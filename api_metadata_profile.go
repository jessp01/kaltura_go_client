/*
Kaltura VPaaS

The Kaltura VPaaS API

API version: 18.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
)


// MetadataProfileApiService MetadataProfileApi service
type MetadataProfileApiService service

type ApiMetadataProfileAddRequest struct {
	ctx context.Context
	ApiService *MetadataProfileApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *MetadataProfileAddRequest
}

func (r ApiMetadataProfileAddRequest) Ks(ks string) ApiMetadataProfileAddRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMetadataProfileAddRequest) Format(format int32) ApiMetadataProfileAddRequest {
	r.format = &format
	return r
}

func (r ApiMetadataProfileAddRequest) ClientTag(clientTag string) ApiMetadataProfileAddRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMetadataProfileAddRequest) PartnerId(partnerId int32) ApiMetadataProfileAddRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMetadataProfileAddRequest) Body(body MetadataProfileAddRequest) ApiMetadataProfileAddRequest {
	r.body = &body
	return r
}

func (r ApiMetadataProfileAddRequest) Execute() (*KalturaMetadataProfile, *http.Response, error) {
	return r.ApiService.MetadataProfileAddExecute(r)
}

/*
MetadataProfileAdd Method for MetadataProfileAdd

Allows you to add a metadata profile object and metadata profile content associated with Kaltura object type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataProfileAddRequest
*/
func (a *MetadataProfileApiService) MetadataProfileAdd(ctx context.Context) ApiMetadataProfileAddRequest {
	return ApiMetadataProfileAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMetadataProfile
func (a *MetadataProfileApiService) MetadataProfileAddExecute(r ApiMetadataProfileAddRequest) (*KalturaMetadataProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMetadataProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataProfileApiService.MetadataProfileAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/metadata_metadataprofile/action/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMetadataProfileAddFromFileRequest struct {
	ctx context.Context
	ApiService *MetadataProfileApiService
	xsdFile **os.File
	ks *string
	format *int32
	metadataProfileMetadataObjectType *string
	metadataProfileName *string
	metadataProfileSystemName *string
	metadataProfileDescription *string
	metadataProfileCreateMode *int32
	metadataProfileDisableReIndexing *bool
	viewsFile **os.File
}

// XSD metadata definition
func (r ApiMetadataProfileAddFromFileRequest) XsdFile(xsdFile *os.File) ApiMetadataProfileAddFromFileRequest {
	r.xsdFile = &xsdFile
	return r
}

func (r ApiMetadataProfileAddFromFileRequest) Ks(ks string) ApiMetadataProfileAddFromFileRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMetadataProfileAddFromFileRequest) Format(format int32) ApiMetadataProfileAddFromFileRequest {
	r.format = &format
	return r
}

// Enum Type: &#x60;KalturaMetadataObjectType&#x60;
func (r ApiMetadataProfileAddFromFileRequest) MetadataProfileMetadataObjectType(metadataProfileMetadataObjectType string) ApiMetadataProfileAddFromFileRequest {
	r.metadataProfileMetadataObjectType = &metadataProfileMetadataObjectType
	return r
}

func (r ApiMetadataProfileAddFromFileRequest) MetadataProfileName(metadataProfileName string) ApiMetadataProfileAddFromFileRequest {
	r.metadataProfileName = &metadataProfileName
	return r
}

func (r ApiMetadataProfileAddFromFileRequest) MetadataProfileSystemName(metadataProfileSystemName string) ApiMetadataProfileAddFromFileRequest {
	r.metadataProfileSystemName = &metadataProfileSystemName
	return r
}

func (r ApiMetadataProfileAddFromFileRequest) MetadataProfileDescription(metadataProfileDescription string) ApiMetadataProfileAddFromFileRequest {
	r.metadataProfileDescription = &metadataProfileDescription
	return r
}

// Enum Type: &#x60;KalturaMetadataProfileCreateMode&#x60;
func (r ApiMetadataProfileAddFromFileRequest) MetadataProfileCreateMode(metadataProfileCreateMode int32) ApiMetadataProfileAddFromFileRequest {
	r.metadataProfileCreateMode = &metadataProfileCreateMode
	return r
}

func (r ApiMetadataProfileAddFromFileRequest) MetadataProfileDisableReIndexing(metadataProfileDisableReIndexing bool) ApiMetadataProfileAddFromFileRequest {
	r.metadataProfileDisableReIndexing = &metadataProfileDisableReIndexing
	return r
}

// UI views definition
func (r ApiMetadataProfileAddFromFileRequest) ViewsFile(viewsFile *os.File) ApiMetadataProfileAddFromFileRequest {
	r.viewsFile = &viewsFile
	return r
}

func (r ApiMetadataProfileAddFromFileRequest) Execute() (*KalturaMetadataProfile, *http.Response, error) {
	return r.ApiService.MetadataProfileAddFromFileExecute(r)
}

/*
MetadataProfileAddFromFile Method for MetadataProfileAddFromFile

Allows you to add a metadata profile object and metadata profile file associated with Kaltura object type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataProfileAddFromFileRequest
*/
func (a *MetadataProfileApiService) MetadataProfileAddFromFile(ctx context.Context) ApiMetadataProfileAddFromFileRequest {
	return ApiMetadataProfileAddFromFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMetadataProfile
func (a *MetadataProfileApiService) MetadataProfileAddFromFileExecute(r ApiMetadataProfileAddFromFileRequest) (*KalturaMetadataProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMetadataProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataProfileApiService.MetadataProfileAddFromFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/metadata_metadataprofile/action/addFromFile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xsdFile == nil {
		return localVarReturnValue, nil, reportError("xsdFile is required and must be specified")
	}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.metadataProfileMetadataObjectType != nil {
		localVarQueryParams.Add("metadataProfile[metadataObjectType]", parameterToString(*r.metadataProfileMetadataObjectType, ""))
	}
	if r.metadataProfileName != nil {
		localVarQueryParams.Add("metadataProfile[name]", parameterToString(*r.metadataProfileName, ""))
	}
	if r.metadataProfileSystemName != nil {
		localVarQueryParams.Add("metadataProfile[systemName]", parameterToString(*r.metadataProfileSystemName, ""))
	}
	if r.metadataProfileDescription != nil {
		localVarQueryParams.Add("metadataProfile[description]", parameterToString(*r.metadataProfileDescription, ""))
	}
	if r.metadataProfileCreateMode != nil {
		localVarQueryParams.Add("metadataProfile[createMode]", parameterToString(*r.metadataProfileCreateMode, ""))
	}
	if r.metadataProfileDisableReIndexing != nil {
		localVarQueryParams.Add("metadataProfile[disableReIndexing]", parameterToString(*r.metadataProfileDisableReIndexing, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var xsdFileLocalVarFormFileName string
	var xsdFileLocalVarFileName     string
	var xsdFileLocalVarFileBytes    []byte

	xsdFileLocalVarFormFileName = "xsdFile"

	xsdFileLocalVarFile := *r.xsdFile
	if xsdFileLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(xsdFileLocalVarFile)
		xsdFileLocalVarFileBytes = fbs
		xsdFileLocalVarFileName = xsdFileLocalVarFile.Name()
		xsdFileLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: xsdFileLocalVarFileBytes, fileName: xsdFileLocalVarFileName, formFileName: xsdFileLocalVarFormFileName})
	var viewsFileLocalVarFormFileName string
	var viewsFileLocalVarFileName     string
	var viewsFileLocalVarFileBytes    []byte

	viewsFileLocalVarFormFileName = "viewsFile"

	var viewsFileLocalVarFile *os.File
	if r.viewsFile != nil {
		viewsFileLocalVarFile = *r.viewsFile
	}
	if viewsFileLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(viewsFileLocalVarFile)
		viewsFileLocalVarFileBytes = fbs
		viewsFileLocalVarFileName = viewsFileLocalVarFile.Name()
		viewsFileLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: viewsFileLocalVarFileBytes, fileName: viewsFileLocalVarFileName, formFileName: viewsFileLocalVarFormFileName})
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMetadataProfileDeleteRequest struct {
	ctx context.Context
	ApiService *MetadataProfileApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AccessControlDeleteRequest
}

func (r ApiMetadataProfileDeleteRequest) Ks(ks string) ApiMetadataProfileDeleteRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMetadataProfileDeleteRequest) Format(format int32) ApiMetadataProfileDeleteRequest {
	r.format = &format
	return r
}

func (r ApiMetadataProfileDeleteRequest) ClientTag(clientTag string) ApiMetadataProfileDeleteRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMetadataProfileDeleteRequest) PartnerId(partnerId int32) ApiMetadataProfileDeleteRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMetadataProfileDeleteRequest) Body(body AccessControlDeleteRequest) ApiMetadataProfileDeleteRequest {
	r.body = &body
	return r
}

func (r ApiMetadataProfileDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataProfileDeleteExecute(r)
}

/*
MetadataProfileDelete Method for MetadataProfileDelete

Delete an existing metadata profile

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataProfileDeleteRequest
*/
func (a *MetadataProfileApiService) MetadataProfileDelete(ctx context.Context) ApiMetadataProfileDeleteRequest {
	return ApiMetadataProfileDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MetadataProfileApiService) MetadataProfileDeleteExecute(r ApiMetadataProfileDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataProfileApiService.MetadataProfileDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/metadata_metadataprofile/action/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataProfileGetRequest struct {
	ctx context.Context
	ApiService *MetadataProfileApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AccessControlDeleteRequest
}

func (r ApiMetadataProfileGetRequest) Ks(ks string) ApiMetadataProfileGetRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMetadataProfileGetRequest) Format(format int32) ApiMetadataProfileGetRequest {
	r.format = &format
	return r
}

func (r ApiMetadataProfileGetRequest) ClientTag(clientTag string) ApiMetadataProfileGetRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMetadataProfileGetRequest) PartnerId(partnerId int32) ApiMetadataProfileGetRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMetadataProfileGetRequest) Body(body AccessControlDeleteRequest) ApiMetadataProfileGetRequest {
	r.body = &body
	return r
}

func (r ApiMetadataProfileGetRequest) Execute() (*KalturaMetadataProfile, *http.Response, error) {
	return r.ApiService.MetadataProfileGetExecute(r)
}

/*
MetadataProfileGet Method for MetadataProfileGet

Retrieve a metadata profile object by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataProfileGetRequest
*/
func (a *MetadataProfileApiService) MetadataProfileGet(ctx context.Context) ApiMetadataProfileGetRequest {
	return ApiMetadataProfileGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMetadataProfile
func (a *MetadataProfileApiService) MetadataProfileGetExecute(r ApiMetadataProfileGetRequest) (*KalturaMetadataProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMetadataProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataProfileApiService.MetadataProfileGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/metadata_metadataprofile/action/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMetadataProfileListRequest struct {
	ctx context.Context
	ApiService *MetadataProfileApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *MetadataProfileListRequest
}

func (r ApiMetadataProfileListRequest) Ks(ks string) ApiMetadataProfileListRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMetadataProfileListRequest) Format(format int32) ApiMetadataProfileListRequest {
	r.format = &format
	return r
}

func (r ApiMetadataProfileListRequest) ClientTag(clientTag string) ApiMetadataProfileListRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMetadataProfileListRequest) PartnerId(partnerId int32) ApiMetadataProfileListRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMetadataProfileListRequest) Body(body MetadataProfileListRequest) ApiMetadataProfileListRequest {
	r.body = &body
	return r
}

func (r ApiMetadataProfileListRequest) Execute() (*KalturaMetadataProfileListResponse, *http.Response, error) {
	return r.ApiService.MetadataProfileListExecute(r)
}

/*
MetadataProfileList Method for MetadataProfileList

List metadata profile objects by filter and pager

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataProfileListRequest
*/
func (a *MetadataProfileApiService) MetadataProfileList(ctx context.Context) ApiMetadataProfileListRequest {
	return ApiMetadataProfileListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMetadataProfileListResponse
func (a *MetadataProfileApiService) MetadataProfileListExecute(r ApiMetadataProfileListRequest) (*KalturaMetadataProfileListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMetadataProfileListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataProfileApiService.MetadataProfileList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/metadata_metadataprofile/action/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMetadataProfileListFieldsRequest struct {
	ctx context.Context
	ApiService *MetadataProfileApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *MetadataProfileListFieldsRequest
}

func (r ApiMetadataProfileListFieldsRequest) Ks(ks string) ApiMetadataProfileListFieldsRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMetadataProfileListFieldsRequest) Format(format int32) ApiMetadataProfileListFieldsRequest {
	r.format = &format
	return r
}

func (r ApiMetadataProfileListFieldsRequest) ClientTag(clientTag string) ApiMetadataProfileListFieldsRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMetadataProfileListFieldsRequest) PartnerId(partnerId int32) ApiMetadataProfileListFieldsRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMetadataProfileListFieldsRequest) Body(body MetadataProfileListFieldsRequest) ApiMetadataProfileListFieldsRequest {
	r.body = &body
	return r
}

func (r ApiMetadataProfileListFieldsRequest) Execute() (*KalturaMetadataProfileFieldListResponse, *http.Response, error) {
	return r.ApiService.MetadataProfileListFieldsExecute(r)
}

/*
MetadataProfileListFields Method for MetadataProfileListFields

List metadata profile fields by metadata profile id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataProfileListFieldsRequest
*/
func (a *MetadataProfileApiService) MetadataProfileListFields(ctx context.Context) ApiMetadataProfileListFieldsRequest {
	return ApiMetadataProfileListFieldsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMetadataProfileFieldListResponse
func (a *MetadataProfileApiService) MetadataProfileListFieldsExecute(r ApiMetadataProfileListFieldsRequest) (*KalturaMetadataProfileFieldListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMetadataProfileFieldListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataProfileApiService.MetadataProfileListFields")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/metadata_metadataprofile/action/listFields"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMetadataProfileRevertRequest struct {
	ctx context.Context
	ApiService *MetadataProfileApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *MetadataProfileRevertRequest
}

func (r ApiMetadataProfileRevertRequest) Ks(ks string) ApiMetadataProfileRevertRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMetadataProfileRevertRequest) Format(format int32) ApiMetadataProfileRevertRequest {
	r.format = &format
	return r
}

func (r ApiMetadataProfileRevertRequest) ClientTag(clientTag string) ApiMetadataProfileRevertRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMetadataProfileRevertRequest) PartnerId(partnerId int32) ApiMetadataProfileRevertRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMetadataProfileRevertRequest) Body(body MetadataProfileRevertRequest) ApiMetadataProfileRevertRequest {
	r.body = &body
	return r
}

func (r ApiMetadataProfileRevertRequest) Execute() (*KalturaMetadataProfile, *http.Response, error) {
	return r.ApiService.MetadataProfileRevertExecute(r)
}

/*
MetadataProfileRevert Method for MetadataProfileRevert

Update an existing metadata object definition file

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataProfileRevertRequest
*/
func (a *MetadataProfileApiService) MetadataProfileRevert(ctx context.Context) ApiMetadataProfileRevertRequest {
	return ApiMetadataProfileRevertRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMetadataProfile
func (a *MetadataProfileApiService) MetadataProfileRevertExecute(r ApiMetadataProfileRevertRequest) (*KalturaMetadataProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMetadataProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataProfileApiService.MetadataProfileRevert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/metadata_metadataprofile/action/revert"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMetadataProfileServeRequest struct {
	ctx context.Context
	ApiService *MetadataProfileApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AccessControlDeleteRequest
}

func (r ApiMetadataProfileServeRequest) Ks(ks string) ApiMetadataProfileServeRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMetadataProfileServeRequest) Format(format int32) ApiMetadataProfileServeRequest {
	r.format = &format
	return r
}

func (r ApiMetadataProfileServeRequest) ClientTag(clientTag string) ApiMetadataProfileServeRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMetadataProfileServeRequest) PartnerId(partnerId int32) ApiMetadataProfileServeRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMetadataProfileServeRequest) Body(body AccessControlDeleteRequest) ApiMetadataProfileServeRequest {
	r.body = &body
	return r
}

func (r ApiMetadataProfileServeRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.MetadataProfileServeExecute(r)
}

/*
MetadataProfileServe Method for MetadataProfileServe

Serves metadata profile XSD file

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataProfileServeRequest
*/
func (a *MetadataProfileApiService) MetadataProfileServe(ctx context.Context) ApiMetadataProfileServeRequest {
	return ApiMetadataProfileServeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *MetadataProfileApiService) MetadataProfileServeExecute(r ApiMetadataProfileServeRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataProfileApiService.MetadataProfileServe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/metadata_metadataprofile/action/serve"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMetadataProfileServeViewRequest struct {
	ctx context.Context
	ApiService *MetadataProfileApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AccessControlDeleteRequest
}

func (r ApiMetadataProfileServeViewRequest) Ks(ks string) ApiMetadataProfileServeViewRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMetadataProfileServeViewRequest) Format(format int32) ApiMetadataProfileServeViewRequest {
	r.format = &format
	return r
}

func (r ApiMetadataProfileServeViewRequest) ClientTag(clientTag string) ApiMetadataProfileServeViewRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMetadataProfileServeViewRequest) PartnerId(partnerId int32) ApiMetadataProfileServeViewRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMetadataProfileServeViewRequest) Body(body AccessControlDeleteRequest) ApiMetadataProfileServeViewRequest {
	r.body = &body
	return r
}

func (r ApiMetadataProfileServeViewRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.MetadataProfileServeViewExecute(r)
}

/*
MetadataProfileServeView Method for MetadataProfileServeView

Serves metadata profile view file

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataProfileServeViewRequest
*/
func (a *MetadataProfileApiService) MetadataProfileServeView(ctx context.Context) ApiMetadataProfileServeViewRequest {
	return ApiMetadataProfileServeViewRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *MetadataProfileApiService) MetadataProfileServeViewExecute(r ApiMetadataProfileServeViewRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataProfileApiService.MetadataProfileServeView")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/metadata_metadataprofile/action/serveView"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMetadataProfileUpdateRequest struct {
	ctx context.Context
	ApiService *MetadataProfileApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *MetadataProfileUpdateRequest
}

func (r ApiMetadataProfileUpdateRequest) Ks(ks string) ApiMetadataProfileUpdateRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMetadataProfileUpdateRequest) Format(format int32) ApiMetadataProfileUpdateRequest {
	r.format = &format
	return r
}

func (r ApiMetadataProfileUpdateRequest) ClientTag(clientTag string) ApiMetadataProfileUpdateRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMetadataProfileUpdateRequest) PartnerId(partnerId int32) ApiMetadataProfileUpdateRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMetadataProfileUpdateRequest) Body(body MetadataProfileUpdateRequest) ApiMetadataProfileUpdateRequest {
	r.body = &body
	return r
}

func (r ApiMetadataProfileUpdateRequest) Execute() (*KalturaMetadataProfile, *http.Response, error) {
	return r.ApiService.MetadataProfileUpdateExecute(r)
}

/*
MetadataProfileUpdate Method for MetadataProfileUpdate

Update an existing metadata object

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataProfileUpdateRequest
*/
func (a *MetadataProfileApiService) MetadataProfileUpdate(ctx context.Context) ApiMetadataProfileUpdateRequest {
	return ApiMetadataProfileUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMetadataProfile
func (a *MetadataProfileApiService) MetadataProfileUpdateExecute(r ApiMetadataProfileUpdateRequest) (*KalturaMetadataProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMetadataProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataProfileApiService.MetadataProfileUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/metadata_metadataprofile/action/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMetadataProfileUpdateDefinitionFromFileRequest struct {
	ctx context.Context
	ApiService *MetadataProfileApiService
	id *int32
	xsdFile **os.File
	ks *string
	format *int32
}

func (r ApiMetadataProfileUpdateDefinitionFromFileRequest) Id(id int32) ApiMetadataProfileUpdateDefinitionFromFileRequest {
	r.id = &id
	return r
}

// XSD metadata definition
func (r ApiMetadataProfileUpdateDefinitionFromFileRequest) XsdFile(xsdFile *os.File) ApiMetadataProfileUpdateDefinitionFromFileRequest {
	r.xsdFile = &xsdFile
	return r
}

func (r ApiMetadataProfileUpdateDefinitionFromFileRequest) Ks(ks string) ApiMetadataProfileUpdateDefinitionFromFileRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMetadataProfileUpdateDefinitionFromFileRequest) Format(format int32) ApiMetadataProfileUpdateDefinitionFromFileRequest {
	r.format = &format
	return r
}

func (r ApiMetadataProfileUpdateDefinitionFromFileRequest) Execute() (*KalturaMetadataProfile, *http.Response, error) {
	return r.ApiService.MetadataProfileUpdateDefinitionFromFileExecute(r)
}

/*
MetadataProfileUpdateDefinitionFromFile Method for MetadataProfileUpdateDefinitionFromFile

Update an existing metadata object definition file

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataProfileUpdateDefinitionFromFileRequest
*/
func (a *MetadataProfileApiService) MetadataProfileUpdateDefinitionFromFile(ctx context.Context) ApiMetadataProfileUpdateDefinitionFromFileRequest {
	return ApiMetadataProfileUpdateDefinitionFromFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMetadataProfile
func (a *MetadataProfileApiService) MetadataProfileUpdateDefinitionFromFileExecute(r ApiMetadataProfileUpdateDefinitionFromFileRequest) (*KalturaMetadataProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMetadataProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataProfileApiService.MetadataProfileUpdateDefinitionFromFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/metadata_metadataprofile/action/updateDefinitionFromFile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.xsdFile == nil {
		return localVarReturnValue, nil, reportError("xsdFile is required and must be specified")
	}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var xsdFileLocalVarFormFileName string
	var xsdFileLocalVarFileName     string
	var xsdFileLocalVarFileBytes    []byte

	xsdFileLocalVarFormFileName = "xsdFile"

	xsdFileLocalVarFile := *r.xsdFile
	if xsdFileLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(xsdFileLocalVarFile)
		xsdFileLocalVarFileBytes = fbs
		xsdFileLocalVarFileName = xsdFileLocalVarFile.Name()
		xsdFileLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: xsdFileLocalVarFileBytes, fileName: xsdFileLocalVarFileName, formFileName: xsdFileLocalVarFormFileName})
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMetadataProfileUpdateTransformationFromFileRequest struct {
	ctx context.Context
	ApiService *MetadataProfileApiService
	id *int32
	xsltFile **os.File
	ks *string
	format *int32
}

func (r ApiMetadataProfileUpdateTransformationFromFileRequest) Id(id int32) ApiMetadataProfileUpdateTransformationFromFileRequest {
	r.id = &id
	return r
}

// XSLT file, will be executed on every metadata add/update
func (r ApiMetadataProfileUpdateTransformationFromFileRequest) XsltFile(xsltFile *os.File) ApiMetadataProfileUpdateTransformationFromFileRequest {
	r.xsltFile = &xsltFile
	return r
}

func (r ApiMetadataProfileUpdateTransformationFromFileRequest) Ks(ks string) ApiMetadataProfileUpdateTransformationFromFileRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMetadataProfileUpdateTransformationFromFileRequest) Format(format int32) ApiMetadataProfileUpdateTransformationFromFileRequest {
	r.format = &format
	return r
}

func (r ApiMetadataProfileUpdateTransformationFromFileRequest) Execute() (*KalturaMetadataProfile, *http.Response, error) {
	return r.ApiService.MetadataProfileUpdateTransformationFromFileExecute(r)
}

/*
MetadataProfileUpdateTransformationFromFile Method for MetadataProfileUpdateTransformationFromFile

Update an existing metadata object XSLT file

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataProfileUpdateTransformationFromFileRequest
*/
func (a *MetadataProfileApiService) MetadataProfileUpdateTransformationFromFile(ctx context.Context) ApiMetadataProfileUpdateTransformationFromFileRequest {
	return ApiMetadataProfileUpdateTransformationFromFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMetadataProfile
func (a *MetadataProfileApiService) MetadataProfileUpdateTransformationFromFileExecute(r ApiMetadataProfileUpdateTransformationFromFileRequest) (*KalturaMetadataProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMetadataProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataProfileApiService.MetadataProfileUpdateTransformationFromFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/metadata_metadataprofile/action/updateTransformationFromFile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.xsltFile == nil {
		return localVarReturnValue, nil, reportError("xsltFile is required and must be specified")
	}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var xsltFileLocalVarFormFileName string
	var xsltFileLocalVarFileName     string
	var xsltFileLocalVarFileBytes    []byte

	xsltFileLocalVarFormFileName = "xsltFile"

	xsltFileLocalVarFile := *r.xsltFile
	if xsltFileLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(xsltFileLocalVarFile)
		xsltFileLocalVarFileBytes = fbs
		xsltFileLocalVarFileName = xsltFileLocalVarFile.Name()
		xsltFileLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: xsltFileLocalVarFileBytes, fileName: xsltFileLocalVarFileName, formFileName: xsltFileLocalVarFormFileName})
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMetadataProfileUpdateViewsFromFileRequest struct {
	ctx context.Context
	ApiService *MetadataProfileApiService
	id *int32
	viewsFile **os.File
	ks *string
	format *int32
}

func (r ApiMetadataProfileUpdateViewsFromFileRequest) Id(id int32) ApiMetadataProfileUpdateViewsFromFileRequest {
	r.id = &id
	return r
}

// UI views file
func (r ApiMetadataProfileUpdateViewsFromFileRequest) ViewsFile(viewsFile *os.File) ApiMetadataProfileUpdateViewsFromFileRequest {
	r.viewsFile = &viewsFile
	return r
}

func (r ApiMetadataProfileUpdateViewsFromFileRequest) Ks(ks string) ApiMetadataProfileUpdateViewsFromFileRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMetadataProfileUpdateViewsFromFileRequest) Format(format int32) ApiMetadataProfileUpdateViewsFromFileRequest {
	r.format = &format
	return r
}

func (r ApiMetadataProfileUpdateViewsFromFileRequest) Execute() (*KalturaMetadataProfile, *http.Response, error) {
	return r.ApiService.MetadataProfileUpdateViewsFromFileExecute(r)
}

/*
MetadataProfileUpdateViewsFromFile Method for MetadataProfileUpdateViewsFromFile

Update an existing metadata object views file

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMetadataProfileUpdateViewsFromFileRequest
*/
func (a *MetadataProfileApiService) MetadataProfileUpdateViewsFromFile(ctx context.Context) ApiMetadataProfileUpdateViewsFromFileRequest {
	return ApiMetadataProfileUpdateViewsFromFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMetadataProfile
func (a *MetadataProfileApiService) MetadataProfileUpdateViewsFromFileExecute(r ApiMetadataProfileUpdateViewsFromFileRequest) (*KalturaMetadataProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMetadataProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataProfileApiService.MetadataProfileUpdateViewsFromFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/metadata_metadataprofile/action/updateViewsFromFile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.viewsFile == nil {
		return localVarReturnValue, nil, reportError("viewsFile is required and must be specified")
	}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var viewsFileLocalVarFormFileName string
	var viewsFileLocalVarFileName     string
	var viewsFileLocalVarFileBytes    []byte

	viewsFileLocalVarFormFileName = "viewsFile"

	viewsFileLocalVarFile := *r.viewsFile
	if viewsFileLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(viewsFileLocalVarFile)
		viewsFileLocalVarFileBytes = fbs
		viewsFileLocalVarFileName = viewsFileLocalVarFile.Name()
		viewsFileLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: viewsFileLocalVarFileBytes, fileName: viewsFileLocalVarFileName, formFileName: viewsFileLocalVarFormFileName})
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
