/*
Kaltura VPaaS

The Kaltura VPaaS API

API version: 18.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// ReportApiService ReportApi service
type ReportApiService service

type ApiReportExecuteRequest struct {
	ctx context.Context
	ApiService *ReportApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *ReportExecuteRequest
}

func (r ApiReportExecuteRequest) Ks(ks string) ApiReportExecuteRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiReportExecuteRequest) Format(format int32) ApiReportExecuteRequest {
	r.format = &format
	return r
}

func (r ApiReportExecuteRequest) ClientTag(clientTag string) ApiReportExecuteRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiReportExecuteRequest) PartnerId(partnerId int32) ApiReportExecuteRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiReportExecuteRequest) Body(body ReportExecuteRequest) ApiReportExecuteRequest {
	r.body = &body
	return r
}

func (r ApiReportExecuteRequest) Execute() (*KalturaReportResponse, *http.Response, error) {
	return r.ApiService.ReportExecuteExecute(r)
}

/*
ReportExecute Method for ReportExecute

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReportExecuteRequest
*/
func (a *ReportApiService) ReportExecute(ctx context.Context) ApiReportExecuteRequest {
	return ApiReportExecuteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaReportResponse
func (a *ReportApiService) ReportExecuteExecute(r ApiReportExecuteRequest) (*KalturaReportResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaReportResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportApiService.ReportExecute")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/report/action/execute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReportExportToCsvRequest struct {
	ctx context.Context
	ApiService *ReportApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *ReportExportToCsvRequest
}

func (r ApiReportExportToCsvRequest) Ks(ks string) ApiReportExportToCsvRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiReportExportToCsvRequest) Format(format int32) ApiReportExportToCsvRequest {
	r.format = &format
	return r
}

func (r ApiReportExportToCsvRequest) ClientTag(clientTag string) ApiReportExportToCsvRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiReportExportToCsvRequest) PartnerId(partnerId int32) ApiReportExportToCsvRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiReportExportToCsvRequest) Body(body ReportExportToCsvRequest) ApiReportExportToCsvRequest {
	r.body = &body
	return r
}

func (r ApiReportExportToCsvRequest) Execute() (*KalturaReportExportResponse, *http.Response, error) {
	return r.ApiService.ReportExportToCsvExecute(r)
}

/*
ReportExportToCsv Method for ReportExportToCsv

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReportExportToCsvRequest
*/
func (a *ReportApiService) ReportExportToCsv(ctx context.Context) ApiReportExportToCsvRequest {
	return ApiReportExportToCsvRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaReportExportResponse
func (a *ReportApiService) ReportExportToCsvExecute(r ApiReportExportToCsvRequest) (*KalturaReportExportResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaReportExportResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportApiService.ReportExportToCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/report/action/exportToCsv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReportGetBaseTotalRequest struct {
	ctx context.Context
	ApiService *ReportApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *ReportGetBaseTotalRequest
}

func (r ApiReportGetBaseTotalRequest) Ks(ks string) ApiReportGetBaseTotalRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiReportGetBaseTotalRequest) Format(format int32) ApiReportGetBaseTotalRequest {
	r.format = &format
	return r
}

func (r ApiReportGetBaseTotalRequest) ClientTag(clientTag string) ApiReportGetBaseTotalRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiReportGetBaseTotalRequest) PartnerId(partnerId int32) ApiReportGetBaseTotalRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiReportGetBaseTotalRequest) Body(body ReportGetBaseTotalRequest) ApiReportGetBaseTotalRequest {
	r.body = &body
	return r
}

func (r ApiReportGetBaseTotalRequest) Execute() ([]KalturaReportBaseTotal, *http.Response, error) {
	return r.ApiService.ReportGetBaseTotalExecute(r)
}

/*
ReportGetBaseTotal Method for ReportGetBaseTotal

report getBaseTotal action allows to get the total base for storage reports

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReportGetBaseTotalRequest
*/
func (a *ReportApiService) ReportGetBaseTotal(ctx context.Context) ApiReportGetBaseTotalRequest {
	return ApiReportGetBaseTotalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []KalturaReportBaseTotal
func (a *ReportApiService) ReportGetBaseTotalExecute(r ApiReportGetBaseTotalRequest) ([]KalturaReportBaseTotal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KalturaReportBaseTotal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportApiService.ReportGetBaseTotal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/report/action/getBaseTotal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReportGetCsvRequest struct {
	ctx context.Context
	ApiService *ReportApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *ReportGetCsvRequest
}

func (r ApiReportGetCsvRequest) Ks(ks string) ApiReportGetCsvRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiReportGetCsvRequest) Format(format int32) ApiReportGetCsvRequest {
	r.format = &format
	return r
}

func (r ApiReportGetCsvRequest) ClientTag(clientTag string) ApiReportGetCsvRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiReportGetCsvRequest) PartnerId(partnerId int32) ApiReportGetCsvRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiReportGetCsvRequest) Body(body ReportGetCsvRequest) ApiReportGetCsvRequest {
	r.body = &body
	return r
}

func (r ApiReportGetCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ReportGetCsvExecute(r)
}

/*
ReportGetCsv Method for ReportGetCsv

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReportGetCsvRequest
*/
func (a *ReportApiService) ReportGetCsv(ctx context.Context) ApiReportGetCsvRequest {
	return ApiReportGetCsvRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *ReportApiService) ReportGetCsvExecute(r ApiReportGetCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportApiService.ReportGetCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/report/action/getCsv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReportGetCsvFromStringParamsRequest struct {
	ctx context.Context
	ApiService *ReportApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *ReportGetCsvFromStringParamsRequest
}

func (r ApiReportGetCsvFromStringParamsRequest) Ks(ks string) ApiReportGetCsvFromStringParamsRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiReportGetCsvFromStringParamsRequest) Format(format int32) ApiReportGetCsvFromStringParamsRequest {
	r.format = &format
	return r
}

func (r ApiReportGetCsvFromStringParamsRequest) ClientTag(clientTag string) ApiReportGetCsvFromStringParamsRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiReportGetCsvFromStringParamsRequest) PartnerId(partnerId int32) ApiReportGetCsvFromStringParamsRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiReportGetCsvFromStringParamsRequest) Body(body ReportGetCsvFromStringParamsRequest) ApiReportGetCsvFromStringParamsRequest {
	r.body = &body
	return r
}

func (r ApiReportGetCsvFromStringParamsRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ReportGetCsvFromStringParamsExecute(r)
}

/*
ReportGetCsvFromStringParams Method for ReportGetCsvFromStringParams

Returns report CSV file executed by string params with the following convention: param1=value1;param2=value2

excludedFields can be supplied comma separated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReportGetCsvFromStringParamsRequest
*/
func (a *ReportApiService) ReportGetCsvFromStringParams(ctx context.Context) ApiReportGetCsvFromStringParamsRequest {
	return ApiReportGetCsvFromStringParamsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *ReportApiService) ReportGetCsvFromStringParamsExecute(r ApiReportGetCsvFromStringParamsRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportApiService.ReportGetCsvFromStringParams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/report/action/getCsvFromStringParams"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReportGetGraphsRequest struct {
	ctx context.Context
	ApiService *ReportApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *ReportGetGraphsRequest
}

func (r ApiReportGetGraphsRequest) Ks(ks string) ApiReportGetGraphsRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiReportGetGraphsRequest) Format(format int32) ApiReportGetGraphsRequest {
	r.format = &format
	return r
}

func (r ApiReportGetGraphsRequest) ClientTag(clientTag string) ApiReportGetGraphsRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiReportGetGraphsRequest) PartnerId(partnerId int32) ApiReportGetGraphsRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiReportGetGraphsRequest) Body(body ReportGetGraphsRequest) ApiReportGetGraphsRequest {
	r.body = &body
	return r
}

func (r ApiReportGetGraphsRequest) Execute() ([]KalturaReportGraph, *http.Response, error) {
	return r.ApiService.ReportGetGraphsExecute(r)
}

/*
ReportGetGraphs Method for ReportGetGraphs

report getGraphs action allows to get a graph data for a specific report.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReportGetGraphsRequest
*/
func (a *ReportApiService) ReportGetGraphs(ctx context.Context) ApiReportGetGraphsRequest {
	return ApiReportGetGraphsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []KalturaReportGraph
func (a *ReportApiService) ReportGetGraphsExecute(r ApiReportGetGraphsRequest) ([]KalturaReportGraph, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KalturaReportGraph
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportApiService.ReportGetGraphs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/report/action/getGraphs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReportGetTableRequest struct {
	ctx context.Context
	ApiService *ReportApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *ReportGetTableRequest
}

func (r ApiReportGetTableRequest) Ks(ks string) ApiReportGetTableRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiReportGetTableRequest) Format(format int32) ApiReportGetTableRequest {
	r.format = &format
	return r
}

func (r ApiReportGetTableRequest) ClientTag(clientTag string) ApiReportGetTableRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiReportGetTableRequest) PartnerId(partnerId int32) ApiReportGetTableRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiReportGetTableRequest) Body(body ReportGetTableRequest) ApiReportGetTableRequest {
	r.body = &body
	return r
}

func (r ApiReportGetTableRequest) Execute() (*KalturaReportTable, *http.Response, error) {
	return r.ApiService.ReportGetTableExecute(r)
}

/*
ReportGetTable Method for ReportGetTable

report getTable action allows to get a graph data for a specific report.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReportGetTableRequest
*/
func (a *ReportApiService) ReportGetTable(ctx context.Context) ApiReportGetTableRequest {
	return ApiReportGetTableRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaReportTable
func (a *ReportApiService) ReportGetTableExecute(r ApiReportGetTableRequest) (*KalturaReportTable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaReportTable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportApiService.ReportGetTable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/report/action/getTable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReportGetTotalRequest struct {
	ctx context.Context
	ApiService *ReportApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *ReportGetBaseTotalRequest
}

func (r ApiReportGetTotalRequest) Ks(ks string) ApiReportGetTotalRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiReportGetTotalRequest) Format(format int32) ApiReportGetTotalRequest {
	r.format = &format
	return r
}

func (r ApiReportGetTotalRequest) ClientTag(clientTag string) ApiReportGetTotalRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiReportGetTotalRequest) PartnerId(partnerId int32) ApiReportGetTotalRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiReportGetTotalRequest) Body(body ReportGetBaseTotalRequest) ApiReportGetTotalRequest {
	r.body = &body
	return r
}

func (r ApiReportGetTotalRequest) Execute() (*KalturaReportTotal, *http.Response, error) {
	return r.ApiService.ReportGetTotalExecute(r)
}

/*
ReportGetTotal Method for ReportGetTotal

report getTotal action allows to get a graph data for a specific report.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReportGetTotalRequest
*/
func (a *ReportApiService) ReportGetTotal(ctx context.Context) ApiReportGetTotalRequest {
	return ApiReportGetTotalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaReportTotal
func (a *ReportApiService) ReportGetTotalExecute(r ApiReportGetTotalRequest) (*KalturaReportTotal, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaReportTotal
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportApiService.ReportGetTotal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/report/action/getTotal"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReportGetUrlForReportAsCsvRequest struct {
	ctx context.Context
	ApiService *ReportApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *ReportGetUrlForReportAsCsvRequest
}

func (r ApiReportGetUrlForReportAsCsvRequest) Ks(ks string) ApiReportGetUrlForReportAsCsvRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiReportGetUrlForReportAsCsvRequest) Format(format int32) ApiReportGetUrlForReportAsCsvRequest {
	r.format = &format
	return r
}

func (r ApiReportGetUrlForReportAsCsvRequest) ClientTag(clientTag string) ApiReportGetUrlForReportAsCsvRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiReportGetUrlForReportAsCsvRequest) PartnerId(partnerId int32) ApiReportGetUrlForReportAsCsvRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiReportGetUrlForReportAsCsvRequest) Body(body ReportGetUrlForReportAsCsvRequest) ApiReportGetUrlForReportAsCsvRequest {
	r.body = &body
	return r
}

func (r ApiReportGetUrlForReportAsCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ReportGetUrlForReportAsCsvExecute(r)
}

/*
ReportGetUrlForReportAsCsv Method for ReportGetUrlForReportAsCsv

will create a CSV file for the given report and return the URL to access it

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReportGetUrlForReportAsCsvRequest
*/
func (a *ReportApiService) ReportGetUrlForReportAsCsv(ctx context.Context) ApiReportGetUrlForReportAsCsvRequest {
	return ApiReportGetUrlForReportAsCsvRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *ReportApiService) ReportGetUrlForReportAsCsvExecute(r ApiReportGetUrlForReportAsCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportApiService.ReportGetUrlForReportAsCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/report/action/getUrlForReportAsCsv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReportServeRequest struct {
	ctx context.Context
	ApiService *ReportApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AnnotationDeleteRequest
}

func (r ApiReportServeRequest) Ks(ks string) ApiReportServeRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiReportServeRequest) Format(format int32) ApiReportServeRequest {
	r.format = &format
	return r
}

func (r ApiReportServeRequest) ClientTag(clientTag string) ApiReportServeRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiReportServeRequest) PartnerId(partnerId int32) ApiReportServeRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiReportServeRequest) Body(body AnnotationDeleteRequest) ApiReportServeRequest {
	r.body = &body
	return r
}

func (r ApiReportServeRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ReportServeExecute(r)
}

/*
ReportServe Method for ReportServe

Will serve a requested report

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReportServeRequest
*/
func (a *ReportApiService) ReportServe(ctx context.Context) ApiReportServeRequest {
	return ApiReportServeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *ReportApiService) ReportServeExecute(r ApiReportServeRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReportApiService.ReportServe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/report/action/serve"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
