/*
Kaltura VPaaS

The Kaltura VPaaS API

API version: 18.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
)


// BaseEntryApiService BaseEntryApi service
type BaseEntryApiService service

type ApiBaseEntryAddRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryAddRequest
}

func (r ApiBaseEntryAddRequest) Ks(ks string) ApiBaseEntryAddRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryAddRequest) Format(format int32) ApiBaseEntryAddRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryAddRequest) ClientTag(clientTag string) ApiBaseEntryAddRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBaseEntryAddRequest) PartnerId(partnerId int32) ApiBaseEntryAddRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBaseEntryAddRequest) Body(body BaseEntryAddRequest) ApiBaseEntryAddRequest {
	r.body = &body
	return r
}

func (r ApiBaseEntryAddRequest) Execute() (*KalturaBaseEntry, *http.Response, error) {
	return r.ApiService.BaseEntryAddExecute(r)
}

/*
BaseEntryAdd Method for BaseEntryAdd

Generic add entry, should be used when the uploaded entry type is not known.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryAddRequest
*/
func (a *BaseEntryApiService) BaseEntryAdd(ctx context.Context) ApiBaseEntryAddRequest {
	return ApiBaseEntryAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBaseEntry
func (a *BaseEntryApiService) BaseEntryAddExecute(r ApiBaseEntryAddRequest) (*KalturaBaseEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBaseEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBaseEntryAddContentRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryAddContentRequest
}

func (r ApiBaseEntryAddContentRequest) Ks(ks string) ApiBaseEntryAddContentRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryAddContentRequest) Format(format int32) ApiBaseEntryAddContentRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryAddContentRequest) ClientTag(clientTag string) ApiBaseEntryAddContentRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBaseEntryAddContentRequest) PartnerId(partnerId int32) ApiBaseEntryAddContentRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBaseEntryAddContentRequest) Body(body BaseEntryAddContentRequest) ApiBaseEntryAddContentRequest {
	r.body = &body
	return r
}

func (r ApiBaseEntryAddContentRequest) Execute() (*KalturaBaseEntry, *http.Response, error) {
	return r.ApiService.BaseEntryAddContentExecute(r)
}

/*
BaseEntryAddContent Method for BaseEntryAddContent

Attach content resource to entry in status NO_MEDIA

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryAddContentRequest
*/
func (a *BaseEntryApiService) BaseEntryAddContent(ctx context.Context) ApiBaseEntryAddContentRequest {
	return ApiBaseEntryAddContentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBaseEntry
func (a *BaseEntryApiService) BaseEntryAddContentExecute(r ApiBaseEntryAddContentRequest) (*KalturaBaseEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBaseEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryAddContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/addContent"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBaseEntryAddFromUploadedFileRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryAddFromUploadedFileRequest
}

func (r ApiBaseEntryAddFromUploadedFileRequest) Ks(ks string) ApiBaseEntryAddFromUploadedFileRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryAddFromUploadedFileRequest) Format(format int32) ApiBaseEntryAddFromUploadedFileRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryAddFromUploadedFileRequest) ClientTag(clientTag string) ApiBaseEntryAddFromUploadedFileRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBaseEntryAddFromUploadedFileRequest) PartnerId(partnerId int32) ApiBaseEntryAddFromUploadedFileRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBaseEntryAddFromUploadedFileRequest) Body(body BaseEntryAddFromUploadedFileRequest) ApiBaseEntryAddFromUploadedFileRequest {
	r.body = &body
	return r
}

func (r ApiBaseEntryAddFromUploadedFileRequest) Execute() (*KalturaBaseEntry, *http.Response, error) {
	return r.ApiService.BaseEntryAddFromUploadedFileExecute(r)
}

/*
BaseEntryAddFromUploadedFile Method for BaseEntryAddFromUploadedFile

Generic add entry using an uploaded file, should be used when the uploaded entry type is not known.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryAddFromUploadedFileRequest
*/
func (a *BaseEntryApiService) BaseEntryAddFromUploadedFile(ctx context.Context) ApiBaseEntryAddFromUploadedFileRequest {
	return ApiBaseEntryAddFromUploadedFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBaseEntry
func (a *BaseEntryApiService) BaseEntryAddFromUploadedFileExecute(r ApiBaseEntryAddFromUploadedFileRequest) (*KalturaBaseEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBaseEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryAddFromUploadedFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/addFromUploadedFile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBaseEntryAnonymousRankRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryAnonymousRankRequest
}

func (r ApiBaseEntryAnonymousRankRequest) Ks(ks string) ApiBaseEntryAnonymousRankRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryAnonymousRankRequest) Format(format int32) ApiBaseEntryAnonymousRankRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryAnonymousRankRequest) ClientTag(clientTag string) ApiBaseEntryAnonymousRankRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBaseEntryAnonymousRankRequest) PartnerId(partnerId int32) ApiBaseEntryAnonymousRankRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBaseEntryAnonymousRankRequest) Body(body BaseEntryAnonymousRankRequest) ApiBaseEntryAnonymousRankRequest {
	r.body = &body
	return r
}

func (r ApiBaseEntryAnonymousRankRequest) Execute() (*http.Response, error) {
	return r.ApiService.BaseEntryAnonymousRankExecute(r)
}

/*
BaseEntryAnonymousRank Method for BaseEntryAnonymousRank

Anonymously rank an entry, no validation is done on duplicate rankings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryAnonymousRankRequest
*/
func (a *BaseEntryApiService) BaseEntryAnonymousRank(ctx context.Context) ApiBaseEntryAnonymousRankRequest {
	return ApiBaseEntryAnonymousRankRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *BaseEntryApiService) BaseEntryAnonymousRankExecute(r ApiBaseEntryAnonymousRankRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryAnonymousRank")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/anonymousRank"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBaseEntryApproveRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryApproveRequest
}

func (r ApiBaseEntryApproveRequest) Ks(ks string) ApiBaseEntryApproveRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryApproveRequest) Format(format int32) ApiBaseEntryApproveRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryApproveRequest) ClientTag(clientTag string) ApiBaseEntryApproveRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBaseEntryApproveRequest) PartnerId(partnerId int32) ApiBaseEntryApproveRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBaseEntryApproveRequest) Body(body BaseEntryApproveRequest) ApiBaseEntryApproveRequest {
	r.body = &body
	return r
}

func (r ApiBaseEntryApproveRequest) Execute() (*http.Response, error) {
	return r.ApiService.BaseEntryApproveExecute(r)
}

/*
BaseEntryApprove Method for BaseEntryApprove

Approve the entry and mark the pending flags (if any) as moderated (this will make the entry playable).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryApproveRequest
*/
func (a *BaseEntryApiService) BaseEntryApprove(ctx context.Context) ApiBaseEntryApproveRequest {
	return ApiBaseEntryApproveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *BaseEntryApiService) BaseEntryApproveExecute(r ApiBaseEntryApproveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryApprove")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/approve"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBaseEntryCloneRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryCloneRequest
}

func (r ApiBaseEntryCloneRequest) Ks(ks string) ApiBaseEntryCloneRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryCloneRequest) Format(format int32) ApiBaseEntryCloneRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryCloneRequest) ClientTag(clientTag string) ApiBaseEntryCloneRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBaseEntryCloneRequest) PartnerId(partnerId int32) ApiBaseEntryCloneRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBaseEntryCloneRequest) Body(body BaseEntryCloneRequest) ApiBaseEntryCloneRequest {
	r.body = &body
	return r
}

func (r ApiBaseEntryCloneRequest) Execute() (*KalturaBaseEntry, *http.Response, error) {
	return r.ApiService.BaseEntryCloneExecute(r)
}

/*
BaseEntryClone Method for BaseEntryClone

Clone an entry with optional attributes to apply to the clone

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryCloneRequest
*/
func (a *BaseEntryApiService) BaseEntryClone(ctx context.Context) ApiBaseEntryCloneRequest {
	return ApiBaseEntryCloneRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBaseEntry
func (a *BaseEntryApiService) BaseEntryCloneExecute(r ApiBaseEntryCloneRequest) (*KalturaBaseEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBaseEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryClone")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/clone"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBaseEntryCountRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryCountRequest
}

func (r ApiBaseEntryCountRequest) Ks(ks string) ApiBaseEntryCountRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryCountRequest) Format(format int32) ApiBaseEntryCountRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryCountRequest) ClientTag(clientTag string) ApiBaseEntryCountRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBaseEntryCountRequest) PartnerId(partnerId int32) ApiBaseEntryCountRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBaseEntryCountRequest) Body(body BaseEntryCountRequest) ApiBaseEntryCountRequest {
	r.body = &body
	return r
}

func (r ApiBaseEntryCountRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.BaseEntryCountExecute(r)
}

/*
BaseEntryCount Method for BaseEntryCount

Count base entries by filter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryCountRequest
*/
func (a *BaseEntryApiService) BaseEntryCount(ctx context.Context) ApiBaseEntryCountRequest {
	return ApiBaseEntryCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return int32
func (a *BaseEntryApiService) BaseEntryCountExecute(r ApiBaseEntryCountRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBaseEntryDeleteRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryApproveRequest
}

func (r ApiBaseEntryDeleteRequest) Ks(ks string) ApiBaseEntryDeleteRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryDeleteRequest) Format(format int32) ApiBaseEntryDeleteRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryDeleteRequest) ClientTag(clientTag string) ApiBaseEntryDeleteRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBaseEntryDeleteRequest) PartnerId(partnerId int32) ApiBaseEntryDeleteRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBaseEntryDeleteRequest) Body(body BaseEntryApproveRequest) ApiBaseEntryDeleteRequest {
	r.body = &body
	return r
}

func (r ApiBaseEntryDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.BaseEntryDeleteExecute(r)
}

/*
BaseEntryDelete Method for BaseEntryDelete

Delete an entry.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryDeleteRequest
*/
func (a *BaseEntryApiService) BaseEntryDelete(ctx context.Context) ApiBaseEntryDeleteRequest {
	return ApiBaseEntryDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *BaseEntryApiService) BaseEntryDeleteExecute(r ApiBaseEntryDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBaseEntryExportRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryExportRequest
}

func (r ApiBaseEntryExportRequest) Ks(ks string) ApiBaseEntryExportRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryExportRequest) Format(format int32) ApiBaseEntryExportRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryExportRequest) ClientTag(clientTag string) ApiBaseEntryExportRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBaseEntryExportRequest) PartnerId(partnerId int32) ApiBaseEntryExportRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBaseEntryExportRequest) Body(body BaseEntryExportRequest) ApiBaseEntryExportRequest {
	r.body = &body
	return r
}

func (r ApiBaseEntryExportRequest) Execute() (*KalturaBaseEntry, *http.Response, error) {
	return r.ApiService.BaseEntryExportExecute(r)
}

/*
BaseEntryExport Method for BaseEntryExport

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryExportRequest
*/
func (a *BaseEntryApiService) BaseEntryExport(ctx context.Context) ApiBaseEntryExportRequest {
	return ApiBaseEntryExportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBaseEntry
func (a *BaseEntryApiService) BaseEntryExportExecute(r ApiBaseEntryExportRequest) (*KalturaBaseEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBaseEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryExport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/export"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBaseEntryExportToCsvRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryExportToCsvRequest
}

func (r ApiBaseEntryExportToCsvRequest) Ks(ks string) ApiBaseEntryExportToCsvRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryExportToCsvRequest) Format(format int32) ApiBaseEntryExportToCsvRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryExportToCsvRequest) ClientTag(clientTag string) ApiBaseEntryExportToCsvRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBaseEntryExportToCsvRequest) PartnerId(partnerId int32) ApiBaseEntryExportToCsvRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBaseEntryExportToCsvRequest) Body(body BaseEntryExportToCsvRequest) ApiBaseEntryExportToCsvRequest {
	r.body = &body
	return r
}

func (r ApiBaseEntryExportToCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.BaseEntryExportToCsvExecute(r)
}

/*
BaseEntryExportToCsv Method for BaseEntryExportToCsv

add batch job that sends an email with a link to download an updated CSV that contains list of entries

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryExportToCsvRequest
*/
func (a *BaseEntryApiService) BaseEntryExportToCsv(ctx context.Context) ApiBaseEntryExportToCsvRequest {
	return ApiBaseEntryExportToCsvRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *BaseEntryApiService) BaseEntryExportToCsvExecute(r ApiBaseEntryExportToCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryExportToCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/exportToCsv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBaseEntryFlagRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryFlagRequest
}

func (r ApiBaseEntryFlagRequest) Ks(ks string) ApiBaseEntryFlagRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryFlagRequest) Format(format int32) ApiBaseEntryFlagRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryFlagRequest) ClientTag(clientTag string) ApiBaseEntryFlagRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBaseEntryFlagRequest) PartnerId(partnerId int32) ApiBaseEntryFlagRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBaseEntryFlagRequest) Body(body BaseEntryFlagRequest) ApiBaseEntryFlagRequest {
	r.body = &body
	return r
}

func (r ApiBaseEntryFlagRequest) Execute() (*http.Response, error) {
	return r.ApiService.BaseEntryFlagExecute(r)
}

/*
BaseEntryFlag Method for BaseEntryFlag

Flag inappropriate entry for moderation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryFlagRequest
*/
func (a *BaseEntryApiService) BaseEntryFlag(ctx context.Context) ApiBaseEntryFlagRequest {
	return ApiBaseEntryFlagRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *BaseEntryApiService) BaseEntryFlagExecute(r ApiBaseEntryFlagRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryFlag")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/flag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBaseEntryGetRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryGetRequest
}

func (r ApiBaseEntryGetRequest) Ks(ks string) ApiBaseEntryGetRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryGetRequest) Format(format int32) ApiBaseEntryGetRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryGetRequest) ClientTag(clientTag string) ApiBaseEntryGetRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBaseEntryGetRequest) PartnerId(partnerId int32) ApiBaseEntryGetRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBaseEntryGetRequest) Body(body BaseEntryGetRequest) ApiBaseEntryGetRequest {
	r.body = &body
	return r
}

func (r ApiBaseEntryGetRequest) Execute() (*KalturaBaseEntry, *http.Response, error) {
	return r.ApiService.BaseEntryGetExecute(r)
}

/*
BaseEntryGet Method for BaseEntryGet

Get base entry by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryGetRequest
*/
func (a *BaseEntryApiService) BaseEntryGet(ctx context.Context) ApiBaseEntryGetRequest {
	return ApiBaseEntryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBaseEntry
func (a *BaseEntryApiService) BaseEntryGetExecute(r ApiBaseEntryGetRequest) (*KalturaBaseEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBaseEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBaseEntryGetByIdsRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryGetByIdsRequest
}

func (r ApiBaseEntryGetByIdsRequest) Ks(ks string) ApiBaseEntryGetByIdsRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryGetByIdsRequest) Format(format int32) ApiBaseEntryGetByIdsRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryGetByIdsRequest) ClientTag(clientTag string) ApiBaseEntryGetByIdsRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBaseEntryGetByIdsRequest) PartnerId(partnerId int32) ApiBaseEntryGetByIdsRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBaseEntryGetByIdsRequest) Body(body BaseEntryGetByIdsRequest) ApiBaseEntryGetByIdsRequest {
	r.body = &body
	return r
}

func (r ApiBaseEntryGetByIdsRequest) Execute() ([]KalturaBaseEntry, *http.Response, error) {
	return r.ApiService.BaseEntryGetByIdsExecute(r)
}

/*
BaseEntryGetByIds Method for BaseEntryGetByIds

Get an array of KalturaBaseEntry objects by a comma-separated list of ids.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryGetByIdsRequest
*/
func (a *BaseEntryApiService) BaseEntryGetByIds(ctx context.Context) ApiBaseEntryGetByIdsRequest {
	return ApiBaseEntryGetByIdsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []KalturaBaseEntry
func (a *BaseEntryApiService) BaseEntryGetByIdsExecute(r ApiBaseEntryGetByIdsRequest) ([]KalturaBaseEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KalturaBaseEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryGetByIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/getByIds"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBaseEntryGetContextDataRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryGetContextDataRequest
}

func (r ApiBaseEntryGetContextDataRequest) Ks(ks string) ApiBaseEntryGetContextDataRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryGetContextDataRequest) Format(format int32) ApiBaseEntryGetContextDataRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryGetContextDataRequest) ClientTag(clientTag string) ApiBaseEntryGetContextDataRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBaseEntryGetContextDataRequest) PartnerId(partnerId int32) ApiBaseEntryGetContextDataRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBaseEntryGetContextDataRequest) Body(body BaseEntryGetContextDataRequest) ApiBaseEntryGetContextDataRequest {
	r.body = &body
	return r
}

func (r ApiBaseEntryGetContextDataRequest) Execute() (*KalturaEntryContextDataResult, *http.Response, error) {
	return r.ApiService.BaseEntryGetContextDataExecute(r)
}

/*
BaseEntryGetContextData Method for BaseEntryGetContextData

This action delivers entry-related data, based on the user's context: access control, restriction, playback format and storage information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryGetContextDataRequest
*/
func (a *BaseEntryApiService) BaseEntryGetContextData(ctx context.Context) ApiBaseEntryGetContextDataRequest {
	return ApiBaseEntryGetContextDataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEntryContextDataResult
func (a *BaseEntryApiService) BaseEntryGetContextDataExecute(r ApiBaseEntryGetContextDataRequest) (*KalturaEntryContextDataResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEntryContextDataResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryGetContextData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/getContextData"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBaseEntryGetPlaybackContextRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryGetPlaybackContextRequest
}

func (r ApiBaseEntryGetPlaybackContextRequest) Ks(ks string) ApiBaseEntryGetPlaybackContextRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryGetPlaybackContextRequest) Format(format int32) ApiBaseEntryGetPlaybackContextRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryGetPlaybackContextRequest) ClientTag(clientTag string) ApiBaseEntryGetPlaybackContextRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBaseEntryGetPlaybackContextRequest) PartnerId(partnerId int32) ApiBaseEntryGetPlaybackContextRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBaseEntryGetPlaybackContextRequest) Body(body BaseEntryGetPlaybackContextRequest) ApiBaseEntryGetPlaybackContextRequest {
	r.body = &body
	return r
}

func (r ApiBaseEntryGetPlaybackContextRequest) Execute() (*KalturaPlaybackContext, *http.Response, error) {
	return r.ApiService.BaseEntryGetPlaybackContextExecute(r)
}

/*
BaseEntryGetPlaybackContext Method for BaseEntryGetPlaybackContext

This action delivers all data relevant for player

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryGetPlaybackContextRequest
*/
func (a *BaseEntryApiService) BaseEntryGetPlaybackContext(ctx context.Context) ApiBaseEntryGetPlaybackContextRequest {
	return ApiBaseEntryGetPlaybackContextRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaPlaybackContext
func (a *BaseEntryApiService) BaseEntryGetPlaybackContextExecute(r ApiBaseEntryGetPlaybackContextRequest) (*KalturaPlaybackContext, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaPlaybackContext
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryGetPlaybackContext")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/getPlaybackContext"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBaseEntryGetRemotePathsRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryApproveRequest
}

func (r ApiBaseEntryGetRemotePathsRequest) Ks(ks string) ApiBaseEntryGetRemotePathsRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryGetRemotePathsRequest) Format(format int32) ApiBaseEntryGetRemotePathsRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryGetRemotePathsRequest) ClientTag(clientTag string) ApiBaseEntryGetRemotePathsRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBaseEntryGetRemotePathsRequest) PartnerId(partnerId int32) ApiBaseEntryGetRemotePathsRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBaseEntryGetRemotePathsRequest) Body(body BaseEntryApproveRequest) ApiBaseEntryGetRemotePathsRequest {
	r.body = &body
	return r
}

func (r ApiBaseEntryGetRemotePathsRequest) Execute() (*KalturaRemotePathListResponse, *http.Response, error) {
	return r.ApiService.BaseEntryGetRemotePathsExecute(r)
}

/*
BaseEntryGetRemotePaths Method for BaseEntryGetRemotePaths

Get remote storage existing paths for the asset.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryGetRemotePathsRequest
*/
func (a *BaseEntryApiService) BaseEntryGetRemotePaths(ctx context.Context) ApiBaseEntryGetRemotePathsRequest {
	return ApiBaseEntryGetRemotePathsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaRemotePathListResponse
func (a *BaseEntryApiService) BaseEntryGetRemotePathsExecute(r ApiBaseEntryGetRemotePathsRequest) (*KalturaRemotePathListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaRemotePathListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryGetRemotePaths")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/getRemotePaths"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBaseEntryIndexRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryIndexRequest
}

func (r ApiBaseEntryIndexRequest) Ks(ks string) ApiBaseEntryIndexRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryIndexRequest) Format(format int32) ApiBaseEntryIndexRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryIndexRequest) ClientTag(clientTag string) ApiBaseEntryIndexRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBaseEntryIndexRequest) PartnerId(partnerId int32) ApiBaseEntryIndexRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBaseEntryIndexRequest) Body(body BaseEntryIndexRequest) ApiBaseEntryIndexRequest {
	r.body = &body
	return r
}

func (r ApiBaseEntryIndexRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.BaseEntryIndexExecute(r)
}

/*
BaseEntryIndex Method for BaseEntryIndex

Index an entry by id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryIndexRequest
*/
func (a *BaseEntryApiService) BaseEntryIndex(ctx context.Context) ApiBaseEntryIndexRequest {
	return ApiBaseEntryIndexRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return int32
func (a *BaseEntryApiService) BaseEntryIndexExecute(r ApiBaseEntryIndexRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/index"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBaseEntryListRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryListRequest
}

func (r ApiBaseEntryListRequest) Ks(ks string) ApiBaseEntryListRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryListRequest) Format(format int32) ApiBaseEntryListRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryListRequest) ClientTag(clientTag string) ApiBaseEntryListRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBaseEntryListRequest) PartnerId(partnerId int32) ApiBaseEntryListRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBaseEntryListRequest) Body(body BaseEntryListRequest) ApiBaseEntryListRequest {
	r.body = &body
	return r
}

func (r ApiBaseEntryListRequest) Execute() (*KalturaBaseEntryListResponse, *http.Response, error) {
	return r.ApiService.BaseEntryListExecute(r)
}

/*
BaseEntryList Method for BaseEntryList

List base entries by filter with paging support.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryListRequest
*/
func (a *BaseEntryApiService) BaseEntryList(ctx context.Context) ApiBaseEntryListRequest {
	return ApiBaseEntryListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBaseEntryListResponse
func (a *BaseEntryApiService) BaseEntryListExecute(r ApiBaseEntryListRequest) (*KalturaBaseEntryListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBaseEntryListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBaseEntryListByReferenceIdRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryListByReferenceIdRequest
}

func (r ApiBaseEntryListByReferenceIdRequest) Ks(ks string) ApiBaseEntryListByReferenceIdRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryListByReferenceIdRequest) Format(format int32) ApiBaseEntryListByReferenceIdRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryListByReferenceIdRequest) ClientTag(clientTag string) ApiBaseEntryListByReferenceIdRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBaseEntryListByReferenceIdRequest) PartnerId(partnerId int32) ApiBaseEntryListByReferenceIdRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBaseEntryListByReferenceIdRequest) Body(body BaseEntryListByReferenceIdRequest) ApiBaseEntryListByReferenceIdRequest {
	r.body = &body
	return r
}

func (r ApiBaseEntryListByReferenceIdRequest) Execute() (*KalturaBaseEntryListResponse, *http.Response, error) {
	return r.ApiService.BaseEntryListByReferenceIdExecute(r)
}

/*
BaseEntryListByReferenceId Method for BaseEntryListByReferenceId

List base entries by filter according to reference id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryListByReferenceIdRequest
*/
func (a *BaseEntryApiService) BaseEntryListByReferenceId(ctx context.Context) ApiBaseEntryListByReferenceIdRequest {
	return ApiBaseEntryListByReferenceIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBaseEntryListResponse
func (a *BaseEntryApiService) BaseEntryListByReferenceIdExecute(r ApiBaseEntryListByReferenceIdRequest) (*KalturaBaseEntryListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBaseEntryListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryListByReferenceId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/listByReferenceId"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBaseEntryListFlagsRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryListFlagsRequest
}

func (r ApiBaseEntryListFlagsRequest) Ks(ks string) ApiBaseEntryListFlagsRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryListFlagsRequest) Format(format int32) ApiBaseEntryListFlagsRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryListFlagsRequest) ClientTag(clientTag string) ApiBaseEntryListFlagsRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBaseEntryListFlagsRequest) PartnerId(partnerId int32) ApiBaseEntryListFlagsRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBaseEntryListFlagsRequest) Body(body BaseEntryListFlagsRequest) ApiBaseEntryListFlagsRequest {
	r.body = &body
	return r
}

func (r ApiBaseEntryListFlagsRequest) Execute() (*KalturaModerationFlagListResponse, *http.Response, error) {
	return r.ApiService.BaseEntryListFlagsExecute(r)
}

/*
BaseEntryListFlags Method for BaseEntryListFlags

List all pending flags for the entry.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryListFlagsRequest
*/
func (a *BaseEntryApiService) BaseEntryListFlags(ctx context.Context) ApiBaseEntryListFlagsRequest {
	return ApiBaseEntryListFlagsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaModerationFlagListResponse
func (a *BaseEntryApiService) BaseEntryListFlagsExecute(r ApiBaseEntryListFlagsRequest) (*KalturaModerationFlagListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaModerationFlagListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryListFlags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/listFlags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBaseEntryRejectRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryApproveRequest
}

func (r ApiBaseEntryRejectRequest) Ks(ks string) ApiBaseEntryRejectRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryRejectRequest) Format(format int32) ApiBaseEntryRejectRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryRejectRequest) ClientTag(clientTag string) ApiBaseEntryRejectRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBaseEntryRejectRequest) PartnerId(partnerId int32) ApiBaseEntryRejectRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBaseEntryRejectRequest) Body(body BaseEntryApproveRequest) ApiBaseEntryRejectRequest {
	r.body = &body
	return r
}

func (r ApiBaseEntryRejectRequest) Execute() (*http.Response, error) {
	return r.ApiService.BaseEntryRejectExecute(r)
}

/*
BaseEntryReject Method for BaseEntryReject

Reject the entry and mark the pending flags (if any) as moderated (this will make the entry non-playable).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryRejectRequest
*/
func (a *BaseEntryApiService) BaseEntryReject(ctx context.Context) ApiBaseEntryRejectRequest {
	return ApiBaseEntryRejectRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *BaseEntryApiService) BaseEntryRejectExecute(r ApiBaseEntryRejectRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryReject")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/reject"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBaseEntryServePlaybackKeyRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryApproveRequest
}

func (r ApiBaseEntryServePlaybackKeyRequest) Ks(ks string) ApiBaseEntryServePlaybackKeyRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryServePlaybackKeyRequest) Format(format int32) ApiBaseEntryServePlaybackKeyRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryServePlaybackKeyRequest) ClientTag(clientTag string) ApiBaseEntryServePlaybackKeyRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBaseEntryServePlaybackKeyRequest) PartnerId(partnerId int32) ApiBaseEntryServePlaybackKeyRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBaseEntryServePlaybackKeyRequest) Body(body BaseEntryApproveRequest) ApiBaseEntryServePlaybackKeyRequest {
	r.body = &body
	return r
}

func (r ApiBaseEntryServePlaybackKeyRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.BaseEntryServePlaybackKeyExecute(r)
}

/*
BaseEntryServePlaybackKey Method for BaseEntryServePlaybackKey

This action serves HLS encrypted key if access control is validated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryServePlaybackKeyRequest
*/
func (a *BaseEntryApiService) BaseEntryServePlaybackKey(ctx context.Context) ApiBaseEntryServePlaybackKeyRequest {
	return ApiBaseEntryServePlaybackKeyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *BaseEntryApiService) BaseEntryServePlaybackKeyExecute(r ApiBaseEntryServePlaybackKeyRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryServePlaybackKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/servePlaybackKey"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBaseEntryUpdateRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryUpdateRequest
}

func (r ApiBaseEntryUpdateRequest) Ks(ks string) ApiBaseEntryUpdateRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryUpdateRequest) Format(format int32) ApiBaseEntryUpdateRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryUpdateRequest) ClientTag(clientTag string) ApiBaseEntryUpdateRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBaseEntryUpdateRequest) PartnerId(partnerId int32) ApiBaseEntryUpdateRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBaseEntryUpdateRequest) Body(body BaseEntryUpdateRequest) ApiBaseEntryUpdateRequest {
	r.body = &body
	return r
}

func (r ApiBaseEntryUpdateRequest) Execute() (*KalturaBaseEntry, *http.Response, error) {
	return r.ApiService.BaseEntryUpdateExecute(r)
}

/*
BaseEntryUpdate Method for BaseEntryUpdate

Update base entry. Only the properties that were set will be updated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryUpdateRequest
*/
func (a *BaseEntryApiService) BaseEntryUpdate(ctx context.Context) ApiBaseEntryUpdateRequest {
	return ApiBaseEntryUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBaseEntry
func (a *BaseEntryApiService) BaseEntryUpdateExecute(r ApiBaseEntryUpdateRequest) (*KalturaBaseEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBaseEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBaseEntryUpdateContentRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryUpdateContentRequest
}

func (r ApiBaseEntryUpdateContentRequest) Ks(ks string) ApiBaseEntryUpdateContentRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryUpdateContentRequest) Format(format int32) ApiBaseEntryUpdateContentRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryUpdateContentRequest) ClientTag(clientTag string) ApiBaseEntryUpdateContentRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBaseEntryUpdateContentRequest) PartnerId(partnerId int32) ApiBaseEntryUpdateContentRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBaseEntryUpdateContentRequest) Body(body BaseEntryUpdateContentRequest) ApiBaseEntryUpdateContentRequest {
	r.body = &body
	return r
}

func (r ApiBaseEntryUpdateContentRequest) Execute() (*KalturaBaseEntry, *http.Response, error) {
	return r.ApiService.BaseEntryUpdateContentExecute(r)
}

/*
BaseEntryUpdateContent Method for BaseEntryUpdateContent

Update the content resource associated with the entry.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryUpdateContentRequest
*/
func (a *BaseEntryApiService) BaseEntryUpdateContent(ctx context.Context) ApiBaseEntryUpdateContentRequest {
	return ApiBaseEntryUpdateContentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBaseEntry
func (a *BaseEntryApiService) BaseEntryUpdateContentExecute(r ApiBaseEntryUpdateContentRequest) (*KalturaBaseEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBaseEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryUpdateContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/updateContent"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBaseEntryUpdateThumbnailFromSourceEntryRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryUpdateThumbnailFromSourceEntryRequest
}

func (r ApiBaseEntryUpdateThumbnailFromSourceEntryRequest) Ks(ks string) ApiBaseEntryUpdateThumbnailFromSourceEntryRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryUpdateThumbnailFromSourceEntryRequest) Format(format int32) ApiBaseEntryUpdateThumbnailFromSourceEntryRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryUpdateThumbnailFromSourceEntryRequest) ClientTag(clientTag string) ApiBaseEntryUpdateThumbnailFromSourceEntryRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBaseEntryUpdateThumbnailFromSourceEntryRequest) PartnerId(partnerId int32) ApiBaseEntryUpdateThumbnailFromSourceEntryRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBaseEntryUpdateThumbnailFromSourceEntryRequest) Body(body BaseEntryUpdateThumbnailFromSourceEntryRequest) ApiBaseEntryUpdateThumbnailFromSourceEntryRequest {
	r.body = &body
	return r
}

func (r ApiBaseEntryUpdateThumbnailFromSourceEntryRequest) Execute() (*KalturaBaseEntry, *http.Response, error) {
	return r.ApiService.BaseEntryUpdateThumbnailFromSourceEntryExecute(r)
}

/*
BaseEntryUpdateThumbnailFromSourceEntry Method for BaseEntryUpdateThumbnailFromSourceEntry

Update entry thumbnail from a different entry by a specified time offset (in seconds).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryUpdateThumbnailFromSourceEntryRequest
*/
func (a *BaseEntryApiService) BaseEntryUpdateThumbnailFromSourceEntry(ctx context.Context) ApiBaseEntryUpdateThumbnailFromSourceEntryRequest {
	return ApiBaseEntryUpdateThumbnailFromSourceEntryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBaseEntry
func (a *BaseEntryApiService) BaseEntryUpdateThumbnailFromSourceEntryExecute(r ApiBaseEntryUpdateThumbnailFromSourceEntryRequest) (*KalturaBaseEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBaseEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryUpdateThumbnailFromSourceEntry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/updateThumbnailFromSourceEntry"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBaseEntryUpdateThumbnailFromUrlRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryUpdateThumbnailFromUrlRequest
}

func (r ApiBaseEntryUpdateThumbnailFromUrlRequest) Ks(ks string) ApiBaseEntryUpdateThumbnailFromUrlRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryUpdateThumbnailFromUrlRequest) Format(format int32) ApiBaseEntryUpdateThumbnailFromUrlRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryUpdateThumbnailFromUrlRequest) ClientTag(clientTag string) ApiBaseEntryUpdateThumbnailFromUrlRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBaseEntryUpdateThumbnailFromUrlRequest) PartnerId(partnerId int32) ApiBaseEntryUpdateThumbnailFromUrlRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBaseEntryUpdateThumbnailFromUrlRequest) Body(body BaseEntryUpdateThumbnailFromUrlRequest) ApiBaseEntryUpdateThumbnailFromUrlRequest {
	r.body = &body
	return r
}

func (r ApiBaseEntryUpdateThumbnailFromUrlRequest) Execute() (*KalturaBaseEntry, *http.Response, error) {
	return r.ApiService.BaseEntryUpdateThumbnailFromUrlExecute(r)
}

/*
BaseEntryUpdateThumbnailFromUrl Method for BaseEntryUpdateThumbnailFromUrl

Update entry thumbnail using URL.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryUpdateThumbnailFromUrlRequest
*/
func (a *BaseEntryApiService) BaseEntryUpdateThumbnailFromUrl(ctx context.Context) ApiBaseEntryUpdateThumbnailFromUrlRequest {
	return ApiBaseEntryUpdateThumbnailFromUrlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBaseEntry
func (a *BaseEntryApiService) BaseEntryUpdateThumbnailFromUrlExecute(r ApiBaseEntryUpdateThumbnailFromUrlRequest) (*KalturaBaseEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBaseEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryUpdateThumbnailFromUrl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/updateThumbnailFromUrl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBaseEntryUpdateThumbnailJpegRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	entryId *string
	fileData **os.File
	ks *string
	format *int32
}

// Media entry id
func (r ApiBaseEntryUpdateThumbnailJpegRequest) EntryId(entryId string) ApiBaseEntryUpdateThumbnailJpegRequest {
	r.entryId = &entryId
	return r
}

// Jpeg file data
func (r ApiBaseEntryUpdateThumbnailJpegRequest) FileData(fileData *os.File) ApiBaseEntryUpdateThumbnailJpegRequest {
	r.fileData = &fileData
	return r
}

func (r ApiBaseEntryUpdateThumbnailJpegRequest) Ks(ks string) ApiBaseEntryUpdateThumbnailJpegRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryUpdateThumbnailJpegRequest) Format(format int32) ApiBaseEntryUpdateThumbnailJpegRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryUpdateThumbnailJpegRequest) Execute() (*KalturaBaseEntry, *http.Response, error) {
	return r.ApiService.BaseEntryUpdateThumbnailJpegExecute(r)
}

/*
BaseEntryUpdateThumbnailJpeg Method for BaseEntryUpdateThumbnailJpeg

Update entry thumbnail using a raw jpeg file.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryUpdateThumbnailJpegRequest
*/
func (a *BaseEntryApiService) BaseEntryUpdateThumbnailJpeg(ctx context.Context) ApiBaseEntryUpdateThumbnailJpegRequest {
	return ApiBaseEntryUpdateThumbnailJpegRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBaseEntry
func (a *BaseEntryApiService) BaseEntryUpdateThumbnailJpegExecute(r ApiBaseEntryUpdateThumbnailJpegRequest) (*KalturaBaseEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBaseEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryUpdateThumbnailJpeg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/updateThumbnailJpeg"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.entryId == nil {
		return localVarReturnValue, nil, reportError("entryId is required and must be specified")
	}
	if r.fileData == nil {
		return localVarReturnValue, nil, reportError("fileData is required and must be specified")
	}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	localVarQueryParams.Add("entryId", parameterToString(*r.entryId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileDataLocalVarFormFileName string
	var fileDataLocalVarFileName     string
	var fileDataLocalVarFileBytes    []byte

	fileDataLocalVarFormFileName = "fileData"

	fileDataLocalVarFile := *r.fileData
	if fileDataLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(fileDataLocalVarFile)
		fileDataLocalVarFileBytes = fbs
		fileDataLocalVarFileName = fileDataLocalVarFile.Name()
		fileDataLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: fileDataLocalVarFileBytes, fileName: fileDataLocalVarFileName, formFileName: fileDataLocalVarFormFileName})
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBaseEntryUploadRequest struct {
	ctx context.Context
	ApiService *BaseEntryApiService
	fileData **os.File
	ks *string
	format *int32
}

// The file data
func (r ApiBaseEntryUploadRequest) FileData(fileData *os.File) ApiBaseEntryUploadRequest {
	r.fileData = &fileData
	return r
}

func (r ApiBaseEntryUploadRequest) Ks(ks string) ApiBaseEntryUploadRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBaseEntryUploadRequest) Format(format int32) ApiBaseEntryUploadRequest {
	r.format = &format
	return r
}

func (r ApiBaseEntryUploadRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.BaseEntryUploadExecute(r)
}

/*
BaseEntryUpload Method for BaseEntryUpload

Upload a file to Kaltura, that can be used to create an entry.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBaseEntryUploadRequest

Deprecated
*/
func (a *BaseEntryApiService) BaseEntryUpload(ctx context.Context) ApiBaseEntryUploadRequest {
	return ApiBaseEntryUploadRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
// Deprecated
func (a *BaseEntryApiService) BaseEntryUploadExecute(r ApiBaseEntryUploadRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BaseEntryApiService.BaseEntryUpload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/baseentry/action/upload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileData == nil {
		return localVarReturnValue, nil, reportError("fileData is required and must be specified")
	}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileDataLocalVarFormFileName string
	var fileDataLocalVarFileName     string
	var fileDataLocalVarFileBytes    []byte

	fileDataLocalVarFormFileName = "fileData"

	fileDataLocalVarFile := *r.fileData
	if fileDataLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(fileDataLocalVarFile)
		fileDataLocalVarFileBytes = fbs
		fileDataLocalVarFileName = fileDataLocalVarFile.Name()
		fileDataLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: fileDataLocalVarFileBytes, fileName: fileDataLocalVarFileName, formFileName: fileDataLocalVarFormFileName})
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
