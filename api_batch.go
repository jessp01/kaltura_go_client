/*
Kaltura VPaaS

The Kaltura VPaaS API

API version: 18.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
)


// BatchApiService BatchApi service
type BatchApiService service

type ApiBatchAddBulkUploadResultRequest struct {
	ctx context.Context
	ApiService *BatchApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BatchAddBulkUploadResultRequest
}

func (r ApiBatchAddBulkUploadResultRequest) Ks(ks string) ApiBatchAddBulkUploadResultRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBatchAddBulkUploadResultRequest) Format(format int32) ApiBatchAddBulkUploadResultRequest {
	r.format = &format
	return r
}

func (r ApiBatchAddBulkUploadResultRequest) ClientTag(clientTag string) ApiBatchAddBulkUploadResultRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBatchAddBulkUploadResultRequest) PartnerId(partnerId int32) ApiBatchAddBulkUploadResultRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBatchAddBulkUploadResultRequest) Body(body BatchAddBulkUploadResultRequest) ApiBatchAddBulkUploadResultRequest {
	r.body = &body
	return r
}

func (r ApiBatchAddBulkUploadResultRequest) Execute() (*KalturaBulkUploadResult, *http.Response, error) {
	return r.ApiService.BatchAddBulkUploadResultExecute(r)
}

/*
BatchAddBulkUploadResult Method for BatchAddBulkUploadResult

batch addBulkUploadResultAction action adds KalturaBulkUploadResult to the DB

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchAddBulkUploadResultRequest
*/
func (a *BatchApiService) BatchAddBulkUploadResult(ctx context.Context) ApiBatchAddBulkUploadResultRequest {
	return ApiBatchAddBulkUploadResultRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBulkUploadResult
func (a *BatchApiService) BatchAddBulkUploadResultExecute(r ApiBatchAddBulkUploadResultRequest) (*KalturaBulkUploadResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBulkUploadResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchApiService.BatchAddBulkUploadResult")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/batch/action/addBulkUploadResult"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchAddMediaInfoRequest struct {
	ctx context.Context
	ApiService *BatchApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BatchAddMediaInfoRequest
}

func (r ApiBatchAddMediaInfoRequest) Ks(ks string) ApiBatchAddMediaInfoRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBatchAddMediaInfoRequest) Format(format int32) ApiBatchAddMediaInfoRequest {
	r.format = &format
	return r
}

func (r ApiBatchAddMediaInfoRequest) ClientTag(clientTag string) ApiBatchAddMediaInfoRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBatchAddMediaInfoRequest) PartnerId(partnerId int32) ApiBatchAddMediaInfoRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBatchAddMediaInfoRequest) Body(body BatchAddMediaInfoRequest) ApiBatchAddMediaInfoRequest {
	r.body = &body
	return r
}

func (r ApiBatchAddMediaInfoRequest) Execute() (*KalturaMediaInfo, *http.Response, error) {
	return r.ApiService.BatchAddMediaInfoExecute(r)
}

/*
BatchAddMediaInfo Method for BatchAddMediaInfo

batch addMediaInfoAction action saves a media info object

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchAddMediaInfoRequest
*/
func (a *BatchApiService) BatchAddMediaInfo(ctx context.Context) ApiBatchAddMediaInfoRequest {
	return ApiBatchAddMediaInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMediaInfo
func (a *BatchApiService) BatchAddMediaInfoExecute(r ApiBatchAddMediaInfoRequest) (*KalturaMediaInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMediaInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchApiService.BatchAddMediaInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/batch/action/addMediaInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchCheckEntryIsDoneRequest struct {
	ctx context.Context
	ApiService *BatchApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BatchCheckEntryIsDoneRequest
}

func (r ApiBatchCheckEntryIsDoneRequest) Ks(ks string) ApiBatchCheckEntryIsDoneRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBatchCheckEntryIsDoneRequest) Format(format int32) ApiBatchCheckEntryIsDoneRequest {
	r.format = &format
	return r
}

func (r ApiBatchCheckEntryIsDoneRequest) ClientTag(clientTag string) ApiBatchCheckEntryIsDoneRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBatchCheckEntryIsDoneRequest) PartnerId(partnerId int32) ApiBatchCheckEntryIsDoneRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBatchCheckEntryIsDoneRequest) Body(body BatchCheckEntryIsDoneRequest) ApiBatchCheckEntryIsDoneRequest {
	r.body = &body
	return r
}

func (r ApiBatchCheckEntryIsDoneRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.BatchCheckEntryIsDoneExecute(r)
}

/*
BatchCheckEntryIsDone Method for BatchCheckEntryIsDone

batch checkEntryIsDone Check weather a specified entry is done converting and changes it to ready.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchCheckEntryIsDoneRequest
*/
func (a *BatchApiService) BatchCheckEntryIsDone(ctx context.Context) ApiBatchCheckEntryIsDoneRequest {
	return ApiBatchCheckEntryIsDoneRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return bool
func (a *BatchApiService) BatchCheckEntryIsDoneExecute(r ApiBatchCheckEntryIsDoneRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchApiService.BatchCheckEntryIsDone")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/batch/action/checkEntryIsDone"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchCheckFileExistsRequest struct {
	ctx context.Context
	ApiService *BatchApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BatchCheckFileExistsRequest
}

func (r ApiBatchCheckFileExistsRequest) Ks(ks string) ApiBatchCheckFileExistsRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBatchCheckFileExistsRequest) Format(format int32) ApiBatchCheckFileExistsRequest {
	r.format = &format
	return r
}

func (r ApiBatchCheckFileExistsRequest) ClientTag(clientTag string) ApiBatchCheckFileExistsRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBatchCheckFileExistsRequest) PartnerId(partnerId int32) ApiBatchCheckFileExistsRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBatchCheckFileExistsRequest) Body(body BatchCheckFileExistsRequest) ApiBatchCheckFileExistsRequest {
	r.body = &body
	return r
}

func (r ApiBatchCheckFileExistsRequest) Execute() (*KalturaFileExistsResponse, *http.Response, error) {
	return r.ApiService.BatchCheckFileExistsExecute(r)
}

/*
BatchCheckFileExists Method for BatchCheckFileExists

batch checkFileExists action check if the file exists

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchCheckFileExistsRequest
*/
func (a *BatchApiService) BatchCheckFileExists(ctx context.Context) ApiBatchCheckFileExistsRequest {
	return ApiBatchCheckFileExistsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaFileExistsResponse
func (a *BatchApiService) BatchCheckFileExistsExecute(r ApiBatchCheckFileExistsRequest) (*KalturaFileExistsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaFileExistsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchApiService.BatchCheckFileExists")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/batch/action/checkFileExists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchCleanExclusiveJobsRequest struct {
	ctx context.Context
	ApiService *BatchApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	batchCleanExclusiveJobsRequest *BatchCleanExclusiveJobsRequest
}

func (r ApiBatchCleanExclusiveJobsRequest) Ks(ks string) ApiBatchCleanExclusiveJobsRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBatchCleanExclusiveJobsRequest) Format(format int32) ApiBatchCleanExclusiveJobsRequest {
	r.format = &format
	return r
}

func (r ApiBatchCleanExclusiveJobsRequest) ClientTag(clientTag string) ApiBatchCleanExclusiveJobsRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBatchCleanExclusiveJobsRequest) PartnerId(partnerId int32) ApiBatchCleanExclusiveJobsRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBatchCleanExclusiveJobsRequest) BatchCleanExclusiveJobsRequest(batchCleanExclusiveJobsRequest BatchCleanExclusiveJobsRequest) ApiBatchCleanExclusiveJobsRequest {
	r.batchCleanExclusiveJobsRequest = &batchCleanExclusiveJobsRequest
	return r
}

func (r ApiBatchCleanExclusiveJobsRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.BatchCleanExclusiveJobsExecute(r)
}

/*
BatchCleanExclusiveJobs Method for BatchCleanExclusiveJobs

batch cleanExclusiveJobs action mark as fatal error all expired jobs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchCleanExclusiveJobsRequest
*/
func (a *BatchApiService) BatchCleanExclusiveJobs(ctx context.Context) ApiBatchCleanExclusiveJobsRequest {
	return ApiBatchCleanExclusiveJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return int32
func (a *BatchApiService) BatchCleanExclusiveJobsExecute(r ApiBatchCleanExclusiveJobsRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchApiService.BatchCleanExclusiveJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/batch/action/cleanExclusiveJobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchCleanExclusiveJobsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchCountBulkUploadEntriesRequest struct {
	ctx context.Context
	ApiService *BatchApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BatchCountBulkUploadEntriesRequest
}

func (r ApiBatchCountBulkUploadEntriesRequest) Ks(ks string) ApiBatchCountBulkUploadEntriesRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBatchCountBulkUploadEntriesRequest) Format(format int32) ApiBatchCountBulkUploadEntriesRequest {
	r.format = &format
	return r
}

func (r ApiBatchCountBulkUploadEntriesRequest) ClientTag(clientTag string) ApiBatchCountBulkUploadEntriesRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBatchCountBulkUploadEntriesRequest) PartnerId(partnerId int32) ApiBatchCountBulkUploadEntriesRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBatchCountBulkUploadEntriesRequest) Body(body BatchCountBulkUploadEntriesRequest) ApiBatchCountBulkUploadEntriesRequest {
	r.body = &body
	return r
}

func (r ApiBatchCountBulkUploadEntriesRequest) Execute() ([]KalturaKeyValue, *http.Response, error) {
	return r.ApiService.BatchCountBulkUploadEntriesExecute(r)
}

/*
BatchCountBulkUploadEntries Method for BatchCountBulkUploadEntries

Returns total created entries count and total error entries count

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchCountBulkUploadEntriesRequest
*/
func (a *BatchApiService) BatchCountBulkUploadEntries(ctx context.Context) ApiBatchCountBulkUploadEntriesRequest {
	return ApiBatchCountBulkUploadEntriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []KalturaKeyValue
func (a *BatchApiService) BatchCountBulkUploadEntriesExecute(r ApiBatchCountBulkUploadEntriesRequest) ([]KalturaKeyValue, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KalturaKeyValue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchApiService.BatchCountBulkUploadEntries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/batch/action/countBulkUploadEntries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchExtendLockExpirationRequest struct {
	ctx context.Context
	ApiService *BatchApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BatchExtendLockExpirationRequest
}

func (r ApiBatchExtendLockExpirationRequest) Ks(ks string) ApiBatchExtendLockExpirationRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBatchExtendLockExpirationRequest) Format(format int32) ApiBatchExtendLockExpirationRequest {
	r.format = &format
	return r
}

func (r ApiBatchExtendLockExpirationRequest) ClientTag(clientTag string) ApiBatchExtendLockExpirationRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBatchExtendLockExpirationRequest) PartnerId(partnerId int32) ApiBatchExtendLockExpirationRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBatchExtendLockExpirationRequest) Body(body BatchExtendLockExpirationRequest) ApiBatchExtendLockExpirationRequest {
	r.body = &body
	return r
}

func (r ApiBatchExtendLockExpirationRequest) Execute() (*http.Response, error) {
	return r.ApiService.BatchExtendLockExpirationExecute(r)
}

/*
BatchExtendLockExpiration Method for BatchExtendLockExpiration

batch extendLockExpiration action allows to extend the expiration of a BatchJobLock by job id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchExtendLockExpirationRequest
*/
func (a *BatchApiService) BatchExtendLockExpiration(ctx context.Context) ApiBatchExtendLockExpirationRequest {
	return ApiBatchExtendLockExpirationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *BatchApiService) BatchExtendLockExpirationExecute(r ApiBatchExtendLockExpirationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchApiService.BatchExtendLockExpiration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/batch/action/extendLockExpiration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBatchFreeExclusiveJobRequest struct {
	ctx context.Context
	ApiService *BatchApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BatchFreeExclusiveJobRequest
}

func (r ApiBatchFreeExclusiveJobRequest) Ks(ks string) ApiBatchFreeExclusiveJobRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBatchFreeExclusiveJobRequest) Format(format int32) ApiBatchFreeExclusiveJobRequest {
	r.format = &format
	return r
}

func (r ApiBatchFreeExclusiveJobRequest) ClientTag(clientTag string) ApiBatchFreeExclusiveJobRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBatchFreeExclusiveJobRequest) PartnerId(partnerId int32) ApiBatchFreeExclusiveJobRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBatchFreeExclusiveJobRequest) Body(body BatchFreeExclusiveJobRequest) ApiBatchFreeExclusiveJobRequest {
	r.body = &body
	return r
}

func (r ApiBatchFreeExclusiveJobRequest) Execute() (*KalturaFreeJobResponse, *http.Response, error) {
	return r.ApiService.BatchFreeExclusiveJobExecute(r)
}

/*
BatchFreeExclusiveJob Method for BatchFreeExclusiveJob

batch freeExclusiveJobAction action allows to get a generic BatchJob

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchFreeExclusiveJobRequest
*/
func (a *BatchApiService) BatchFreeExclusiveJob(ctx context.Context) ApiBatchFreeExclusiveJobRequest {
	return ApiBatchFreeExclusiveJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaFreeJobResponse
func (a *BatchApiService) BatchFreeExclusiveJobExecute(r ApiBatchFreeExclusiveJobRequest) (*KalturaFreeJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaFreeJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchApiService.BatchFreeExclusiveJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/batch/action/freeExclusiveJob"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchGetBulkUploadLastResultRequest struct {
	ctx context.Context
	ApiService *BatchApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BatchGetBulkUploadLastResultRequest
}

func (r ApiBatchGetBulkUploadLastResultRequest) Ks(ks string) ApiBatchGetBulkUploadLastResultRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBatchGetBulkUploadLastResultRequest) Format(format int32) ApiBatchGetBulkUploadLastResultRequest {
	r.format = &format
	return r
}

func (r ApiBatchGetBulkUploadLastResultRequest) ClientTag(clientTag string) ApiBatchGetBulkUploadLastResultRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBatchGetBulkUploadLastResultRequest) PartnerId(partnerId int32) ApiBatchGetBulkUploadLastResultRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBatchGetBulkUploadLastResultRequest) Body(body BatchGetBulkUploadLastResultRequest) ApiBatchGetBulkUploadLastResultRequest {
	r.body = &body
	return r
}

func (r ApiBatchGetBulkUploadLastResultRequest) Execute() (*KalturaBulkUploadResult, *http.Response, error) {
	return r.ApiService.BatchGetBulkUploadLastResultExecute(r)
}

/*
BatchGetBulkUploadLastResult Method for BatchGetBulkUploadLastResult

batch getBulkUploadLastResultAction action returns the last result of the bulk upload

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchGetBulkUploadLastResultRequest
*/
func (a *BatchApiService) BatchGetBulkUploadLastResult(ctx context.Context) ApiBatchGetBulkUploadLastResultRequest {
	return ApiBatchGetBulkUploadLastResultRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBulkUploadResult
func (a *BatchApiService) BatchGetBulkUploadLastResultExecute(r ApiBatchGetBulkUploadLastResultRequest) (*KalturaBulkUploadResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBulkUploadResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchApiService.BatchGetBulkUploadLastResult")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/batch/action/getBulkUploadLastResult"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchGetExclusiveAlmostDoneRequest struct {
	ctx context.Context
	ApiService *BatchApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BatchGetExclusiveAlmostDoneRequest
}

func (r ApiBatchGetExclusiveAlmostDoneRequest) Ks(ks string) ApiBatchGetExclusiveAlmostDoneRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBatchGetExclusiveAlmostDoneRequest) Format(format int32) ApiBatchGetExclusiveAlmostDoneRequest {
	r.format = &format
	return r
}

func (r ApiBatchGetExclusiveAlmostDoneRequest) ClientTag(clientTag string) ApiBatchGetExclusiveAlmostDoneRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBatchGetExclusiveAlmostDoneRequest) PartnerId(partnerId int32) ApiBatchGetExclusiveAlmostDoneRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBatchGetExclusiveAlmostDoneRequest) Body(body BatchGetExclusiveAlmostDoneRequest) ApiBatchGetExclusiveAlmostDoneRequest {
	r.body = &body
	return r
}

func (r ApiBatchGetExclusiveAlmostDoneRequest) Execute() ([]KalturaBatchJob, *http.Response, error) {
	return r.ApiService.BatchGetExclusiveAlmostDoneExecute(r)
}

/*
BatchGetExclusiveAlmostDone Method for BatchGetExclusiveAlmostDone

batch getExclusiveAlmostDone action allows to get a BatchJob that wait for remote closure

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchGetExclusiveAlmostDoneRequest
*/
func (a *BatchApiService) BatchGetExclusiveAlmostDone(ctx context.Context) ApiBatchGetExclusiveAlmostDoneRequest {
	return ApiBatchGetExclusiveAlmostDoneRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []KalturaBatchJob
func (a *BatchApiService) BatchGetExclusiveAlmostDoneExecute(r ApiBatchGetExclusiveAlmostDoneRequest) ([]KalturaBatchJob, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KalturaBatchJob
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchApiService.BatchGetExclusiveAlmostDone")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/batch/action/getExclusiveAlmostDone"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchGetExclusiveJobsRequest struct {
	ctx context.Context
	ApiService *BatchApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BatchGetExclusiveJobsRequest
}

func (r ApiBatchGetExclusiveJobsRequest) Ks(ks string) ApiBatchGetExclusiveJobsRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBatchGetExclusiveJobsRequest) Format(format int32) ApiBatchGetExclusiveJobsRequest {
	r.format = &format
	return r
}

func (r ApiBatchGetExclusiveJobsRequest) ClientTag(clientTag string) ApiBatchGetExclusiveJobsRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBatchGetExclusiveJobsRequest) PartnerId(partnerId int32) ApiBatchGetExclusiveJobsRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBatchGetExclusiveJobsRequest) Body(body BatchGetExclusiveJobsRequest) ApiBatchGetExclusiveJobsRequest {
	r.body = &body
	return r
}

func (r ApiBatchGetExclusiveJobsRequest) Execute() ([]KalturaBatchJob, *http.Response, error) {
	return r.ApiService.BatchGetExclusiveJobsExecute(r)
}

/*
BatchGetExclusiveJobs Method for BatchGetExclusiveJobs

batch getExclusiveJobsAction action allows to get a BatchJob

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchGetExclusiveJobsRequest
*/
func (a *BatchApiService) BatchGetExclusiveJobs(ctx context.Context) ApiBatchGetExclusiveJobsRequest {
	return ApiBatchGetExclusiveJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []KalturaBatchJob
func (a *BatchApiService) BatchGetExclusiveJobsExecute(r ApiBatchGetExclusiveJobsRequest) ([]KalturaBatchJob, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KalturaBatchJob
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchApiService.BatchGetExclusiveJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/batch/action/getExclusiveJobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchGetExclusiveNotificationJobsRequest struct {
	ctx context.Context
	ApiService *BatchApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BatchGetExclusiveNotificationJobsRequest
}

func (r ApiBatchGetExclusiveNotificationJobsRequest) Ks(ks string) ApiBatchGetExclusiveNotificationJobsRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBatchGetExclusiveNotificationJobsRequest) Format(format int32) ApiBatchGetExclusiveNotificationJobsRequest {
	r.format = &format
	return r
}

func (r ApiBatchGetExclusiveNotificationJobsRequest) ClientTag(clientTag string) ApiBatchGetExclusiveNotificationJobsRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBatchGetExclusiveNotificationJobsRequest) PartnerId(partnerId int32) ApiBatchGetExclusiveNotificationJobsRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBatchGetExclusiveNotificationJobsRequest) Body(body BatchGetExclusiveNotificationJobsRequest) ApiBatchGetExclusiveNotificationJobsRequest {
	r.body = &body
	return r
}

func (r ApiBatchGetExclusiveNotificationJobsRequest) Execute() (*KalturaBatchGetExclusiveNotificationJobsResponse, *http.Response, error) {
	return r.ApiService.BatchGetExclusiveNotificationJobsExecute(r)
}

/*
BatchGetExclusiveNotificationJobs Method for BatchGetExclusiveNotificationJobs

batch getExclusiveNotificationJob action allows to get a BatchJob of type NOTIFICATION

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchGetExclusiveNotificationJobsRequest
*/
func (a *BatchApiService) BatchGetExclusiveNotificationJobs(ctx context.Context) ApiBatchGetExclusiveNotificationJobsRequest {
	return ApiBatchGetExclusiveNotificationJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchGetExclusiveNotificationJobsResponse
func (a *BatchApiService) BatchGetExclusiveNotificationJobsExecute(r ApiBatchGetExclusiveNotificationJobsRequest) (*KalturaBatchGetExclusiveNotificationJobsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchGetExclusiveNotificationJobsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchApiService.BatchGetExclusiveNotificationJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/batch/action/getExclusiveNotificationJobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchGetQueueSizeRequest struct {
	ctx context.Context
	ApiService *BatchApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BatchGetQueueSizeRequest
}

func (r ApiBatchGetQueueSizeRequest) Ks(ks string) ApiBatchGetQueueSizeRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBatchGetQueueSizeRequest) Format(format int32) ApiBatchGetQueueSizeRequest {
	r.format = &format
	return r
}

func (r ApiBatchGetQueueSizeRequest) ClientTag(clientTag string) ApiBatchGetQueueSizeRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBatchGetQueueSizeRequest) PartnerId(partnerId int32) ApiBatchGetQueueSizeRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBatchGetQueueSizeRequest) Body(body BatchGetQueueSizeRequest) ApiBatchGetQueueSizeRequest {
	r.body = &body
	return r
}

func (r ApiBatchGetQueueSizeRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.BatchGetQueueSizeExecute(r)
}

/*
BatchGetQueueSize Method for BatchGetQueueSize

batch getQueueSize action get the queue size for job type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchGetQueueSizeRequest
*/
func (a *BatchApiService) BatchGetQueueSize(ctx context.Context) ApiBatchGetQueueSizeRequest {
	return ApiBatchGetQueueSizeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return int32
func (a *BatchApiService) BatchGetQueueSizeExecute(r ApiBatchGetQueueSizeRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchApiService.BatchGetQueueSize")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/batch/action/getQueueSize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchLogConversionRequest struct {
	ctx context.Context
	ApiService *BatchApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BatchLogConversionRequest
}

func (r ApiBatchLogConversionRequest) Ks(ks string) ApiBatchLogConversionRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBatchLogConversionRequest) Format(format int32) ApiBatchLogConversionRequest {
	r.format = &format
	return r
}

func (r ApiBatchLogConversionRequest) ClientTag(clientTag string) ApiBatchLogConversionRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBatchLogConversionRequest) PartnerId(partnerId int32) ApiBatchLogConversionRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBatchLogConversionRequest) Body(body BatchLogConversionRequest) ApiBatchLogConversionRequest {
	r.body = &body
	return r
}

func (r ApiBatchLogConversionRequest) Execute() (*http.Response, error) {
	return r.ApiService.BatchLogConversionExecute(r)
}

/*
BatchLogConversion Method for BatchLogConversion

Add the data to the flavor asset conversion log, creates it if doesn't exists

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchLogConversionRequest
*/
func (a *BatchApiService) BatchLogConversion(ctx context.Context) ApiBatchLogConversionRequest {
	return ApiBatchLogConversionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *BatchApiService) BatchLogConversionExecute(r ApiBatchLogConversionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchApiService.BatchLogConversion")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/batch/action/logConversion"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBatchPutFileRequest struct {
	ctx context.Context
	ApiService *BatchApiService
	destPath *string
	data **os.File
	ks *string
	format *int32
}

func (r ApiBatchPutFileRequest) DestPath(destPath string) ApiBatchPutFileRequest {
	r.destPath = &destPath
	return r
}

func (r ApiBatchPutFileRequest) Data(data *os.File) ApiBatchPutFileRequest {
	r.data = &data
	return r
}

func (r ApiBatchPutFileRequest) Ks(ks string) ApiBatchPutFileRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBatchPutFileRequest) Format(format int32) ApiBatchPutFileRequest {
	r.format = &format
	return r
}

func (r ApiBatchPutFileRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.BatchPutFileExecute(r)
}

/*
BatchPutFile Method for BatchPutFile

batch putFileAction action allows put file on server via http

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchPutFileRequest
*/
func (a *BatchApiService) BatchPutFile(ctx context.Context) ApiBatchPutFileRequest {
	return ApiBatchPutFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return int32
func (a *BatchApiService) BatchPutFileExecute(r ApiBatchPutFileRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchApiService.BatchPutFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/batch/action/putFile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.destPath == nil {
		return localVarReturnValue, nil, reportError("destPath is required and must be specified")
	}
	if r.data == nil {
		return localVarReturnValue, nil, reportError("data is required and must be specified")
	}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	localVarQueryParams.Add("destPath", parameterToString(*r.destPath, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var dataLocalVarFormFileName string
	var dataLocalVarFileName     string
	var dataLocalVarFileBytes    []byte

	dataLocalVarFormFileName = "data"

	dataLocalVarFile := *r.data
	if dataLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(dataLocalVarFile)
		dataLocalVarFileBytes = fbs
		dataLocalVarFileName = dataLocalVarFile.Name()
		dataLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: dataLocalVarFileBytes, fileName: dataLocalVarFileName, formFileName: dataLocalVarFormFileName})
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchResetJobExecutionAttemptsRequest struct {
	ctx context.Context
	ApiService *BatchApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BatchResetJobExecutionAttemptsRequest
}

func (r ApiBatchResetJobExecutionAttemptsRequest) Ks(ks string) ApiBatchResetJobExecutionAttemptsRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBatchResetJobExecutionAttemptsRequest) Format(format int32) ApiBatchResetJobExecutionAttemptsRequest {
	r.format = &format
	return r
}

func (r ApiBatchResetJobExecutionAttemptsRequest) ClientTag(clientTag string) ApiBatchResetJobExecutionAttemptsRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBatchResetJobExecutionAttemptsRequest) PartnerId(partnerId int32) ApiBatchResetJobExecutionAttemptsRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBatchResetJobExecutionAttemptsRequest) Body(body BatchResetJobExecutionAttemptsRequest) ApiBatchResetJobExecutionAttemptsRequest {
	r.body = &body
	return r
}

func (r ApiBatchResetJobExecutionAttemptsRequest) Execute() (*http.Response, error) {
	return r.ApiService.BatchResetJobExecutionAttemptsExecute(r)
}

/*
BatchResetJobExecutionAttempts Method for BatchResetJobExecutionAttempts

batch resetJobExecutionAttempts action resets the execution attempts of the job

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchResetJobExecutionAttemptsRequest
*/
func (a *BatchApiService) BatchResetJobExecutionAttempts(ctx context.Context) ApiBatchResetJobExecutionAttemptsRequest {
	return ApiBatchResetJobExecutionAttemptsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *BatchApiService) BatchResetJobExecutionAttemptsExecute(r ApiBatchResetJobExecutionAttemptsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchApiService.BatchResetJobExecutionAttempts")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/batch/action/resetJobExecutionAttempts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBatchSuspendJobsRequest struct {
	ctx context.Context
	ApiService *BatchApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	batchCleanExclusiveJobsRequest *BatchCleanExclusiveJobsRequest
}

func (r ApiBatchSuspendJobsRequest) Ks(ks string) ApiBatchSuspendJobsRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBatchSuspendJobsRequest) Format(format int32) ApiBatchSuspendJobsRequest {
	r.format = &format
	return r
}

func (r ApiBatchSuspendJobsRequest) ClientTag(clientTag string) ApiBatchSuspendJobsRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBatchSuspendJobsRequest) PartnerId(partnerId int32) ApiBatchSuspendJobsRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBatchSuspendJobsRequest) BatchCleanExclusiveJobsRequest(batchCleanExclusiveJobsRequest BatchCleanExclusiveJobsRequest) ApiBatchSuspendJobsRequest {
	r.batchCleanExclusiveJobsRequest = &batchCleanExclusiveJobsRequest
	return r
}

func (r ApiBatchSuspendJobsRequest) Execute() (*http.Response, error) {
	return r.ApiService.BatchSuspendJobsExecute(r)
}

/*
BatchSuspendJobs Method for BatchSuspendJobs

batch suspendJobs action suspends jobs from running.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchSuspendJobsRequest
*/
func (a *BatchApiService) BatchSuspendJobs(ctx context.Context) ApiBatchSuspendJobsRequest {
	return ApiBatchSuspendJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *BatchApiService) BatchSuspendJobsExecute(r ApiBatchSuspendJobsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchApiService.BatchSuspendJobs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/batch/action/suspendJobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchCleanExclusiveJobsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBatchUpdateBulkUploadResultsRequest struct {
	ctx context.Context
	ApiService *BatchApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BatchGetBulkUploadLastResultRequest
}

func (r ApiBatchUpdateBulkUploadResultsRequest) Ks(ks string) ApiBatchUpdateBulkUploadResultsRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBatchUpdateBulkUploadResultsRequest) Format(format int32) ApiBatchUpdateBulkUploadResultsRequest {
	r.format = &format
	return r
}

func (r ApiBatchUpdateBulkUploadResultsRequest) ClientTag(clientTag string) ApiBatchUpdateBulkUploadResultsRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBatchUpdateBulkUploadResultsRequest) PartnerId(partnerId int32) ApiBatchUpdateBulkUploadResultsRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBatchUpdateBulkUploadResultsRequest) Body(body BatchGetBulkUploadLastResultRequest) ApiBatchUpdateBulkUploadResultsRequest {
	r.body = &body
	return r
}

func (r ApiBatchUpdateBulkUploadResultsRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.BatchUpdateBulkUploadResultsExecute(r)
}

/*
BatchUpdateBulkUploadResults Method for BatchUpdateBulkUploadResults

batch updateBulkUploadResults action adds KalturaBulkUploadResult to the DB

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchUpdateBulkUploadResultsRequest
*/
func (a *BatchApiService) BatchUpdateBulkUploadResults(ctx context.Context) ApiBatchUpdateBulkUploadResultsRequest {
	return ApiBatchUpdateBulkUploadResultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return int32
func (a *BatchApiService) BatchUpdateBulkUploadResultsExecute(r ApiBatchUpdateBulkUploadResultsRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchApiService.BatchUpdateBulkUploadResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/batch/action/updateBulkUploadResults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchUpdateExclusiveConvertCollectionJobRequest struct {
	ctx context.Context
	ApiService *BatchApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BatchUpdateExclusiveConvertCollectionJobRequest
}

func (r ApiBatchUpdateExclusiveConvertCollectionJobRequest) Ks(ks string) ApiBatchUpdateExclusiveConvertCollectionJobRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBatchUpdateExclusiveConvertCollectionJobRequest) Format(format int32) ApiBatchUpdateExclusiveConvertCollectionJobRequest {
	r.format = &format
	return r
}

func (r ApiBatchUpdateExclusiveConvertCollectionJobRequest) ClientTag(clientTag string) ApiBatchUpdateExclusiveConvertCollectionJobRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBatchUpdateExclusiveConvertCollectionJobRequest) PartnerId(partnerId int32) ApiBatchUpdateExclusiveConvertCollectionJobRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBatchUpdateExclusiveConvertCollectionJobRequest) Body(body BatchUpdateExclusiveConvertCollectionJobRequest) ApiBatchUpdateExclusiveConvertCollectionJobRequest {
	r.body = &body
	return r
}

func (r ApiBatchUpdateExclusiveConvertCollectionJobRequest) Execute() (*KalturaBatchJob, *http.Response, error) {
	return r.ApiService.BatchUpdateExclusiveConvertCollectionJobExecute(r)
}

/*
BatchUpdateExclusiveConvertCollectionJob Method for BatchUpdateExclusiveConvertCollectionJob

batch updateExclusiveConvertCollectionJobAction action updates a BatchJob of type CONVERT_PROFILE that was claimed using the getExclusiveConvertJobs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchUpdateExclusiveConvertCollectionJobRequest
*/
func (a *BatchApiService) BatchUpdateExclusiveConvertCollectionJob(ctx context.Context) ApiBatchUpdateExclusiveConvertCollectionJobRequest {
	return ApiBatchUpdateExclusiveConvertCollectionJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJob
func (a *BatchApiService) BatchUpdateExclusiveConvertCollectionJobExecute(r ApiBatchUpdateExclusiveConvertCollectionJobRequest) (*KalturaBatchJob, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJob
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchApiService.BatchUpdateExclusiveConvertCollectionJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/batch/action/updateExclusiveConvertCollectionJob"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchUpdateExclusiveJobRequest struct {
	ctx context.Context
	ApiService *BatchApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BatchUpdateExclusiveJobRequest
}

func (r ApiBatchUpdateExclusiveJobRequest) Ks(ks string) ApiBatchUpdateExclusiveJobRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBatchUpdateExclusiveJobRequest) Format(format int32) ApiBatchUpdateExclusiveJobRequest {
	r.format = &format
	return r
}

func (r ApiBatchUpdateExclusiveJobRequest) ClientTag(clientTag string) ApiBatchUpdateExclusiveJobRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBatchUpdateExclusiveJobRequest) PartnerId(partnerId int32) ApiBatchUpdateExclusiveJobRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBatchUpdateExclusiveJobRequest) Body(body BatchUpdateExclusiveJobRequest) ApiBatchUpdateExclusiveJobRequest {
	r.body = &body
	return r
}

func (r ApiBatchUpdateExclusiveJobRequest) Execute() (*KalturaBatchJob, *http.Response, error) {
	return r.ApiService.BatchUpdateExclusiveJobExecute(r)
}

/*
BatchUpdateExclusiveJob Method for BatchUpdateExclusiveJob

batch updateExclusiveJobAction action updates a BatchJob of extended type that was claimed using the getExclusiveJobs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchUpdateExclusiveJobRequest
*/
func (a *BatchApiService) BatchUpdateExclusiveJob(ctx context.Context) ApiBatchUpdateExclusiveJobRequest {
	return ApiBatchUpdateExclusiveJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJob
func (a *BatchApiService) BatchUpdateExclusiveJobExecute(r ApiBatchUpdateExclusiveJobRequest) (*KalturaBatchJob, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJob
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchApiService.BatchUpdateExclusiveJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/batch/action/updateExclusiveJob"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchUpdatePartnerLoadTableRequest struct {
	ctx context.Context
	ApiService *BatchApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	batchCleanExclusiveJobsRequest *BatchCleanExclusiveJobsRequest
}

func (r ApiBatchUpdatePartnerLoadTableRequest) Ks(ks string) ApiBatchUpdatePartnerLoadTableRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBatchUpdatePartnerLoadTableRequest) Format(format int32) ApiBatchUpdatePartnerLoadTableRequest {
	r.format = &format
	return r
}

func (r ApiBatchUpdatePartnerLoadTableRequest) ClientTag(clientTag string) ApiBatchUpdatePartnerLoadTableRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBatchUpdatePartnerLoadTableRequest) PartnerId(partnerId int32) ApiBatchUpdatePartnerLoadTableRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBatchUpdatePartnerLoadTableRequest) BatchCleanExclusiveJobsRequest(batchCleanExclusiveJobsRequest BatchCleanExclusiveJobsRequest) ApiBatchUpdatePartnerLoadTableRequest {
	r.batchCleanExclusiveJobsRequest = &batchCleanExclusiveJobsRequest
	return r
}

func (r ApiBatchUpdatePartnerLoadTableRequest) Execute() (*http.Response, error) {
	return r.ApiService.BatchUpdatePartnerLoadTableExecute(r)
}

/*
BatchUpdatePartnerLoadTable Method for BatchUpdatePartnerLoadTable

batch updatePartnerLoadTable action cleans the partner load table

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchUpdatePartnerLoadTableRequest
*/
func (a *BatchApiService) BatchUpdatePartnerLoadTable(ctx context.Context) ApiBatchUpdatePartnerLoadTableRequest {
	return ApiBatchUpdatePartnerLoadTableRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *BatchApiService) BatchUpdatePartnerLoadTableExecute(r ApiBatchUpdatePartnerLoadTableRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchApiService.BatchUpdatePartnerLoadTable")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/batch/action/updatePartnerLoadTable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchCleanExclusiveJobsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
