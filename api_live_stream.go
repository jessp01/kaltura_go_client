/*
Kaltura VPaaS

The Kaltura VPaaS API

API version: 18.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
)


// LiveStreamApiService LiveStreamApi service
type LiveStreamApiService service

type ApiLiveStreamAddRequest struct {
	ctx context.Context
	ApiService *LiveStreamApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *LiveStreamAddRequest
}

func (r ApiLiveStreamAddRequest) Ks(ks string) ApiLiveStreamAddRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiLiveStreamAddRequest) Format(format int32) ApiLiveStreamAddRequest {
	r.format = &format
	return r
}

func (r ApiLiveStreamAddRequest) ClientTag(clientTag string) ApiLiveStreamAddRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiLiveStreamAddRequest) PartnerId(partnerId int32) ApiLiveStreamAddRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiLiveStreamAddRequest) Body(body LiveStreamAddRequest) ApiLiveStreamAddRequest {
	r.body = &body
	return r
}

func (r ApiLiveStreamAddRequest) Execute() (*KalturaLiveStreamEntry, *http.Response, error) {
	return r.ApiService.LiveStreamAddExecute(r)
}

/*
LiveStreamAdd Method for LiveStreamAdd

Adds new live stream entry.

The entry will be queued for provision.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLiveStreamAddRequest
*/
func (a *LiveStreamApiService) LiveStreamAdd(ctx context.Context) ApiLiveStreamAddRequest {
	return ApiLiveStreamAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaLiveStreamEntry
func (a *LiveStreamApiService) LiveStreamAddExecute(r ApiLiveStreamAddRequest) (*KalturaLiveStreamEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaLiveStreamEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamApiService.LiveStreamAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/livestream/action/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveStreamAddLiveStreamPushPublishConfigurationRequest struct {
	ctx context.Context
	ApiService *LiveStreamApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *LiveStreamAddLiveStreamPushPublishConfigurationRequest
}

func (r ApiLiveStreamAddLiveStreamPushPublishConfigurationRequest) Ks(ks string) ApiLiveStreamAddLiveStreamPushPublishConfigurationRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiLiveStreamAddLiveStreamPushPublishConfigurationRequest) Format(format int32) ApiLiveStreamAddLiveStreamPushPublishConfigurationRequest {
	r.format = &format
	return r
}

func (r ApiLiveStreamAddLiveStreamPushPublishConfigurationRequest) ClientTag(clientTag string) ApiLiveStreamAddLiveStreamPushPublishConfigurationRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiLiveStreamAddLiveStreamPushPublishConfigurationRequest) PartnerId(partnerId int32) ApiLiveStreamAddLiveStreamPushPublishConfigurationRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiLiveStreamAddLiveStreamPushPublishConfigurationRequest) Body(body LiveStreamAddLiveStreamPushPublishConfigurationRequest) ApiLiveStreamAddLiveStreamPushPublishConfigurationRequest {
	r.body = &body
	return r
}

func (r ApiLiveStreamAddLiveStreamPushPublishConfigurationRequest) Execute() (*KalturaLiveStreamEntry, *http.Response, error) {
	return r.ApiService.LiveStreamAddLiveStreamPushPublishConfigurationExecute(r)
}

/*
LiveStreamAddLiveStreamPushPublishConfiguration Method for LiveStreamAddLiveStreamPushPublishConfiguration

Add new pushPublish configuration to entry

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLiveStreamAddLiveStreamPushPublishConfigurationRequest
*/
func (a *LiveStreamApiService) LiveStreamAddLiveStreamPushPublishConfiguration(ctx context.Context) ApiLiveStreamAddLiveStreamPushPublishConfigurationRequest {
	return ApiLiveStreamAddLiveStreamPushPublishConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaLiveStreamEntry
func (a *LiveStreamApiService) LiveStreamAddLiveStreamPushPublishConfigurationExecute(r ApiLiveStreamAddLiveStreamPushPublishConfigurationRequest) (*KalturaLiveStreamEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaLiveStreamEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamApiService.LiveStreamAddLiveStreamPushPublishConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/livestream/action/addLiveStreamPushPublishConfiguration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveStreamAllocateConferenceRoomRequest struct {
	ctx context.Context
	ApiService *LiveStreamApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *LiveStreamAllocateConferenceRoomRequest
}

func (r ApiLiveStreamAllocateConferenceRoomRequest) Ks(ks string) ApiLiveStreamAllocateConferenceRoomRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiLiveStreamAllocateConferenceRoomRequest) Format(format int32) ApiLiveStreamAllocateConferenceRoomRequest {
	r.format = &format
	return r
}

func (r ApiLiveStreamAllocateConferenceRoomRequest) ClientTag(clientTag string) ApiLiveStreamAllocateConferenceRoomRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiLiveStreamAllocateConferenceRoomRequest) PartnerId(partnerId int32) ApiLiveStreamAllocateConferenceRoomRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiLiveStreamAllocateConferenceRoomRequest) Body(body LiveStreamAllocateConferenceRoomRequest) ApiLiveStreamAllocateConferenceRoomRequest {
	r.body = &body
	return r
}

func (r ApiLiveStreamAllocateConferenceRoomRequest) Execute() (*KalturaRoomDetails, *http.Response, error) {
	return r.ApiService.LiveStreamAllocateConferenceRoomExecute(r)
}

/*
LiveStreamAllocateConferenceRoom Method for LiveStreamAllocateConferenceRoom

Allocates a conference room or returns ones that has already been allocated

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLiveStreamAllocateConferenceRoomRequest
*/
func (a *LiveStreamApiService) LiveStreamAllocateConferenceRoom(ctx context.Context) ApiLiveStreamAllocateConferenceRoomRequest {
	return ApiLiveStreamAllocateConferenceRoomRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaRoomDetails
func (a *LiveStreamApiService) LiveStreamAllocateConferenceRoomExecute(r ApiLiveStreamAllocateConferenceRoomRequest) (*KalturaRoomDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaRoomDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamApiService.LiveStreamAllocateConferenceRoom")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/livestream/action/allocateConferenceRoom"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveStreamAppendRecordingRequest struct {
	ctx context.Context
	ApiService *LiveStreamApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *LiveStreamAppendRecordingRequest
}

func (r ApiLiveStreamAppendRecordingRequest) Ks(ks string) ApiLiveStreamAppendRecordingRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiLiveStreamAppendRecordingRequest) Format(format int32) ApiLiveStreamAppendRecordingRequest {
	r.format = &format
	return r
}

func (r ApiLiveStreamAppendRecordingRequest) ClientTag(clientTag string) ApiLiveStreamAppendRecordingRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiLiveStreamAppendRecordingRequest) PartnerId(partnerId int32) ApiLiveStreamAppendRecordingRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiLiveStreamAppendRecordingRequest) Body(body LiveStreamAppendRecordingRequest) ApiLiveStreamAppendRecordingRequest {
	r.body = &body
	return r
}

func (r ApiLiveStreamAppendRecordingRequest) Execute() (*KalturaLiveEntry, *http.Response, error) {
	return r.ApiService.LiveStreamAppendRecordingExecute(r)
}

/*
LiveStreamAppendRecording Method for LiveStreamAppendRecording

Append recorded video to live entry

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLiveStreamAppendRecordingRequest
*/
func (a *LiveStreamApiService) LiveStreamAppendRecording(ctx context.Context) ApiLiveStreamAppendRecordingRequest {
	return ApiLiveStreamAppendRecordingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaLiveEntry
func (a *LiveStreamApiService) LiveStreamAppendRecordingExecute(r ApiLiveStreamAppendRecordingRequest) (*KalturaLiveEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaLiveEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamApiService.LiveStreamAppendRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/livestream/action/appendRecording"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveStreamArchiveRequest struct {
	ctx context.Context
	ApiService *LiveStreamApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *LiveStreamArchiveRequest
}

func (r ApiLiveStreamArchiveRequest) Ks(ks string) ApiLiveStreamArchiveRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiLiveStreamArchiveRequest) Format(format int32) ApiLiveStreamArchiveRequest {
	r.format = &format
	return r
}

func (r ApiLiveStreamArchiveRequest) ClientTag(clientTag string) ApiLiveStreamArchiveRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiLiveStreamArchiveRequest) PartnerId(partnerId int32) ApiLiveStreamArchiveRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiLiveStreamArchiveRequest) Body(body LiveStreamArchiveRequest) ApiLiveStreamArchiveRequest {
	r.body = &body
	return r
}

func (r ApiLiveStreamArchiveRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.LiveStreamArchiveExecute(r)
}

/*
LiveStreamArchive Method for LiveStreamArchive

Archive a live entry which was recorded

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLiveStreamArchiveRequest
*/
func (a *LiveStreamApiService) LiveStreamArchive(ctx context.Context) ApiLiveStreamArchiveRequest {
	return ApiLiveStreamArchiveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return bool
func (a *LiveStreamApiService) LiveStreamArchiveExecute(r ApiLiveStreamArchiveRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamApiService.LiveStreamArchive")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/livestream/action/archive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveStreamAuthenticateRequest struct {
	ctx context.Context
	ApiService *LiveStreamApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *LiveStreamAuthenticateRequest
}

func (r ApiLiveStreamAuthenticateRequest) Ks(ks string) ApiLiveStreamAuthenticateRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiLiveStreamAuthenticateRequest) Format(format int32) ApiLiveStreamAuthenticateRequest {
	r.format = &format
	return r
}

func (r ApiLiveStreamAuthenticateRequest) ClientTag(clientTag string) ApiLiveStreamAuthenticateRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiLiveStreamAuthenticateRequest) PartnerId(partnerId int32) ApiLiveStreamAuthenticateRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiLiveStreamAuthenticateRequest) Body(body LiveStreamAuthenticateRequest) ApiLiveStreamAuthenticateRequest {
	r.body = &body
	return r
}

func (r ApiLiveStreamAuthenticateRequest) Execute() (*KalturaLiveStreamEntry, *http.Response, error) {
	return r.ApiService.LiveStreamAuthenticateExecute(r)
}

/*
LiveStreamAuthenticate Method for LiveStreamAuthenticate

Authenticate live-stream entry against stream token and partner limitations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLiveStreamAuthenticateRequest
*/
func (a *LiveStreamApiService) LiveStreamAuthenticate(ctx context.Context) ApiLiveStreamAuthenticateRequest {
	return ApiLiveStreamAuthenticateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaLiveStreamEntry
func (a *LiveStreamApiService) LiveStreamAuthenticateExecute(r ApiLiveStreamAuthenticateRequest) (*KalturaLiveStreamEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaLiveStreamEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamApiService.LiveStreamAuthenticate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/livestream/action/authenticate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveStreamCreatePeriodicSyncPointsRequest struct {
	ctx context.Context
	ApiService *LiveStreamApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *LiveStreamCreatePeriodicSyncPointsRequest
}

func (r ApiLiveStreamCreatePeriodicSyncPointsRequest) Ks(ks string) ApiLiveStreamCreatePeriodicSyncPointsRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiLiveStreamCreatePeriodicSyncPointsRequest) Format(format int32) ApiLiveStreamCreatePeriodicSyncPointsRequest {
	r.format = &format
	return r
}

func (r ApiLiveStreamCreatePeriodicSyncPointsRequest) ClientTag(clientTag string) ApiLiveStreamCreatePeriodicSyncPointsRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiLiveStreamCreatePeriodicSyncPointsRequest) PartnerId(partnerId int32) ApiLiveStreamCreatePeriodicSyncPointsRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiLiveStreamCreatePeriodicSyncPointsRequest) Body(body LiveStreamCreatePeriodicSyncPointsRequest) ApiLiveStreamCreatePeriodicSyncPointsRequest {
	r.body = &body
	return r
}

func (r ApiLiveStreamCreatePeriodicSyncPointsRequest) Execute() (*http.Response, error) {
	return r.ApiService.LiveStreamCreatePeriodicSyncPointsExecute(r)
}

/*
LiveStreamCreatePeriodicSyncPoints Method for LiveStreamCreatePeriodicSyncPoints

Creates periodic metadata sync-point events on a live stream

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLiveStreamCreatePeriodicSyncPointsRequest

Deprecated
*/
func (a *LiveStreamApiService) LiveStreamCreatePeriodicSyncPoints(ctx context.Context) ApiLiveStreamCreatePeriodicSyncPointsRequest {
	return ApiLiveStreamCreatePeriodicSyncPointsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
// Deprecated
func (a *LiveStreamApiService) LiveStreamCreatePeriodicSyncPointsExecute(r ApiLiveStreamCreatePeriodicSyncPointsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamApiService.LiveStreamCreatePeriodicSyncPoints")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/livestream/action/createPeriodicSyncPoints"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLiveStreamCreateRecordedEntryRequest struct {
	ctx context.Context
	ApiService *LiveStreamApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *LiveStreamCreateRecordedEntryRequest
}

func (r ApiLiveStreamCreateRecordedEntryRequest) Ks(ks string) ApiLiveStreamCreateRecordedEntryRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiLiveStreamCreateRecordedEntryRequest) Format(format int32) ApiLiveStreamCreateRecordedEntryRequest {
	r.format = &format
	return r
}

func (r ApiLiveStreamCreateRecordedEntryRequest) ClientTag(clientTag string) ApiLiveStreamCreateRecordedEntryRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiLiveStreamCreateRecordedEntryRequest) PartnerId(partnerId int32) ApiLiveStreamCreateRecordedEntryRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiLiveStreamCreateRecordedEntryRequest) Body(body LiveStreamCreateRecordedEntryRequest) ApiLiveStreamCreateRecordedEntryRequest {
	r.body = &body
	return r
}

func (r ApiLiveStreamCreateRecordedEntryRequest) Execute() (*KalturaLiveEntry, *http.Response, error) {
	return r.ApiService.LiveStreamCreateRecordedEntryExecute(r)
}

/*
LiveStreamCreateRecordedEntry Method for LiveStreamCreateRecordedEntry

Create recorded entry id if it doesn't exist and make sure it happens on the DC that the live entry was created on.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLiveStreamCreateRecordedEntryRequest
*/
func (a *LiveStreamApiService) LiveStreamCreateRecordedEntry(ctx context.Context) ApiLiveStreamCreateRecordedEntryRequest {
	return ApiLiveStreamCreateRecordedEntryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaLiveEntry
func (a *LiveStreamApiService) LiveStreamCreateRecordedEntryExecute(r ApiLiveStreamCreateRecordedEntryRequest) (*KalturaLiveEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaLiveEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamApiService.LiveStreamCreateRecordedEntry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/livestream/action/createRecordedEntry"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveStreamDeleteRequest struct {
	ctx context.Context
	ApiService *LiveStreamApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryApproveRequest
}

func (r ApiLiveStreamDeleteRequest) Ks(ks string) ApiLiveStreamDeleteRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiLiveStreamDeleteRequest) Format(format int32) ApiLiveStreamDeleteRequest {
	r.format = &format
	return r
}

func (r ApiLiveStreamDeleteRequest) ClientTag(clientTag string) ApiLiveStreamDeleteRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiLiveStreamDeleteRequest) PartnerId(partnerId int32) ApiLiveStreamDeleteRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiLiveStreamDeleteRequest) Body(body BaseEntryApproveRequest) ApiLiveStreamDeleteRequest {
	r.body = &body
	return r
}

func (r ApiLiveStreamDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.LiveStreamDeleteExecute(r)
}

/*
LiveStreamDelete Method for LiveStreamDelete

Delete a live stream entry.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLiveStreamDeleteRequest
*/
func (a *LiveStreamApiService) LiveStreamDelete(ctx context.Context) ApiLiveStreamDeleteRequest {
	return ApiLiveStreamDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveStreamApiService) LiveStreamDeleteExecute(r ApiLiveStreamDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamApiService.LiveStreamDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/livestream/action/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLiveStreamFinishConfRequest struct {
	ctx context.Context
	ApiService *LiveStreamApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *LiveStreamFinishConfRequest
}

func (r ApiLiveStreamFinishConfRequest) Ks(ks string) ApiLiveStreamFinishConfRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiLiveStreamFinishConfRequest) Format(format int32) ApiLiveStreamFinishConfRequest {
	r.format = &format
	return r
}

func (r ApiLiveStreamFinishConfRequest) ClientTag(clientTag string) ApiLiveStreamFinishConfRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiLiveStreamFinishConfRequest) PartnerId(partnerId int32) ApiLiveStreamFinishConfRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiLiveStreamFinishConfRequest) Body(body LiveStreamFinishConfRequest) ApiLiveStreamFinishConfRequest {
	r.body = &body
	return r
}

func (r ApiLiveStreamFinishConfRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.LiveStreamFinishConfExecute(r)
}

/*
LiveStreamFinishConf Method for LiveStreamFinishConf

When the conf is finished this API should be called.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLiveStreamFinishConfRequest
*/
func (a *LiveStreamApiService) LiveStreamFinishConf(ctx context.Context) ApiLiveStreamFinishConfRequest {
	return ApiLiveStreamFinishConfRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return bool
func (a *LiveStreamApiService) LiveStreamFinishConfExecute(r ApiLiveStreamFinishConfRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamApiService.LiveStreamFinishConf")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/livestream/action/finishConf"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveStreamGetRequest struct {
	ctx context.Context
	ApiService *LiveStreamApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryGetRequest
}

func (r ApiLiveStreamGetRequest) Ks(ks string) ApiLiveStreamGetRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiLiveStreamGetRequest) Format(format int32) ApiLiveStreamGetRequest {
	r.format = &format
	return r
}

func (r ApiLiveStreamGetRequest) ClientTag(clientTag string) ApiLiveStreamGetRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiLiveStreamGetRequest) PartnerId(partnerId int32) ApiLiveStreamGetRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiLiveStreamGetRequest) Body(body BaseEntryGetRequest) ApiLiveStreamGetRequest {
	r.body = &body
	return r
}

func (r ApiLiveStreamGetRequest) Execute() (*KalturaLiveStreamEntry, *http.Response, error) {
	return r.ApiService.LiveStreamGetExecute(r)
}

/*
LiveStreamGet Method for LiveStreamGet

Get live stream entry by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLiveStreamGetRequest
*/
func (a *LiveStreamApiService) LiveStreamGet(ctx context.Context) ApiLiveStreamGetRequest {
	return ApiLiveStreamGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaLiveStreamEntry
func (a *LiveStreamApiService) LiveStreamGetExecute(r ApiLiveStreamGetRequest) (*KalturaLiveStreamEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaLiveStreamEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamApiService.LiveStreamGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/livestream/action/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveStreamGetDetailsRequest struct {
	ctx context.Context
	ApiService *LiveStreamApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AnnotationDeleteRequest
}

func (r ApiLiveStreamGetDetailsRequest) Ks(ks string) ApiLiveStreamGetDetailsRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiLiveStreamGetDetailsRequest) Format(format int32) ApiLiveStreamGetDetailsRequest {
	r.format = &format
	return r
}

func (r ApiLiveStreamGetDetailsRequest) ClientTag(clientTag string) ApiLiveStreamGetDetailsRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiLiveStreamGetDetailsRequest) PartnerId(partnerId int32) ApiLiveStreamGetDetailsRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiLiveStreamGetDetailsRequest) Body(body AnnotationDeleteRequest) ApiLiveStreamGetDetailsRequest {
	r.body = &body
	return r
}

func (r ApiLiveStreamGetDetailsRequest) Execute() (*KalturaLiveStreamDetails, *http.Response, error) {
	return r.ApiService.LiveStreamGetDetailsExecute(r)
}

/*
LiveStreamGetDetails Method for LiveStreamGetDetails

Delivering the status of a live stream (on-air/offline) if it is possible

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLiveStreamGetDetailsRequest
*/
func (a *LiveStreamApiService) LiveStreamGetDetails(ctx context.Context) ApiLiveStreamGetDetailsRequest {
	return ApiLiveStreamGetDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaLiveStreamDetails
func (a *LiveStreamApiService) LiveStreamGetDetailsExecute(r ApiLiveStreamGetDetailsRequest) (*KalturaLiveStreamDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaLiveStreamDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamApiService.LiveStreamGetDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/livestream/action/getDetails"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveStreamIsLiveRequest struct {
	ctx context.Context
	ApiService *LiveStreamApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *LiveStreamIsLiveRequest
}

func (r ApiLiveStreamIsLiveRequest) Ks(ks string) ApiLiveStreamIsLiveRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiLiveStreamIsLiveRequest) Format(format int32) ApiLiveStreamIsLiveRequest {
	r.format = &format
	return r
}

func (r ApiLiveStreamIsLiveRequest) ClientTag(clientTag string) ApiLiveStreamIsLiveRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiLiveStreamIsLiveRequest) PartnerId(partnerId int32) ApiLiveStreamIsLiveRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiLiveStreamIsLiveRequest) Body(body LiveStreamIsLiveRequest) ApiLiveStreamIsLiveRequest {
	r.body = &body
	return r
}

func (r ApiLiveStreamIsLiveRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.LiveStreamIsLiveExecute(r)
}

/*
LiveStreamIsLive Method for LiveStreamIsLive

Delivering the status of a live stream (on-air/offline) if it is possible

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLiveStreamIsLiveRequest
*/
func (a *LiveStreamApiService) LiveStreamIsLive(ctx context.Context) ApiLiveStreamIsLiveRequest {
	return ApiLiveStreamIsLiveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return bool
func (a *LiveStreamApiService) LiveStreamIsLiveExecute(r ApiLiveStreamIsLiveRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamApiService.LiveStreamIsLive")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/livestream/action/isLive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveStreamListRequest struct {
	ctx context.Context
	ApiService *LiveStreamApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *LiveStreamListRequest
}

func (r ApiLiveStreamListRequest) Ks(ks string) ApiLiveStreamListRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiLiveStreamListRequest) Format(format int32) ApiLiveStreamListRequest {
	r.format = &format
	return r
}

func (r ApiLiveStreamListRequest) ClientTag(clientTag string) ApiLiveStreamListRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiLiveStreamListRequest) PartnerId(partnerId int32) ApiLiveStreamListRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiLiveStreamListRequest) Body(body LiveStreamListRequest) ApiLiveStreamListRequest {
	r.body = &body
	return r
}

func (r ApiLiveStreamListRequest) Execute() (*KalturaLiveStreamListResponse, *http.Response, error) {
	return r.ApiService.LiveStreamListExecute(r)
}

/*
LiveStreamList Method for LiveStreamList

List live stream entries by filter with paging support.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLiveStreamListRequest
*/
func (a *LiveStreamApiService) LiveStreamList(ctx context.Context) ApiLiveStreamListRequest {
	return ApiLiveStreamListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaLiveStreamListResponse
func (a *LiveStreamApiService) LiveStreamListExecute(r ApiLiveStreamListRequest) (*KalturaLiveStreamListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaLiveStreamListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamApiService.LiveStreamList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/livestream/action/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveStreamRegenerateStreamTokenRequest struct {
	ctx context.Context
	ApiService *LiveStreamApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryApproveRequest
}

func (r ApiLiveStreamRegenerateStreamTokenRequest) Ks(ks string) ApiLiveStreamRegenerateStreamTokenRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiLiveStreamRegenerateStreamTokenRequest) Format(format int32) ApiLiveStreamRegenerateStreamTokenRequest {
	r.format = &format
	return r
}

func (r ApiLiveStreamRegenerateStreamTokenRequest) ClientTag(clientTag string) ApiLiveStreamRegenerateStreamTokenRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiLiveStreamRegenerateStreamTokenRequest) PartnerId(partnerId int32) ApiLiveStreamRegenerateStreamTokenRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiLiveStreamRegenerateStreamTokenRequest) Body(body BaseEntryApproveRequest) ApiLiveStreamRegenerateStreamTokenRequest {
	r.body = &body
	return r
}

func (r ApiLiveStreamRegenerateStreamTokenRequest) Execute() (*KalturaLiveEntry, *http.Response, error) {
	return r.ApiService.LiveStreamRegenerateStreamTokenExecute(r)
}

/*
LiveStreamRegenerateStreamToken Method for LiveStreamRegenerateStreamToken

Regenerate new secure token for liveStream

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLiveStreamRegenerateStreamTokenRequest
*/
func (a *LiveStreamApiService) LiveStreamRegenerateStreamToken(ctx context.Context) ApiLiveStreamRegenerateStreamTokenRequest {
	return ApiLiveStreamRegenerateStreamTokenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaLiveEntry
func (a *LiveStreamApiService) LiveStreamRegenerateStreamTokenExecute(r ApiLiveStreamRegenerateStreamTokenRequest) (*KalturaLiveEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaLiveEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamApiService.LiveStreamRegenerateStreamToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/livestream/action/regenerateStreamToken"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveStreamRegisterConfRequest struct {
	ctx context.Context
	ApiService *LiveStreamApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryApproveRequest
}

func (r ApiLiveStreamRegisterConfRequest) Ks(ks string) ApiLiveStreamRegisterConfRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiLiveStreamRegisterConfRequest) Format(format int32) ApiLiveStreamRegisterConfRequest {
	r.format = &format
	return r
}

func (r ApiLiveStreamRegisterConfRequest) ClientTag(clientTag string) ApiLiveStreamRegisterConfRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiLiveStreamRegisterConfRequest) PartnerId(partnerId int32) ApiLiveStreamRegisterConfRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiLiveStreamRegisterConfRequest) Body(body BaseEntryApproveRequest) ApiLiveStreamRegisterConfRequest {
	r.body = &body
	return r
}

func (r ApiLiveStreamRegisterConfRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.LiveStreamRegisterConfExecute(r)
}

/*
LiveStreamRegisterConf Method for LiveStreamRegisterConf

Mark that the conference has actually started

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLiveStreamRegisterConfRequest
*/
func (a *LiveStreamApiService) LiveStreamRegisterConf(ctx context.Context) ApiLiveStreamRegisterConfRequest {
	return ApiLiveStreamRegisterConfRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return bool
func (a *LiveStreamApiService) LiveStreamRegisterConfExecute(r ApiLiveStreamRegisterConfRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamApiService.LiveStreamRegisterConf")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/livestream/action/registerConf"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveStreamRegisterMediaServerRequest struct {
	ctx context.Context
	ApiService *LiveStreamApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *LiveStreamRegisterMediaServerRequest
}

func (r ApiLiveStreamRegisterMediaServerRequest) Ks(ks string) ApiLiveStreamRegisterMediaServerRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiLiveStreamRegisterMediaServerRequest) Format(format int32) ApiLiveStreamRegisterMediaServerRequest {
	r.format = &format
	return r
}

func (r ApiLiveStreamRegisterMediaServerRequest) ClientTag(clientTag string) ApiLiveStreamRegisterMediaServerRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiLiveStreamRegisterMediaServerRequest) PartnerId(partnerId int32) ApiLiveStreamRegisterMediaServerRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiLiveStreamRegisterMediaServerRequest) Body(body LiveStreamRegisterMediaServerRequest) ApiLiveStreamRegisterMediaServerRequest {
	r.body = &body
	return r
}

func (r ApiLiveStreamRegisterMediaServerRequest) Execute() (*KalturaLiveEntry, *http.Response, error) {
	return r.ApiService.LiveStreamRegisterMediaServerExecute(r)
}

/*
LiveStreamRegisterMediaServer Method for LiveStreamRegisterMediaServer

Register media server to live entry

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLiveStreamRegisterMediaServerRequest
*/
func (a *LiveStreamApiService) LiveStreamRegisterMediaServer(ctx context.Context) ApiLiveStreamRegisterMediaServerRequest {
	return ApiLiveStreamRegisterMediaServerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaLiveEntry
func (a *LiveStreamApiService) LiveStreamRegisterMediaServerExecute(r ApiLiveStreamRegisterMediaServerRequest) (*KalturaLiveEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaLiveEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamApiService.LiveStreamRegisterMediaServer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/livestream/action/registerMediaServer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveStreamRemoveLiveStreamPushPublishConfigurationRequest struct {
	ctx context.Context
	ApiService *LiveStreamApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *LiveStreamRemoveLiveStreamPushPublishConfigurationRequest
}

func (r ApiLiveStreamRemoveLiveStreamPushPublishConfigurationRequest) Ks(ks string) ApiLiveStreamRemoveLiveStreamPushPublishConfigurationRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiLiveStreamRemoveLiveStreamPushPublishConfigurationRequest) Format(format int32) ApiLiveStreamRemoveLiveStreamPushPublishConfigurationRequest {
	r.format = &format
	return r
}

func (r ApiLiveStreamRemoveLiveStreamPushPublishConfigurationRequest) ClientTag(clientTag string) ApiLiveStreamRemoveLiveStreamPushPublishConfigurationRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiLiveStreamRemoveLiveStreamPushPublishConfigurationRequest) PartnerId(partnerId int32) ApiLiveStreamRemoveLiveStreamPushPublishConfigurationRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiLiveStreamRemoveLiveStreamPushPublishConfigurationRequest) Body(body LiveStreamRemoveLiveStreamPushPublishConfigurationRequest) ApiLiveStreamRemoveLiveStreamPushPublishConfigurationRequest {
	r.body = &body
	return r
}

func (r ApiLiveStreamRemoveLiveStreamPushPublishConfigurationRequest) Execute() (*KalturaLiveStreamEntry, *http.Response, error) {
	return r.ApiService.LiveStreamRemoveLiveStreamPushPublishConfigurationExecute(r)
}

/*
LiveStreamRemoveLiveStreamPushPublishConfiguration Method for LiveStreamRemoveLiveStreamPushPublishConfiguration

Remove push publish configuration from entry

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLiveStreamRemoveLiveStreamPushPublishConfigurationRequest
*/
func (a *LiveStreamApiService) LiveStreamRemoveLiveStreamPushPublishConfiguration(ctx context.Context) ApiLiveStreamRemoveLiveStreamPushPublishConfigurationRequest {
	return ApiLiveStreamRemoveLiveStreamPushPublishConfigurationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaLiveStreamEntry
func (a *LiveStreamApiService) LiveStreamRemoveLiveStreamPushPublishConfigurationExecute(r ApiLiveStreamRemoveLiveStreamPushPublishConfigurationRequest) (*KalturaLiveStreamEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaLiveStreamEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamApiService.LiveStreamRemoveLiveStreamPushPublishConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/livestream/action/removeLiveStreamPushPublishConfiguration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveStreamSetRecordedContentRequest struct {
	ctx context.Context
	ApiService *LiveStreamApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *LiveStreamSetRecordedContentRequest
}

func (r ApiLiveStreamSetRecordedContentRequest) Ks(ks string) ApiLiveStreamSetRecordedContentRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiLiveStreamSetRecordedContentRequest) Format(format int32) ApiLiveStreamSetRecordedContentRequest {
	r.format = &format
	return r
}

func (r ApiLiveStreamSetRecordedContentRequest) ClientTag(clientTag string) ApiLiveStreamSetRecordedContentRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiLiveStreamSetRecordedContentRequest) PartnerId(partnerId int32) ApiLiveStreamSetRecordedContentRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiLiveStreamSetRecordedContentRequest) Body(body LiveStreamSetRecordedContentRequest) ApiLiveStreamSetRecordedContentRequest {
	r.body = &body
	return r
}

func (r ApiLiveStreamSetRecordedContentRequest) Execute() (*KalturaLiveEntry, *http.Response, error) {
	return r.ApiService.LiveStreamSetRecordedContentExecute(r)
}

/*
LiveStreamSetRecordedContent Method for LiveStreamSetRecordedContent

Set recorded video to live entry

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLiveStreamSetRecordedContentRequest
*/
func (a *LiveStreamApiService) LiveStreamSetRecordedContent(ctx context.Context) ApiLiveStreamSetRecordedContentRequest {
	return ApiLiveStreamSetRecordedContentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaLiveEntry
func (a *LiveStreamApiService) LiveStreamSetRecordedContentExecute(r ApiLiveStreamSetRecordedContentRequest) (*KalturaLiveEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaLiveEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamApiService.LiveStreamSetRecordedContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/livestream/action/setRecordedContent"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveStreamUnregisterMediaServerRequest struct {
	ctx context.Context
	ApiService *LiveStreamApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *LiveStreamUnregisterMediaServerRequest
}

func (r ApiLiveStreamUnregisterMediaServerRequest) Ks(ks string) ApiLiveStreamUnregisterMediaServerRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiLiveStreamUnregisterMediaServerRequest) Format(format int32) ApiLiveStreamUnregisterMediaServerRequest {
	r.format = &format
	return r
}

func (r ApiLiveStreamUnregisterMediaServerRequest) ClientTag(clientTag string) ApiLiveStreamUnregisterMediaServerRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiLiveStreamUnregisterMediaServerRequest) PartnerId(partnerId int32) ApiLiveStreamUnregisterMediaServerRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiLiveStreamUnregisterMediaServerRequest) Body(body LiveStreamUnregisterMediaServerRequest) ApiLiveStreamUnregisterMediaServerRequest {
	r.body = &body
	return r
}

func (r ApiLiveStreamUnregisterMediaServerRequest) Execute() (*KalturaLiveEntry, *http.Response, error) {
	return r.ApiService.LiveStreamUnregisterMediaServerExecute(r)
}

/*
LiveStreamUnregisterMediaServer Method for LiveStreamUnregisterMediaServer

Unregister media server from live entry

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLiveStreamUnregisterMediaServerRequest
*/
func (a *LiveStreamApiService) LiveStreamUnregisterMediaServer(ctx context.Context) ApiLiveStreamUnregisterMediaServerRequest {
	return ApiLiveStreamUnregisterMediaServerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaLiveEntry
func (a *LiveStreamApiService) LiveStreamUnregisterMediaServerExecute(r ApiLiveStreamUnregisterMediaServerRequest) (*KalturaLiveEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaLiveEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamApiService.LiveStreamUnregisterMediaServer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/livestream/action/unregisterMediaServer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveStreamUpdateRequest struct {
	ctx context.Context
	ApiService *LiveStreamApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *LiveStreamUpdateRequest
}

func (r ApiLiveStreamUpdateRequest) Ks(ks string) ApiLiveStreamUpdateRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiLiveStreamUpdateRequest) Format(format int32) ApiLiveStreamUpdateRequest {
	r.format = &format
	return r
}

func (r ApiLiveStreamUpdateRequest) ClientTag(clientTag string) ApiLiveStreamUpdateRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiLiveStreamUpdateRequest) PartnerId(partnerId int32) ApiLiveStreamUpdateRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiLiveStreamUpdateRequest) Body(body LiveStreamUpdateRequest) ApiLiveStreamUpdateRequest {
	r.body = &body
	return r
}

func (r ApiLiveStreamUpdateRequest) Execute() (*KalturaLiveStreamEntry, *http.Response, error) {
	return r.ApiService.LiveStreamUpdateExecute(r)
}

/*
LiveStreamUpdate Method for LiveStreamUpdate

Update live stream entry. Only the properties that were set will be updated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLiveStreamUpdateRequest
*/
func (a *LiveStreamApiService) LiveStreamUpdate(ctx context.Context) ApiLiveStreamUpdateRequest {
	return ApiLiveStreamUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaLiveStreamEntry
func (a *LiveStreamApiService) LiveStreamUpdateExecute(r ApiLiveStreamUpdateRequest) (*KalturaLiveStreamEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaLiveStreamEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamApiService.LiveStreamUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/livestream/action/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveStreamUpdateOfflineThumbnailFromUrlRequest struct {
	ctx context.Context
	ApiService *LiveStreamApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryUpdateThumbnailFromUrlRequest
}

func (r ApiLiveStreamUpdateOfflineThumbnailFromUrlRequest) Ks(ks string) ApiLiveStreamUpdateOfflineThumbnailFromUrlRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiLiveStreamUpdateOfflineThumbnailFromUrlRequest) Format(format int32) ApiLiveStreamUpdateOfflineThumbnailFromUrlRequest {
	r.format = &format
	return r
}

func (r ApiLiveStreamUpdateOfflineThumbnailFromUrlRequest) ClientTag(clientTag string) ApiLiveStreamUpdateOfflineThumbnailFromUrlRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiLiveStreamUpdateOfflineThumbnailFromUrlRequest) PartnerId(partnerId int32) ApiLiveStreamUpdateOfflineThumbnailFromUrlRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiLiveStreamUpdateOfflineThumbnailFromUrlRequest) Body(body BaseEntryUpdateThumbnailFromUrlRequest) ApiLiveStreamUpdateOfflineThumbnailFromUrlRequest {
	r.body = &body
	return r
}

func (r ApiLiveStreamUpdateOfflineThumbnailFromUrlRequest) Execute() (*KalturaLiveStreamEntry, *http.Response, error) {
	return r.ApiService.LiveStreamUpdateOfflineThumbnailFromUrlExecute(r)
}

/*
LiveStreamUpdateOfflineThumbnailFromUrl Method for LiveStreamUpdateOfflineThumbnailFromUrl

Update entry thumbnail using url

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLiveStreamUpdateOfflineThumbnailFromUrlRequest
*/
func (a *LiveStreamApiService) LiveStreamUpdateOfflineThumbnailFromUrl(ctx context.Context) ApiLiveStreamUpdateOfflineThumbnailFromUrlRequest {
	return ApiLiveStreamUpdateOfflineThumbnailFromUrlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaLiveStreamEntry
func (a *LiveStreamApiService) LiveStreamUpdateOfflineThumbnailFromUrlExecute(r ApiLiveStreamUpdateOfflineThumbnailFromUrlRequest) (*KalturaLiveStreamEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaLiveStreamEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamApiService.LiveStreamUpdateOfflineThumbnailFromUrl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/livestream/action/updateOfflineThumbnailFromUrl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveStreamUpdateOfflineThumbnailJpegRequest struct {
	ctx context.Context
	ApiService *LiveStreamApiService
	entryId *string
	fileData **os.File
	ks *string
	format *int32
}

// live stream entry id
func (r ApiLiveStreamUpdateOfflineThumbnailJpegRequest) EntryId(entryId string) ApiLiveStreamUpdateOfflineThumbnailJpegRequest {
	r.entryId = &entryId
	return r
}

// Jpeg file data
func (r ApiLiveStreamUpdateOfflineThumbnailJpegRequest) FileData(fileData *os.File) ApiLiveStreamUpdateOfflineThumbnailJpegRequest {
	r.fileData = &fileData
	return r
}

func (r ApiLiveStreamUpdateOfflineThumbnailJpegRequest) Ks(ks string) ApiLiveStreamUpdateOfflineThumbnailJpegRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiLiveStreamUpdateOfflineThumbnailJpegRequest) Format(format int32) ApiLiveStreamUpdateOfflineThumbnailJpegRequest {
	r.format = &format
	return r
}

func (r ApiLiveStreamUpdateOfflineThumbnailJpegRequest) Execute() (*KalturaLiveStreamEntry, *http.Response, error) {
	return r.ApiService.LiveStreamUpdateOfflineThumbnailJpegExecute(r)
}

/*
LiveStreamUpdateOfflineThumbnailJpeg Method for LiveStreamUpdateOfflineThumbnailJpeg

Update live stream entry thumbnail using a raw jpeg file

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLiveStreamUpdateOfflineThumbnailJpegRequest
*/
func (a *LiveStreamApiService) LiveStreamUpdateOfflineThumbnailJpeg(ctx context.Context) ApiLiveStreamUpdateOfflineThumbnailJpegRequest {
	return ApiLiveStreamUpdateOfflineThumbnailJpegRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaLiveStreamEntry
func (a *LiveStreamApiService) LiveStreamUpdateOfflineThumbnailJpegExecute(r ApiLiveStreamUpdateOfflineThumbnailJpegRequest) (*KalturaLiveStreamEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaLiveStreamEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamApiService.LiveStreamUpdateOfflineThumbnailJpeg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/livestream/action/updateOfflineThumbnailJpeg"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.entryId == nil {
		return localVarReturnValue, nil, reportError("entryId is required and must be specified")
	}
	if r.fileData == nil {
		return localVarReturnValue, nil, reportError("fileData is required and must be specified")
	}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	localVarQueryParams.Add("entryId", parameterToString(*r.entryId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileDataLocalVarFormFileName string
	var fileDataLocalVarFileName     string
	var fileDataLocalVarFileBytes    []byte

	fileDataLocalVarFormFileName = "fileData"

	fileDataLocalVarFile := *r.fileData
	if fileDataLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(fileDataLocalVarFile)
		fileDataLocalVarFileBytes = fbs
		fileDataLocalVarFileName = fileDataLocalVarFile.Name()
		fileDataLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: fileDataLocalVarFileBytes, fileName: fileDataLocalVarFileName, formFileName: fileDataLocalVarFormFileName})
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveStreamValidateRegisteredMediaServersRequest struct {
	ctx context.Context
	ApiService *LiveStreamApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryApproveRequest
}

func (r ApiLiveStreamValidateRegisteredMediaServersRequest) Ks(ks string) ApiLiveStreamValidateRegisteredMediaServersRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiLiveStreamValidateRegisteredMediaServersRequest) Format(format int32) ApiLiveStreamValidateRegisteredMediaServersRequest {
	r.format = &format
	return r
}

func (r ApiLiveStreamValidateRegisteredMediaServersRequest) ClientTag(clientTag string) ApiLiveStreamValidateRegisteredMediaServersRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiLiveStreamValidateRegisteredMediaServersRequest) PartnerId(partnerId int32) ApiLiveStreamValidateRegisteredMediaServersRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiLiveStreamValidateRegisteredMediaServersRequest) Body(body BaseEntryApproveRequest) ApiLiveStreamValidateRegisteredMediaServersRequest {
	r.body = &body
	return r
}

func (r ApiLiveStreamValidateRegisteredMediaServersRequest) Execute() (*http.Response, error) {
	return r.ApiService.LiveStreamValidateRegisteredMediaServersExecute(r)
}

/*
LiveStreamValidateRegisteredMediaServers Method for LiveStreamValidateRegisteredMediaServers

Validates all registered media servers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLiveStreamValidateRegisteredMediaServersRequest
*/
func (a *LiveStreamApiService) LiveStreamValidateRegisteredMediaServers(ctx context.Context) ApiLiveStreamValidateRegisteredMediaServersRequest {
	return ApiLiveStreamValidateRegisteredMediaServersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveStreamApiService) LiveStreamValidateRegisteredMediaServersExecute(r ApiLiveStreamValidateRegisteredMediaServersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveStreamApiService.LiveStreamValidateRegisteredMediaServers")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/livestream/action/validateRegisteredMediaServers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
