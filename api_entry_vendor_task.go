/*
Kaltura VPaaS

The Kaltura VPaaS API

API version: 18.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// EntryVendorTaskApiService EntryVendorTaskApi service
type EntryVendorTaskApiService service

type ApiEntryVendorTaskAbortRequest struct {
	ctx context.Context
	ApiService *EntryVendorTaskApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *EntryVendorTaskAbortRequest
}

func (r ApiEntryVendorTaskAbortRequest) Ks(ks string) ApiEntryVendorTaskAbortRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryVendorTaskAbortRequest) Format(format int32) ApiEntryVendorTaskAbortRequest {
	r.format = &format
	return r
}

func (r ApiEntryVendorTaskAbortRequest) ClientTag(clientTag string) ApiEntryVendorTaskAbortRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryVendorTaskAbortRequest) PartnerId(partnerId int32) ApiEntryVendorTaskAbortRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryVendorTaskAbortRequest) Body(body EntryVendorTaskAbortRequest) ApiEntryVendorTaskAbortRequest {
	r.body = &body
	return r
}

func (r ApiEntryVendorTaskAbortRequest) Execute() (*KalturaEntryVendorTask, *http.Response, error) {
	return r.ApiService.EntryVendorTaskAbortExecute(r)
}

/*
EntryVendorTaskAbort Method for EntryVendorTaskAbort

Cancel entry task. will only occur for task in PENDING or PENDING_MODERATION status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryVendorTaskAbortRequest
*/
func (a *EntryVendorTaskApiService) EntryVendorTaskAbort(ctx context.Context) ApiEntryVendorTaskAbortRequest {
	return ApiEntryVendorTaskAbortRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEntryVendorTask
func (a *EntryVendorTaskApiService) EntryVendorTaskAbortExecute(r ApiEntryVendorTaskAbortRequest) (*KalturaEntryVendorTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEntryVendorTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryVendorTaskApiService.EntryVendorTaskAbort")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/reach_entryvendortask/action/abort"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEntryVendorTaskAddRequest struct {
	ctx context.Context
	ApiService *EntryVendorTaskApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *EntryVendorTaskAddRequest
}

func (r ApiEntryVendorTaskAddRequest) Ks(ks string) ApiEntryVendorTaskAddRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryVendorTaskAddRequest) Format(format int32) ApiEntryVendorTaskAddRequest {
	r.format = &format
	return r
}

func (r ApiEntryVendorTaskAddRequest) ClientTag(clientTag string) ApiEntryVendorTaskAddRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryVendorTaskAddRequest) PartnerId(partnerId int32) ApiEntryVendorTaskAddRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryVendorTaskAddRequest) Body(body EntryVendorTaskAddRequest) ApiEntryVendorTaskAddRequest {
	r.body = &body
	return r
}

func (r ApiEntryVendorTaskAddRequest) Execute() (*KalturaEntryVendorTask, *http.Response, error) {
	return r.ApiService.EntryVendorTaskAddExecute(r)
}

/*
EntryVendorTaskAdd Method for EntryVendorTaskAdd

Allows you to add a entry vendor task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryVendorTaskAddRequest
*/
func (a *EntryVendorTaskApiService) EntryVendorTaskAdd(ctx context.Context) ApiEntryVendorTaskAddRequest {
	return ApiEntryVendorTaskAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEntryVendorTask
func (a *EntryVendorTaskApiService) EntryVendorTaskAddExecute(r ApiEntryVendorTaskAddRequest) (*KalturaEntryVendorTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEntryVendorTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryVendorTaskApiService.EntryVendorTaskAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/reach_entryvendortask/action/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEntryVendorTaskApproveRequest struct {
	ctx context.Context
	ApiService *EntryVendorTaskApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AccessControlDeleteRequest
}

func (r ApiEntryVendorTaskApproveRequest) Ks(ks string) ApiEntryVendorTaskApproveRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryVendorTaskApproveRequest) Format(format int32) ApiEntryVendorTaskApproveRequest {
	r.format = &format
	return r
}

func (r ApiEntryVendorTaskApproveRequest) ClientTag(clientTag string) ApiEntryVendorTaskApproveRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryVendorTaskApproveRequest) PartnerId(partnerId int32) ApiEntryVendorTaskApproveRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryVendorTaskApproveRequest) Body(body AccessControlDeleteRequest) ApiEntryVendorTaskApproveRequest {
	r.body = &body
	return r
}

func (r ApiEntryVendorTaskApproveRequest) Execute() (*KalturaEntryVendorTask, *http.Response, error) {
	return r.ApiService.EntryVendorTaskApproveExecute(r)
}

/*
EntryVendorTaskApprove Method for EntryVendorTaskApprove

Approve entry vendor task for execution.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryVendorTaskApproveRequest
*/
func (a *EntryVendorTaskApiService) EntryVendorTaskApprove(ctx context.Context) ApiEntryVendorTaskApproveRequest {
	return ApiEntryVendorTaskApproveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEntryVendorTask
func (a *EntryVendorTaskApiService) EntryVendorTaskApproveExecute(r ApiEntryVendorTaskApproveRequest) (*KalturaEntryVendorTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEntryVendorTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryVendorTaskApiService.EntryVendorTaskApprove")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/reach_entryvendortask/action/approve"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEntryVendorTaskExportToCsvRequest struct {
	ctx context.Context
	ApiService *EntryVendorTaskApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *EntryVendorTaskExportToCsvRequest
}

func (r ApiEntryVendorTaskExportToCsvRequest) Ks(ks string) ApiEntryVendorTaskExportToCsvRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryVendorTaskExportToCsvRequest) Format(format int32) ApiEntryVendorTaskExportToCsvRequest {
	r.format = &format
	return r
}

func (r ApiEntryVendorTaskExportToCsvRequest) ClientTag(clientTag string) ApiEntryVendorTaskExportToCsvRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryVendorTaskExportToCsvRequest) PartnerId(partnerId int32) ApiEntryVendorTaskExportToCsvRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryVendorTaskExportToCsvRequest) Body(body EntryVendorTaskExportToCsvRequest) ApiEntryVendorTaskExportToCsvRequest {
	r.body = &body
	return r
}

func (r ApiEntryVendorTaskExportToCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.EntryVendorTaskExportToCsvExecute(r)
}

/*
EntryVendorTaskExportToCsv Method for EntryVendorTaskExportToCsv

add batch job that sends an email with a link to download an updated CSV that contains list of users

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryVendorTaskExportToCsvRequest
*/
func (a *EntryVendorTaskApiService) EntryVendorTaskExportToCsv(ctx context.Context) ApiEntryVendorTaskExportToCsvRequest {
	return ApiEntryVendorTaskExportToCsvRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *EntryVendorTaskApiService) EntryVendorTaskExportToCsvExecute(r ApiEntryVendorTaskExportToCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryVendorTaskApiService.EntryVendorTaskExportToCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/reach_entryvendortask/action/exportToCsv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEntryVendorTaskExtendAccessKeyRequest struct {
	ctx context.Context
	ApiService *EntryVendorTaskApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AccessControlDeleteRequest
}

func (r ApiEntryVendorTaskExtendAccessKeyRequest) Ks(ks string) ApiEntryVendorTaskExtendAccessKeyRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryVendorTaskExtendAccessKeyRequest) Format(format int32) ApiEntryVendorTaskExtendAccessKeyRequest {
	r.format = &format
	return r
}

func (r ApiEntryVendorTaskExtendAccessKeyRequest) ClientTag(clientTag string) ApiEntryVendorTaskExtendAccessKeyRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryVendorTaskExtendAccessKeyRequest) PartnerId(partnerId int32) ApiEntryVendorTaskExtendAccessKeyRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryVendorTaskExtendAccessKeyRequest) Body(body AccessControlDeleteRequest) ApiEntryVendorTaskExtendAccessKeyRequest {
	r.body = &body
	return r
}

func (r ApiEntryVendorTaskExtendAccessKeyRequest) Execute() (*KalturaEntryVendorTask, *http.Response, error) {
	return r.ApiService.EntryVendorTaskExtendAccessKeyExecute(r)
}

/*
EntryVendorTaskExtendAccessKey Method for EntryVendorTaskExtendAccessKey

Extend access key in case the existing one has expired.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryVendorTaskExtendAccessKeyRequest
*/
func (a *EntryVendorTaskApiService) EntryVendorTaskExtendAccessKey(ctx context.Context) ApiEntryVendorTaskExtendAccessKeyRequest {
	return ApiEntryVendorTaskExtendAccessKeyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEntryVendorTask
func (a *EntryVendorTaskApiService) EntryVendorTaskExtendAccessKeyExecute(r ApiEntryVendorTaskExtendAccessKeyRequest) (*KalturaEntryVendorTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEntryVendorTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryVendorTaskApiService.EntryVendorTaskExtendAccessKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/reach_entryvendortask/action/extendAccessKey"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEntryVendorTaskGetRequest struct {
	ctx context.Context
	ApiService *EntryVendorTaskApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AccessControlDeleteRequest
}

func (r ApiEntryVendorTaskGetRequest) Ks(ks string) ApiEntryVendorTaskGetRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryVendorTaskGetRequest) Format(format int32) ApiEntryVendorTaskGetRequest {
	r.format = &format
	return r
}

func (r ApiEntryVendorTaskGetRequest) ClientTag(clientTag string) ApiEntryVendorTaskGetRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryVendorTaskGetRequest) PartnerId(partnerId int32) ApiEntryVendorTaskGetRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryVendorTaskGetRequest) Body(body AccessControlDeleteRequest) ApiEntryVendorTaskGetRequest {
	r.body = &body
	return r
}

func (r ApiEntryVendorTaskGetRequest) Execute() (*KalturaEntryVendorTask, *http.Response, error) {
	return r.ApiService.EntryVendorTaskGetExecute(r)
}

/*
EntryVendorTaskGet Method for EntryVendorTaskGet

Retrieve specific entry vendor task by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryVendorTaskGetRequest
*/
func (a *EntryVendorTaskApiService) EntryVendorTaskGet(ctx context.Context) ApiEntryVendorTaskGetRequest {
	return ApiEntryVendorTaskGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEntryVendorTask
func (a *EntryVendorTaskApiService) EntryVendorTaskGetExecute(r ApiEntryVendorTaskGetRequest) (*KalturaEntryVendorTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEntryVendorTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryVendorTaskApiService.EntryVendorTaskGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/reach_entryvendortask/action/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEntryVendorTaskGetJobsRequest struct {
	ctx context.Context
	ApiService *EntryVendorTaskApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *EntryVendorTaskGetJobsRequest
}

func (r ApiEntryVendorTaskGetJobsRequest) Ks(ks string) ApiEntryVendorTaskGetJobsRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryVendorTaskGetJobsRequest) Format(format int32) ApiEntryVendorTaskGetJobsRequest {
	r.format = &format
	return r
}

func (r ApiEntryVendorTaskGetJobsRequest) ClientTag(clientTag string) ApiEntryVendorTaskGetJobsRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryVendorTaskGetJobsRequest) PartnerId(partnerId int32) ApiEntryVendorTaskGetJobsRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryVendorTaskGetJobsRequest) Body(body EntryVendorTaskGetJobsRequest) ApiEntryVendorTaskGetJobsRequest {
	r.body = &body
	return r
}

func (r ApiEntryVendorTaskGetJobsRequest) Execute() (*KalturaEntryVendorTaskListResponse, *http.Response, error) {
	return r.ApiService.EntryVendorTaskGetJobsExecute(r)
}

/*
EntryVendorTaskGetJobs Method for EntryVendorTaskGetJobs

get KalturaEntryVendorTask objects for specific vendor partner

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryVendorTaskGetJobsRequest
*/
func (a *EntryVendorTaskApiService) EntryVendorTaskGetJobs(ctx context.Context) ApiEntryVendorTaskGetJobsRequest {
	return ApiEntryVendorTaskGetJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEntryVendorTaskListResponse
func (a *EntryVendorTaskApiService) EntryVendorTaskGetJobsExecute(r ApiEntryVendorTaskGetJobsRequest) (*KalturaEntryVendorTaskListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEntryVendorTaskListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryVendorTaskApiService.EntryVendorTaskGetJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/reach_entryvendortask/action/getJobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEntryVendorTaskGetServeUrlRequest struct {
	ctx context.Context
	ApiService *EntryVendorTaskApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *EntryVendorTaskGetServeUrlRequest
}

func (r ApiEntryVendorTaskGetServeUrlRequest) Ks(ks string) ApiEntryVendorTaskGetServeUrlRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryVendorTaskGetServeUrlRequest) Format(format int32) ApiEntryVendorTaskGetServeUrlRequest {
	r.format = &format
	return r
}

func (r ApiEntryVendorTaskGetServeUrlRequest) ClientTag(clientTag string) ApiEntryVendorTaskGetServeUrlRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryVendorTaskGetServeUrlRequest) PartnerId(partnerId int32) ApiEntryVendorTaskGetServeUrlRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryVendorTaskGetServeUrlRequest) Body(body EntryVendorTaskGetServeUrlRequest) ApiEntryVendorTaskGetServeUrlRequest {
	r.body = &body
	return r
}

func (r ApiEntryVendorTaskGetServeUrlRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.EntryVendorTaskGetServeUrlExecute(r)
}

/*
EntryVendorTaskGetServeUrl Method for EntryVendorTaskGetServeUrl

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryVendorTaskGetServeUrlRequest
*/
func (a *EntryVendorTaskApiService) EntryVendorTaskGetServeUrl(ctx context.Context) ApiEntryVendorTaskGetServeUrlRequest {
	return ApiEntryVendorTaskGetServeUrlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *EntryVendorTaskApiService) EntryVendorTaskGetServeUrlExecute(r ApiEntryVendorTaskGetServeUrlRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryVendorTaskApiService.EntryVendorTaskGetServeUrl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/reach_entryvendortask/action/getServeUrl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEntryVendorTaskListRequest struct {
	ctx context.Context
	ApiService *EntryVendorTaskApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *EntryVendorTaskGetJobsRequest
}

func (r ApiEntryVendorTaskListRequest) Ks(ks string) ApiEntryVendorTaskListRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryVendorTaskListRequest) Format(format int32) ApiEntryVendorTaskListRequest {
	r.format = &format
	return r
}

func (r ApiEntryVendorTaskListRequest) ClientTag(clientTag string) ApiEntryVendorTaskListRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryVendorTaskListRequest) PartnerId(partnerId int32) ApiEntryVendorTaskListRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryVendorTaskListRequest) Body(body EntryVendorTaskGetJobsRequest) ApiEntryVendorTaskListRequest {
	r.body = &body
	return r
}

func (r ApiEntryVendorTaskListRequest) Execute() (*KalturaEntryVendorTaskListResponse, *http.Response, error) {
	return r.ApiService.EntryVendorTaskListExecute(r)
}

/*
EntryVendorTaskList Method for EntryVendorTaskList

List KalturaEntryVendorTask objects

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryVendorTaskListRequest
*/
func (a *EntryVendorTaskApiService) EntryVendorTaskList(ctx context.Context) ApiEntryVendorTaskListRequest {
	return ApiEntryVendorTaskListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEntryVendorTaskListResponse
func (a *EntryVendorTaskApiService) EntryVendorTaskListExecute(r ApiEntryVendorTaskListRequest) (*KalturaEntryVendorTaskListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEntryVendorTaskListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryVendorTaskApiService.EntryVendorTaskList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/reach_entryvendortask/action/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEntryVendorTaskRejectRequest struct {
	ctx context.Context
	ApiService *EntryVendorTaskApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *EntryVendorTaskRejectRequest
}

func (r ApiEntryVendorTaskRejectRequest) Ks(ks string) ApiEntryVendorTaskRejectRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryVendorTaskRejectRequest) Format(format int32) ApiEntryVendorTaskRejectRequest {
	r.format = &format
	return r
}

func (r ApiEntryVendorTaskRejectRequest) ClientTag(clientTag string) ApiEntryVendorTaskRejectRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryVendorTaskRejectRequest) PartnerId(partnerId int32) ApiEntryVendorTaskRejectRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryVendorTaskRejectRequest) Body(body EntryVendorTaskRejectRequest) ApiEntryVendorTaskRejectRequest {
	r.body = &body
	return r
}

func (r ApiEntryVendorTaskRejectRequest) Execute() (*KalturaEntryVendorTask, *http.Response, error) {
	return r.ApiService.EntryVendorTaskRejectExecute(r)
}

/*
EntryVendorTaskReject Method for EntryVendorTaskReject

Reject entry vendor task for execution.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryVendorTaskRejectRequest
*/
func (a *EntryVendorTaskApiService) EntryVendorTaskReject(ctx context.Context) ApiEntryVendorTaskRejectRequest {
	return ApiEntryVendorTaskRejectRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEntryVendorTask
func (a *EntryVendorTaskApiService) EntryVendorTaskRejectExecute(r ApiEntryVendorTaskRejectRequest) (*KalturaEntryVendorTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEntryVendorTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryVendorTaskApiService.EntryVendorTaskReject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/reach_entryvendortask/action/reject"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEntryVendorTaskServeRequest struct {
	ctx context.Context
	ApiService *EntryVendorTaskApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *EntryVendorTaskServeRequest
}

func (r ApiEntryVendorTaskServeRequest) Ks(ks string) ApiEntryVendorTaskServeRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryVendorTaskServeRequest) Format(format int32) ApiEntryVendorTaskServeRequest {
	r.format = &format
	return r
}

func (r ApiEntryVendorTaskServeRequest) ClientTag(clientTag string) ApiEntryVendorTaskServeRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryVendorTaskServeRequest) PartnerId(partnerId int32) ApiEntryVendorTaskServeRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryVendorTaskServeRequest) Body(body EntryVendorTaskServeRequest) ApiEntryVendorTaskServeRequest {
	r.body = &body
	return r
}

func (r ApiEntryVendorTaskServeRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.EntryVendorTaskServeExecute(r)
}

/*
EntryVendorTaskServe Method for EntryVendorTaskServe

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryVendorTaskServeRequest
*/
func (a *EntryVendorTaskApiService) EntryVendorTaskServe(ctx context.Context) ApiEntryVendorTaskServeRequest {
	return ApiEntryVendorTaskServeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *EntryVendorTaskApiService) EntryVendorTaskServeExecute(r ApiEntryVendorTaskServeRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryVendorTaskApiService.EntryVendorTaskServe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/reach_entryvendortask/action/serve"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEntryVendorTaskServeCsvRequest struct {
	ctx context.Context
	ApiService *EntryVendorTaskApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AnnotationDeleteRequest
}

func (r ApiEntryVendorTaskServeCsvRequest) Ks(ks string) ApiEntryVendorTaskServeCsvRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryVendorTaskServeCsvRequest) Format(format int32) ApiEntryVendorTaskServeCsvRequest {
	r.format = &format
	return r
}

func (r ApiEntryVendorTaskServeCsvRequest) ClientTag(clientTag string) ApiEntryVendorTaskServeCsvRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryVendorTaskServeCsvRequest) PartnerId(partnerId int32) ApiEntryVendorTaskServeCsvRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryVendorTaskServeCsvRequest) Body(body AnnotationDeleteRequest) ApiEntryVendorTaskServeCsvRequest {
	r.body = &body
	return r
}

func (r ApiEntryVendorTaskServeCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.EntryVendorTaskServeCsvExecute(r)
}

/*
EntryVendorTaskServeCsv Method for EntryVendorTaskServeCsv

Will serve a requested csv

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryVendorTaskServeCsvRequest

Deprecated
*/
func (a *EntryVendorTaskApiService) EntryVendorTaskServeCsv(ctx context.Context) ApiEntryVendorTaskServeCsvRequest {
	return ApiEntryVendorTaskServeCsvRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
// Deprecated
func (a *EntryVendorTaskApiService) EntryVendorTaskServeCsvExecute(r ApiEntryVendorTaskServeCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryVendorTaskApiService.EntryVendorTaskServeCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/reach_entryvendortask/action/serveCsv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEntryVendorTaskUpdateRequest struct {
	ctx context.Context
	ApiService *EntryVendorTaskApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *EntryVendorTaskUpdateRequest
}

func (r ApiEntryVendorTaskUpdateRequest) Ks(ks string) ApiEntryVendorTaskUpdateRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryVendorTaskUpdateRequest) Format(format int32) ApiEntryVendorTaskUpdateRequest {
	r.format = &format
	return r
}

func (r ApiEntryVendorTaskUpdateRequest) ClientTag(clientTag string) ApiEntryVendorTaskUpdateRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryVendorTaskUpdateRequest) PartnerId(partnerId int32) ApiEntryVendorTaskUpdateRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryVendorTaskUpdateRequest) Body(body EntryVendorTaskUpdateRequest) ApiEntryVendorTaskUpdateRequest {
	r.body = &body
	return r
}

func (r ApiEntryVendorTaskUpdateRequest) Execute() (*KalturaEntryVendorTask, *http.Response, error) {
	return r.ApiService.EntryVendorTaskUpdateExecute(r)
}

/*
EntryVendorTaskUpdate Method for EntryVendorTaskUpdate

Update entry vendor task. Only the properties that were set will be updated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryVendorTaskUpdateRequest
*/
func (a *EntryVendorTaskApiService) EntryVendorTaskUpdate(ctx context.Context) ApiEntryVendorTaskUpdateRequest {
	return ApiEntryVendorTaskUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEntryVendorTask
func (a *EntryVendorTaskApiService) EntryVendorTaskUpdateExecute(r ApiEntryVendorTaskUpdateRequest) (*KalturaEntryVendorTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEntryVendorTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryVendorTaskApiService.EntryVendorTaskUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/reach_entryvendortask/action/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEntryVendorTaskUpdateJobRequest struct {
	ctx context.Context
	ApiService *EntryVendorTaskApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *EntryVendorTaskUpdateRequest
}

func (r ApiEntryVendorTaskUpdateJobRequest) Ks(ks string) ApiEntryVendorTaskUpdateJobRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryVendorTaskUpdateJobRequest) Format(format int32) ApiEntryVendorTaskUpdateJobRequest {
	r.format = &format
	return r
}

func (r ApiEntryVendorTaskUpdateJobRequest) ClientTag(clientTag string) ApiEntryVendorTaskUpdateJobRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryVendorTaskUpdateJobRequest) PartnerId(partnerId int32) ApiEntryVendorTaskUpdateJobRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryVendorTaskUpdateJobRequest) Body(body EntryVendorTaskUpdateRequest) ApiEntryVendorTaskUpdateJobRequest {
	r.body = &body
	return r
}

func (r ApiEntryVendorTaskUpdateJobRequest) Execute() (*KalturaEntryVendorTask, *http.Response, error) {
	return r.ApiService.EntryVendorTaskUpdateJobExecute(r)
}

/*
EntryVendorTaskUpdateJob Method for EntryVendorTaskUpdateJob

Update entry vendor task. Only the properties that were set will be updated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryVendorTaskUpdateJobRequest
*/
func (a *EntryVendorTaskApiService) EntryVendorTaskUpdateJob(ctx context.Context) ApiEntryVendorTaskUpdateJobRequest {
	return ApiEntryVendorTaskUpdateJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEntryVendorTask
func (a *EntryVendorTaskApiService) EntryVendorTaskUpdateJobExecute(r ApiEntryVendorTaskUpdateJobRequest) (*KalturaEntryVendorTask, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEntryVendorTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryVendorTaskApiService.EntryVendorTaskUpdateJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/reach_entryvendortask/action/updateJob"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
