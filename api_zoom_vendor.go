/*
Kaltura VPaaS

The Kaltura VPaaS API

API version: 18.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// ZoomVendorApiService ZoomVendorApi service
type ZoomVendorApiService service

type ApiZoomVendorDeAuthorizationRequest struct {
	ctx context.Context
	ApiService *ZoomVendorApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	batchCleanExclusiveJobsRequest *BatchCleanExclusiveJobsRequest
}

func (r ApiZoomVendorDeAuthorizationRequest) Ks(ks string) ApiZoomVendorDeAuthorizationRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiZoomVendorDeAuthorizationRequest) Format(format int32) ApiZoomVendorDeAuthorizationRequest {
	r.format = &format
	return r
}

func (r ApiZoomVendorDeAuthorizationRequest) ClientTag(clientTag string) ApiZoomVendorDeAuthorizationRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiZoomVendorDeAuthorizationRequest) PartnerId(partnerId int32) ApiZoomVendorDeAuthorizationRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiZoomVendorDeAuthorizationRequest) BatchCleanExclusiveJobsRequest(batchCleanExclusiveJobsRequest BatchCleanExclusiveJobsRequest) ApiZoomVendorDeAuthorizationRequest {
	r.batchCleanExclusiveJobsRequest = &batchCleanExclusiveJobsRequest
	return r
}

func (r ApiZoomVendorDeAuthorizationRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ZoomVendorDeAuthorizationExecute(r)
}

/*
ZoomVendorDeAuthorization Method for ZoomVendorDeAuthorization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiZoomVendorDeAuthorizationRequest
*/
func (a *ZoomVendorApiService) ZoomVendorDeAuthorization(ctx context.Context) ApiZoomVendorDeAuthorizationRequest {
	return ApiZoomVendorDeAuthorizationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *ZoomVendorApiService) ZoomVendorDeAuthorizationExecute(r ApiZoomVendorDeAuthorizationRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ZoomVendorApiService.ZoomVendorDeAuthorization")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/vendor_zoomvendor/action/deAuthorization"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchCleanExclusiveJobsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiZoomVendorFetchRegistrationPageRequest struct {
	ctx context.Context
	ApiService *ZoomVendorApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *ZoomVendorFetchRegistrationPageRequest
}

func (r ApiZoomVendorFetchRegistrationPageRequest) Ks(ks string) ApiZoomVendorFetchRegistrationPageRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiZoomVendorFetchRegistrationPageRequest) Format(format int32) ApiZoomVendorFetchRegistrationPageRequest {
	r.format = &format
	return r
}

func (r ApiZoomVendorFetchRegistrationPageRequest) ClientTag(clientTag string) ApiZoomVendorFetchRegistrationPageRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiZoomVendorFetchRegistrationPageRequest) PartnerId(partnerId int32) ApiZoomVendorFetchRegistrationPageRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiZoomVendorFetchRegistrationPageRequest) Body(body ZoomVendorFetchRegistrationPageRequest) ApiZoomVendorFetchRegistrationPageRequest {
	r.body = &body
	return r
}

func (r ApiZoomVendorFetchRegistrationPageRequest) Execute() (*http.Response, error) {
	return r.ApiService.ZoomVendorFetchRegistrationPageExecute(r)
}

/*
ZoomVendorFetchRegistrationPage Method for ZoomVendorFetchRegistrationPage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiZoomVendorFetchRegistrationPageRequest
*/
func (a *ZoomVendorApiService) ZoomVendorFetchRegistrationPage(ctx context.Context) ApiZoomVendorFetchRegistrationPageRequest {
	return ApiZoomVendorFetchRegistrationPageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ZoomVendorApiService) ZoomVendorFetchRegistrationPageExecute(r ApiZoomVendorFetchRegistrationPageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ZoomVendorApiService.ZoomVendorFetchRegistrationPage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/vendor_zoomvendor/action/fetchRegistrationPage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiZoomVendorGetRequest struct {
	ctx context.Context
	ApiService *ZoomVendorApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *ZoomVendorGetRequest
}

func (r ApiZoomVendorGetRequest) Ks(ks string) ApiZoomVendorGetRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiZoomVendorGetRequest) Format(format int32) ApiZoomVendorGetRequest {
	r.format = &format
	return r
}

func (r ApiZoomVendorGetRequest) ClientTag(clientTag string) ApiZoomVendorGetRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiZoomVendorGetRequest) PartnerId(partnerId int32) ApiZoomVendorGetRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiZoomVendorGetRequest) Body(body ZoomVendorGetRequest) ApiZoomVendorGetRequest {
	r.body = &body
	return r
}

func (r ApiZoomVendorGetRequest) Execute() (*KalturaZoomIntegrationSetting, *http.Response, error) {
	return r.ApiService.ZoomVendorGetExecute(r)
}

/*
ZoomVendorGet Method for ZoomVendorGet

Retrieve zoom integration setting object by partner id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiZoomVendorGetRequest
*/
func (a *ZoomVendorApiService) ZoomVendorGet(ctx context.Context) ApiZoomVendorGetRequest {
	return ApiZoomVendorGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaZoomIntegrationSetting
func (a *ZoomVendorApiService) ZoomVendorGetExecute(r ApiZoomVendorGetRequest) (*KalturaZoomIntegrationSetting, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaZoomIntegrationSetting
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ZoomVendorApiService.ZoomVendorGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/vendor_zoomvendor/action/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiZoomVendorListRequest struct {
	ctx context.Context
	ApiService *ZoomVendorApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BulkUploadListRequest
}

func (r ApiZoomVendorListRequest) Ks(ks string) ApiZoomVendorListRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiZoomVendorListRequest) Format(format int32) ApiZoomVendorListRequest {
	r.format = &format
	return r
}

func (r ApiZoomVendorListRequest) ClientTag(clientTag string) ApiZoomVendorListRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiZoomVendorListRequest) PartnerId(partnerId int32) ApiZoomVendorListRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiZoomVendorListRequest) Body(body BulkUploadListRequest) ApiZoomVendorListRequest {
	r.body = &body
	return r
}

func (r ApiZoomVendorListRequest) Execute() (*KalturaZoomIntegrationSettingResponse, *http.Response, error) {
	return r.ApiService.ZoomVendorListExecute(r)
}

/*
ZoomVendorList Method for ZoomVendorList

List KalturaZoomIntegrationSetting objects

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiZoomVendorListRequest
*/
func (a *ZoomVendorApiService) ZoomVendorList(ctx context.Context) ApiZoomVendorListRequest {
	return ApiZoomVendorListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaZoomIntegrationSettingResponse
func (a *ZoomVendorApiService) ZoomVendorListExecute(r ApiZoomVendorListRequest) (*KalturaZoomIntegrationSettingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaZoomIntegrationSettingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ZoomVendorApiService.ZoomVendorList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/vendor_zoomvendor/action/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiZoomVendorLocalRegistrationPageRequest struct {
	ctx context.Context
	ApiService *ZoomVendorApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *ZoomVendorLocalRegistrationPageRequest
}

func (r ApiZoomVendorLocalRegistrationPageRequest) Ks(ks string) ApiZoomVendorLocalRegistrationPageRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiZoomVendorLocalRegistrationPageRequest) Format(format int32) ApiZoomVendorLocalRegistrationPageRequest {
	r.format = &format
	return r
}

func (r ApiZoomVendorLocalRegistrationPageRequest) ClientTag(clientTag string) ApiZoomVendorLocalRegistrationPageRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiZoomVendorLocalRegistrationPageRequest) PartnerId(partnerId int32) ApiZoomVendorLocalRegistrationPageRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiZoomVendorLocalRegistrationPageRequest) Body(body ZoomVendorLocalRegistrationPageRequest) ApiZoomVendorLocalRegistrationPageRequest {
	r.body = &body
	return r
}

func (r ApiZoomVendorLocalRegistrationPageRequest) Execute() (*http.Response, error) {
	return r.ApiService.ZoomVendorLocalRegistrationPageExecute(r)
}

/*
ZoomVendorLocalRegistrationPage Method for ZoomVendorLocalRegistrationPage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiZoomVendorLocalRegistrationPageRequest
*/
func (a *ZoomVendorApiService) ZoomVendorLocalRegistrationPage(ctx context.Context) ApiZoomVendorLocalRegistrationPageRequest {
	return ApiZoomVendorLocalRegistrationPageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ZoomVendorApiService) ZoomVendorLocalRegistrationPageExecute(r ApiZoomVendorLocalRegistrationPageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ZoomVendorApiService.ZoomVendorLocalRegistrationPage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/vendor_zoomvendor/action/localRegistrationPage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiZoomVendorOauthValidationRequest struct {
	ctx context.Context
	ApiService *ZoomVendorApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	batchCleanExclusiveJobsRequest *BatchCleanExclusiveJobsRequest
}

func (r ApiZoomVendorOauthValidationRequest) Ks(ks string) ApiZoomVendorOauthValidationRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiZoomVendorOauthValidationRequest) Format(format int32) ApiZoomVendorOauthValidationRequest {
	r.format = &format
	return r
}

func (r ApiZoomVendorOauthValidationRequest) ClientTag(clientTag string) ApiZoomVendorOauthValidationRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiZoomVendorOauthValidationRequest) PartnerId(partnerId int32) ApiZoomVendorOauthValidationRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiZoomVendorOauthValidationRequest) BatchCleanExclusiveJobsRequest(batchCleanExclusiveJobsRequest BatchCleanExclusiveJobsRequest) ApiZoomVendorOauthValidationRequest {
	r.batchCleanExclusiveJobsRequest = &batchCleanExclusiveJobsRequest
	return r
}

func (r ApiZoomVendorOauthValidationRequest) Execute() (*http.Response, error) {
	return r.ApiService.ZoomVendorOauthValidationExecute(r)
}

/*
ZoomVendorOauthValidation Method for ZoomVendorOauthValidation

load html page the that will ask the user for its KMC URL, derive the region of the user from it,

and redirect to the registration page in the correct region, while forwarding the necessary code for registration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiZoomVendorOauthValidationRequest
*/
func (a *ZoomVendorApiService) ZoomVendorOauthValidation(ctx context.Context) ApiZoomVendorOauthValidationRequest {
	return ApiZoomVendorOauthValidationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ZoomVendorApiService) ZoomVendorOauthValidationExecute(r ApiZoomVendorOauthValidationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ZoomVendorApiService.ZoomVendorOauthValidation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/vendor_zoomvendor/action/oauthValidation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchCleanExclusiveJobsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiZoomVendorPreOauthValidationRequest struct {
	ctx context.Context
	ApiService *ZoomVendorApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	batchCleanExclusiveJobsRequest *BatchCleanExclusiveJobsRequest
}

func (r ApiZoomVendorPreOauthValidationRequest) Ks(ks string) ApiZoomVendorPreOauthValidationRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiZoomVendorPreOauthValidationRequest) Format(format int32) ApiZoomVendorPreOauthValidationRequest {
	r.format = &format
	return r
}

func (r ApiZoomVendorPreOauthValidationRequest) ClientTag(clientTag string) ApiZoomVendorPreOauthValidationRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiZoomVendorPreOauthValidationRequest) PartnerId(partnerId int32) ApiZoomVendorPreOauthValidationRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiZoomVendorPreOauthValidationRequest) BatchCleanExclusiveJobsRequest(batchCleanExclusiveJobsRequest BatchCleanExclusiveJobsRequest) ApiZoomVendorPreOauthValidationRequest {
	r.batchCleanExclusiveJobsRequest = &batchCleanExclusiveJobsRequest
	return r
}

func (r ApiZoomVendorPreOauthValidationRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ZoomVendorPreOauthValidationExecute(r)
}

/*
ZoomVendorPreOauthValidation Method for ZoomVendorPreOauthValidation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiZoomVendorPreOauthValidationRequest
*/
func (a *ZoomVendorApiService) ZoomVendorPreOauthValidation(ctx context.Context) ApiZoomVendorPreOauthValidationRequest {
	return ApiZoomVendorPreOauthValidationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *ZoomVendorApiService) ZoomVendorPreOauthValidationExecute(r ApiZoomVendorPreOauthValidationRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ZoomVendorApiService.ZoomVendorPreOauthValidation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/vendor_zoomvendor/action/preOauthValidation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchCleanExclusiveJobsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiZoomVendorRecordingCompleteRequest struct {
	ctx context.Context
	ApiService *ZoomVendorApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	batchCleanExclusiveJobsRequest *BatchCleanExclusiveJobsRequest
}

func (r ApiZoomVendorRecordingCompleteRequest) Ks(ks string) ApiZoomVendorRecordingCompleteRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiZoomVendorRecordingCompleteRequest) Format(format int32) ApiZoomVendorRecordingCompleteRequest {
	r.format = &format
	return r
}

func (r ApiZoomVendorRecordingCompleteRequest) ClientTag(clientTag string) ApiZoomVendorRecordingCompleteRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiZoomVendorRecordingCompleteRequest) PartnerId(partnerId int32) ApiZoomVendorRecordingCompleteRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiZoomVendorRecordingCompleteRequest) BatchCleanExclusiveJobsRequest(batchCleanExclusiveJobsRequest BatchCleanExclusiveJobsRequest) ApiZoomVendorRecordingCompleteRequest {
	r.batchCleanExclusiveJobsRequest = &batchCleanExclusiveJobsRequest
	return r
}

func (r ApiZoomVendorRecordingCompleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ZoomVendorRecordingCompleteExecute(r)
}

/*
ZoomVendorRecordingComplete Method for ZoomVendorRecordingComplete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiZoomVendorRecordingCompleteRequest
*/
func (a *ZoomVendorApiService) ZoomVendorRecordingComplete(ctx context.Context) ApiZoomVendorRecordingCompleteRequest {
	return ApiZoomVendorRecordingCompleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ZoomVendorApiService) ZoomVendorRecordingCompleteExecute(r ApiZoomVendorRecordingCompleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ZoomVendorApiService.ZoomVendorRecordingComplete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/vendor_zoomvendor/action/recordingComplete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchCleanExclusiveJobsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiZoomVendorSubmitRegistrationRequest struct {
	ctx context.Context
	ApiService *ZoomVendorApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *ZoomVendorSubmitRegistrationRequest
}

func (r ApiZoomVendorSubmitRegistrationRequest) Ks(ks string) ApiZoomVendorSubmitRegistrationRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiZoomVendorSubmitRegistrationRequest) Format(format int32) ApiZoomVendorSubmitRegistrationRequest {
	r.format = &format
	return r
}

func (r ApiZoomVendorSubmitRegistrationRequest) ClientTag(clientTag string) ApiZoomVendorSubmitRegistrationRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiZoomVendorSubmitRegistrationRequest) PartnerId(partnerId int32) ApiZoomVendorSubmitRegistrationRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiZoomVendorSubmitRegistrationRequest) Body(body ZoomVendorSubmitRegistrationRequest) ApiZoomVendorSubmitRegistrationRequest {
	r.body = &body
	return r
}

func (r ApiZoomVendorSubmitRegistrationRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ZoomVendorSubmitRegistrationExecute(r)
}

/*
ZoomVendorSubmitRegistration Method for ZoomVendorSubmitRegistration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiZoomVendorSubmitRegistrationRequest
*/
func (a *ZoomVendorApiService) ZoomVendorSubmitRegistration(ctx context.Context) ApiZoomVendorSubmitRegistrationRequest {
	return ApiZoomVendorSubmitRegistrationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *ZoomVendorApiService) ZoomVendorSubmitRegistrationExecute(r ApiZoomVendorSubmitRegistrationRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ZoomVendorApiService.ZoomVendorSubmitRegistration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/vendor_zoomvendor/action/submitRegistration"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
