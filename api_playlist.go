/*
Kaltura VPaaS

The Kaltura VPaaS API

API version: 18.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// PlaylistApiService PlaylistApi service
type PlaylistApiService service

type ApiPlaylistAddRequest struct {
	ctx context.Context
	ApiService *PlaylistApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *PlaylistAddRequest
}

func (r ApiPlaylistAddRequest) Ks(ks string) ApiPlaylistAddRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiPlaylistAddRequest) Format(format int32) ApiPlaylistAddRequest {
	r.format = &format
	return r
}

func (r ApiPlaylistAddRequest) ClientTag(clientTag string) ApiPlaylistAddRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiPlaylistAddRequest) PartnerId(partnerId int32) ApiPlaylistAddRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiPlaylistAddRequest) Body(body PlaylistAddRequest) ApiPlaylistAddRequest {
	r.body = &body
	return r
}

func (r ApiPlaylistAddRequest) Execute() (*KalturaPlaylist, *http.Response, error) {
	return r.ApiService.PlaylistAddExecute(r)
}

/*
PlaylistAdd Method for PlaylistAdd

Add new playlist

Note that all entries used in a playlist will become public and may appear in KalturaNetwork

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPlaylistAddRequest
*/
func (a *PlaylistApiService) PlaylistAdd(ctx context.Context) ApiPlaylistAddRequest {
	return ApiPlaylistAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaPlaylist
func (a *PlaylistApiService) PlaylistAddExecute(r ApiPlaylistAddRequest) (*KalturaPlaylist, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaPlaylist
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaylistApiService.PlaylistAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/playlist/action/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlaylistCloneRequest struct {
	ctx context.Context
	ApiService *PlaylistApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *PlaylistCloneRequest
}

func (r ApiPlaylistCloneRequest) Ks(ks string) ApiPlaylistCloneRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiPlaylistCloneRequest) Format(format int32) ApiPlaylistCloneRequest {
	r.format = &format
	return r
}

func (r ApiPlaylistCloneRequest) ClientTag(clientTag string) ApiPlaylistCloneRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiPlaylistCloneRequest) PartnerId(partnerId int32) ApiPlaylistCloneRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiPlaylistCloneRequest) Body(body PlaylistCloneRequest) ApiPlaylistCloneRequest {
	r.body = &body
	return r
}

func (r ApiPlaylistCloneRequest) Execute() (*KalturaPlaylist, *http.Response, error) {
	return r.ApiService.PlaylistCloneExecute(r)
}

/*
PlaylistClone Method for PlaylistClone

Clone an existing playlist

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPlaylistCloneRequest
*/
func (a *PlaylistApiService) PlaylistClone(ctx context.Context) ApiPlaylistCloneRequest {
	return ApiPlaylistCloneRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaPlaylist
func (a *PlaylistApiService) PlaylistCloneExecute(r ApiPlaylistCloneRequest) (*KalturaPlaylist, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaPlaylist
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaylistApiService.PlaylistClone")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/playlist/action/clone"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlaylistDeleteRequest struct {
	ctx context.Context
	ApiService *PlaylistApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AnnotationDeleteRequest
}

func (r ApiPlaylistDeleteRequest) Ks(ks string) ApiPlaylistDeleteRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiPlaylistDeleteRequest) Format(format int32) ApiPlaylistDeleteRequest {
	r.format = &format
	return r
}

func (r ApiPlaylistDeleteRequest) ClientTag(clientTag string) ApiPlaylistDeleteRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiPlaylistDeleteRequest) PartnerId(partnerId int32) ApiPlaylistDeleteRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiPlaylistDeleteRequest) Body(body AnnotationDeleteRequest) ApiPlaylistDeleteRequest {
	r.body = &body
	return r
}

func (r ApiPlaylistDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.PlaylistDeleteExecute(r)
}

/*
PlaylistDelete Method for PlaylistDelete

Delete existing playlist

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPlaylistDeleteRequest
*/
func (a *PlaylistApiService) PlaylistDelete(ctx context.Context) ApiPlaylistDeleteRequest {
	return ApiPlaylistDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PlaylistApiService) PlaylistDeleteExecute(r ApiPlaylistDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaylistApiService.PlaylistDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/playlist/action/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPlaylistExecuteRequest struct {
	ctx context.Context
	ApiService *PlaylistApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *PlaylistExecuteRequest
}

func (r ApiPlaylistExecuteRequest) Ks(ks string) ApiPlaylistExecuteRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiPlaylistExecuteRequest) Format(format int32) ApiPlaylistExecuteRequest {
	r.format = &format
	return r
}

func (r ApiPlaylistExecuteRequest) ClientTag(clientTag string) ApiPlaylistExecuteRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiPlaylistExecuteRequest) PartnerId(partnerId int32) ApiPlaylistExecuteRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiPlaylistExecuteRequest) Body(body PlaylistExecuteRequest) ApiPlaylistExecuteRequest {
	r.body = &body
	return r
}

func (r ApiPlaylistExecuteRequest) Execute() ([]KalturaBaseEntry, *http.Response, error) {
	return r.ApiService.PlaylistExecuteExecute(r)
}

/*
PlaylistExecute Method for PlaylistExecute

Retrieve playlist for playing purpose

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPlaylistExecuteRequest
*/
func (a *PlaylistApiService) PlaylistExecute(ctx context.Context) ApiPlaylistExecuteRequest {
	return ApiPlaylistExecuteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []KalturaBaseEntry
func (a *PlaylistApiService) PlaylistExecuteExecute(r ApiPlaylistExecuteRequest) ([]KalturaBaseEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KalturaBaseEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaylistApiService.PlaylistExecute")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/playlist/action/execute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlaylistExecuteFromContentRequest struct {
	ctx context.Context
	ApiService *PlaylistApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *PlaylistExecuteFromContentRequest
}

func (r ApiPlaylistExecuteFromContentRequest) Ks(ks string) ApiPlaylistExecuteFromContentRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiPlaylistExecuteFromContentRequest) Format(format int32) ApiPlaylistExecuteFromContentRequest {
	r.format = &format
	return r
}

func (r ApiPlaylistExecuteFromContentRequest) ClientTag(clientTag string) ApiPlaylistExecuteFromContentRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiPlaylistExecuteFromContentRequest) PartnerId(partnerId int32) ApiPlaylistExecuteFromContentRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiPlaylistExecuteFromContentRequest) Body(body PlaylistExecuteFromContentRequest) ApiPlaylistExecuteFromContentRequest {
	r.body = &body
	return r
}

func (r ApiPlaylistExecuteFromContentRequest) Execute() ([]KalturaBaseEntry, *http.Response, error) {
	return r.ApiService.PlaylistExecuteFromContentExecute(r)
}

/*
PlaylistExecuteFromContent Method for PlaylistExecuteFromContent

Retrieve playlist for playing purpose, based on content

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPlaylistExecuteFromContentRequest
*/
func (a *PlaylistApiService) PlaylistExecuteFromContent(ctx context.Context) ApiPlaylistExecuteFromContentRequest {
	return ApiPlaylistExecuteFromContentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []KalturaBaseEntry
func (a *PlaylistApiService) PlaylistExecuteFromContentExecute(r ApiPlaylistExecuteFromContentRequest) ([]KalturaBaseEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KalturaBaseEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaylistApiService.PlaylistExecuteFromContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/playlist/action/executeFromContent"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlaylistExecuteFromFiltersRequest struct {
	ctx context.Context
	ApiService *PlaylistApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *PlaylistExecuteFromFiltersRequest
}

func (r ApiPlaylistExecuteFromFiltersRequest) Ks(ks string) ApiPlaylistExecuteFromFiltersRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiPlaylistExecuteFromFiltersRequest) Format(format int32) ApiPlaylistExecuteFromFiltersRequest {
	r.format = &format
	return r
}

func (r ApiPlaylistExecuteFromFiltersRequest) ClientTag(clientTag string) ApiPlaylistExecuteFromFiltersRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiPlaylistExecuteFromFiltersRequest) PartnerId(partnerId int32) ApiPlaylistExecuteFromFiltersRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiPlaylistExecuteFromFiltersRequest) Body(body PlaylistExecuteFromFiltersRequest) ApiPlaylistExecuteFromFiltersRequest {
	r.body = &body
	return r
}

func (r ApiPlaylistExecuteFromFiltersRequest) Execute() ([]KalturaBaseEntry, *http.Response, error) {
	return r.ApiService.PlaylistExecuteFromFiltersExecute(r)
}

/*
PlaylistExecuteFromFilters Method for PlaylistExecuteFromFilters

Retrieve playlist for playing purpose, based on media entry filters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPlaylistExecuteFromFiltersRequest
*/
func (a *PlaylistApiService) PlaylistExecuteFromFilters(ctx context.Context) ApiPlaylistExecuteFromFiltersRequest {
	return ApiPlaylistExecuteFromFiltersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []KalturaBaseEntry
func (a *PlaylistApiService) PlaylistExecuteFromFiltersExecute(r ApiPlaylistExecuteFromFiltersRequest) ([]KalturaBaseEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KalturaBaseEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaylistApiService.PlaylistExecuteFromFilters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/playlist/action/executeFromFilters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlaylistGetRequest struct {
	ctx context.Context
	ApiService *PlaylistApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *PlaylistGetRequest
}

func (r ApiPlaylistGetRequest) Ks(ks string) ApiPlaylistGetRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiPlaylistGetRequest) Format(format int32) ApiPlaylistGetRequest {
	r.format = &format
	return r
}

func (r ApiPlaylistGetRequest) ClientTag(clientTag string) ApiPlaylistGetRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiPlaylistGetRequest) PartnerId(partnerId int32) ApiPlaylistGetRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiPlaylistGetRequest) Body(body PlaylistGetRequest) ApiPlaylistGetRequest {
	r.body = &body
	return r
}

func (r ApiPlaylistGetRequest) Execute() (*KalturaPlaylist, *http.Response, error) {
	return r.ApiService.PlaylistGetExecute(r)
}

/*
PlaylistGet Method for PlaylistGet

Retrieve a playlist

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPlaylistGetRequest
*/
func (a *PlaylistApiService) PlaylistGet(ctx context.Context) ApiPlaylistGetRequest {
	return ApiPlaylistGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaPlaylist
func (a *PlaylistApiService) PlaylistGetExecute(r ApiPlaylistGetRequest) (*KalturaPlaylist, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaPlaylist
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaylistApiService.PlaylistGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/playlist/action/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlaylistGetStatsFromContentRequest struct {
	ctx context.Context
	ApiService *PlaylistApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *PlaylistGetStatsFromContentRequest
}

func (r ApiPlaylistGetStatsFromContentRequest) Ks(ks string) ApiPlaylistGetStatsFromContentRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiPlaylistGetStatsFromContentRequest) Format(format int32) ApiPlaylistGetStatsFromContentRequest {
	r.format = &format
	return r
}

func (r ApiPlaylistGetStatsFromContentRequest) ClientTag(clientTag string) ApiPlaylistGetStatsFromContentRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiPlaylistGetStatsFromContentRequest) PartnerId(partnerId int32) ApiPlaylistGetStatsFromContentRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiPlaylistGetStatsFromContentRequest) Body(body PlaylistGetStatsFromContentRequest) ApiPlaylistGetStatsFromContentRequest {
	r.body = &body
	return r
}

func (r ApiPlaylistGetStatsFromContentRequest) Execute() (*KalturaPlaylist, *http.Response, error) {
	return r.ApiService.PlaylistGetStatsFromContentExecute(r)
}

/*
PlaylistGetStatsFromContent Method for PlaylistGetStatsFromContent

Retrieve playlist statistics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPlaylistGetStatsFromContentRequest

Deprecated
*/
func (a *PlaylistApiService) PlaylistGetStatsFromContent(ctx context.Context) ApiPlaylistGetStatsFromContentRequest {
	return ApiPlaylistGetStatsFromContentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaPlaylist
// Deprecated
func (a *PlaylistApiService) PlaylistGetStatsFromContentExecute(r ApiPlaylistGetStatsFromContentRequest) (*KalturaPlaylist, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaPlaylist
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaylistApiService.PlaylistGetStatsFromContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/playlist/action/getStatsFromContent"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlaylistListRequest struct {
	ctx context.Context
	ApiService *PlaylistApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *PlaylistListRequest
}

func (r ApiPlaylistListRequest) Ks(ks string) ApiPlaylistListRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiPlaylistListRequest) Format(format int32) ApiPlaylistListRequest {
	r.format = &format
	return r
}

func (r ApiPlaylistListRequest) ClientTag(clientTag string) ApiPlaylistListRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiPlaylistListRequest) PartnerId(partnerId int32) ApiPlaylistListRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiPlaylistListRequest) Body(body PlaylistListRequest) ApiPlaylistListRequest {
	r.body = &body
	return r
}

func (r ApiPlaylistListRequest) Execute() (*KalturaPlaylistListResponse, *http.Response, error) {
	return r.ApiService.PlaylistListExecute(r)
}

/*
PlaylistList Method for PlaylistList

List available playlists

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPlaylistListRequest
*/
func (a *PlaylistApiService) PlaylistList(ctx context.Context) ApiPlaylistListRequest {
	return ApiPlaylistListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaPlaylistListResponse
func (a *PlaylistApiService) PlaylistListExecute(r ApiPlaylistListRequest) (*KalturaPlaylistListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaPlaylistListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaylistApiService.PlaylistList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/playlist/action/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlaylistUpdateRequest struct {
	ctx context.Context
	ApiService *PlaylistApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *PlaylistUpdateRequest
}

func (r ApiPlaylistUpdateRequest) Ks(ks string) ApiPlaylistUpdateRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiPlaylistUpdateRequest) Format(format int32) ApiPlaylistUpdateRequest {
	r.format = &format
	return r
}

func (r ApiPlaylistUpdateRequest) ClientTag(clientTag string) ApiPlaylistUpdateRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiPlaylistUpdateRequest) PartnerId(partnerId int32) ApiPlaylistUpdateRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiPlaylistUpdateRequest) Body(body PlaylistUpdateRequest) ApiPlaylistUpdateRequest {
	r.body = &body
	return r
}

func (r ApiPlaylistUpdateRequest) Execute() (*KalturaPlaylist, *http.Response, error) {
	return r.ApiService.PlaylistUpdateExecute(r)
}

/*
PlaylistUpdate Method for PlaylistUpdate

Update existing playlist

Note - you cannot change playlist type. Updated playlist must be of the same type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPlaylistUpdateRequest
*/
func (a *PlaylistApiService) PlaylistUpdate(ctx context.Context) ApiPlaylistUpdateRequest {
	return ApiPlaylistUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaPlaylist
func (a *PlaylistApiService) PlaylistUpdateExecute(r ApiPlaylistUpdateRequest) (*KalturaPlaylist, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaPlaylist
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaylistApiService.PlaylistUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/playlist/action/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
