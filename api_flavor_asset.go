/*
Kaltura VPaaS

The Kaltura VPaaS API

API version: 18.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// FlavorAssetApiService FlavorAssetApi service
type FlavorAssetApiService service

type ApiFlavorAssetAddRequest struct {
	ctx context.Context
	ApiService *FlavorAssetApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *FlavorAssetAddRequest
}

func (r ApiFlavorAssetAddRequest) Ks(ks string) ApiFlavorAssetAddRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiFlavorAssetAddRequest) Format(format int32) ApiFlavorAssetAddRequest {
	r.format = &format
	return r
}

func (r ApiFlavorAssetAddRequest) ClientTag(clientTag string) ApiFlavorAssetAddRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiFlavorAssetAddRequest) PartnerId(partnerId int32) ApiFlavorAssetAddRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiFlavorAssetAddRequest) Body(body FlavorAssetAddRequest) ApiFlavorAssetAddRequest {
	r.body = &body
	return r
}

func (r ApiFlavorAssetAddRequest) Execute() (*KalturaFlavorAsset, *http.Response, error) {
	return r.ApiService.FlavorAssetAddExecute(r)
}

/*
FlavorAssetAdd Method for FlavorAssetAdd

Add flavor asset

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFlavorAssetAddRequest
*/
func (a *FlavorAssetApiService) FlavorAssetAdd(ctx context.Context) ApiFlavorAssetAddRequest {
	return ApiFlavorAssetAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaFlavorAsset
func (a *FlavorAssetApiService) FlavorAssetAddExecute(r ApiFlavorAssetAddRequest) (*KalturaFlavorAsset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaFlavorAsset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlavorAssetApiService.FlavorAssetAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/flavorasset/action/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlavorAssetConvertRequest struct {
	ctx context.Context
	ApiService *FlavorAssetApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *FlavorAssetConvertRequest
}

func (r ApiFlavorAssetConvertRequest) Ks(ks string) ApiFlavorAssetConvertRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiFlavorAssetConvertRequest) Format(format int32) ApiFlavorAssetConvertRequest {
	r.format = &format
	return r
}

func (r ApiFlavorAssetConvertRequest) ClientTag(clientTag string) ApiFlavorAssetConvertRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiFlavorAssetConvertRequest) PartnerId(partnerId int32) ApiFlavorAssetConvertRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiFlavorAssetConvertRequest) Body(body FlavorAssetConvertRequest) ApiFlavorAssetConvertRequest {
	r.body = &body
	return r
}

func (r ApiFlavorAssetConvertRequest) Execute() (*http.Response, error) {
	return r.ApiService.FlavorAssetConvertExecute(r)
}

/*
FlavorAssetConvert Method for FlavorAssetConvert

Add and convert new Flavor Asset for Entry with specific Flavor Params

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFlavorAssetConvertRequest
*/
func (a *FlavorAssetApiService) FlavorAssetConvert(ctx context.Context) ApiFlavorAssetConvertRequest {
	return ApiFlavorAssetConvertRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FlavorAssetApiService) FlavorAssetConvertExecute(r ApiFlavorAssetConvertRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlavorAssetApiService.FlavorAssetConvert")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/flavorasset/action/convert"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFlavorAssetDeleteRequest struct {
	ctx context.Context
	ApiService *FlavorAssetApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AnnotationDeleteRequest
}

func (r ApiFlavorAssetDeleteRequest) Ks(ks string) ApiFlavorAssetDeleteRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiFlavorAssetDeleteRequest) Format(format int32) ApiFlavorAssetDeleteRequest {
	r.format = &format
	return r
}

func (r ApiFlavorAssetDeleteRequest) ClientTag(clientTag string) ApiFlavorAssetDeleteRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiFlavorAssetDeleteRequest) PartnerId(partnerId int32) ApiFlavorAssetDeleteRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiFlavorAssetDeleteRequest) Body(body AnnotationDeleteRequest) ApiFlavorAssetDeleteRequest {
	r.body = &body
	return r
}

func (r ApiFlavorAssetDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.FlavorAssetDeleteExecute(r)
}

/*
FlavorAssetDelete Method for FlavorAssetDelete

Delete Flavor Asset by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFlavorAssetDeleteRequest
*/
func (a *FlavorAssetApiService) FlavorAssetDelete(ctx context.Context) ApiFlavorAssetDeleteRequest {
	return ApiFlavorAssetDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FlavorAssetApiService) FlavorAssetDeleteExecute(r ApiFlavorAssetDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlavorAssetApiService.FlavorAssetDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/flavorasset/action/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFlavorAssetDeleteLocalContentRequest struct {
	ctx context.Context
	ApiService *FlavorAssetApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *ContentDistributionBatchGetAssetUrlRequest
}

func (r ApiFlavorAssetDeleteLocalContentRequest) Ks(ks string) ApiFlavorAssetDeleteLocalContentRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiFlavorAssetDeleteLocalContentRequest) Format(format int32) ApiFlavorAssetDeleteLocalContentRequest {
	r.format = &format
	return r
}

func (r ApiFlavorAssetDeleteLocalContentRequest) ClientTag(clientTag string) ApiFlavorAssetDeleteLocalContentRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiFlavorAssetDeleteLocalContentRequest) PartnerId(partnerId int32) ApiFlavorAssetDeleteLocalContentRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiFlavorAssetDeleteLocalContentRequest) Body(body ContentDistributionBatchGetAssetUrlRequest) ApiFlavorAssetDeleteLocalContentRequest {
	r.body = &body
	return r
}

func (r ApiFlavorAssetDeleteLocalContentRequest) Execute() (*http.Response, error) {
	return r.ApiService.FlavorAssetDeleteLocalContentExecute(r)
}

/*
FlavorAssetDeleteLocalContent Method for FlavorAssetDeleteLocalContent

delete all local file syncs for this asset

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFlavorAssetDeleteLocalContentRequest
*/
func (a *FlavorAssetApiService) FlavorAssetDeleteLocalContent(ctx context.Context) ApiFlavorAssetDeleteLocalContentRequest {
	return ApiFlavorAssetDeleteLocalContentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FlavorAssetApiService) FlavorAssetDeleteLocalContentExecute(r ApiFlavorAssetDeleteLocalContentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlavorAssetApiService.FlavorAssetDeleteLocalContent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/flavorasset/action/deleteLocalContent"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFlavorAssetExportRequest struct {
	ctx context.Context
	ApiService *FlavorAssetApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *CaptionAssetExportRequest
}

func (r ApiFlavorAssetExportRequest) Ks(ks string) ApiFlavorAssetExportRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiFlavorAssetExportRequest) Format(format int32) ApiFlavorAssetExportRequest {
	r.format = &format
	return r
}

func (r ApiFlavorAssetExportRequest) ClientTag(clientTag string) ApiFlavorAssetExportRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiFlavorAssetExportRequest) PartnerId(partnerId int32) ApiFlavorAssetExportRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiFlavorAssetExportRequest) Body(body CaptionAssetExportRequest) ApiFlavorAssetExportRequest {
	r.body = &body
	return r
}

func (r ApiFlavorAssetExportRequest) Execute() (*KalturaFlavorAsset, *http.Response, error) {
	return r.ApiService.FlavorAssetExportExecute(r)
}

/*
FlavorAssetExport Method for FlavorAssetExport

manually export an asset

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFlavorAssetExportRequest
*/
func (a *FlavorAssetApiService) FlavorAssetExport(ctx context.Context) ApiFlavorAssetExportRequest {
	return ApiFlavorAssetExportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaFlavorAsset
func (a *FlavorAssetApiService) FlavorAssetExportExecute(r ApiFlavorAssetExportRequest) (*KalturaFlavorAsset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaFlavorAsset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlavorAssetApiService.FlavorAssetExport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/flavorasset/action/export"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlavorAssetGetRequest struct {
	ctx context.Context
	ApiService *FlavorAssetApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AnnotationDeleteRequest
}

func (r ApiFlavorAssetGetRequest) Ks(ks string) ApiFlavorAssetGetRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiFlavorAssetGetRequest) Format(format int32) ApiFlavorAssetGetRequest {
	r.format = &format
	return r
}

func (r ApiFlavorAssetGetRequest) ClientTag(clientTag string) ApiFlavorAssetGetRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiFlavorAssetGetRequest) PartnerId(partnerId int32) ApiFlavorAssetGetRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiFlavorAssetGetRequest) Body(body AnnotationDeleteRequest) ApiFlavorAssetGetRequest {
	r.body = &body
	return r
}

func (r ApiFlavorAssetGetRequest) Execute() (*KalturaFlavorAsset, *http.Response, error) {
	return r.ApiService.FlavorAssetGetExecute(r)
}

/*
FlavorAssetGet Method for FlavorAssetGet

Get Flavor Asset by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFlavorAssetGetRequest
*/
func (a *FlavorAssetApiService) FlavorAssetGet(ctx context.Context) ApiFlavorAssetGetRequest {
	return ApiFlavorAssetGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaFlavorAsset
func (a *FlavorAssetApiService) FlavorAssetGetExecute(r ApiFlavorAssetGetRequest) (*KalturaFlavorAsset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaFlavorAsset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlavorAssetApiService.FlavorAssetGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/flavorasset/action/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlavorAssetGetByEntryIdRequest struct {
	ctx context.Context
	ApiService *FlavorAssetApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryApproveRequest
}

func (r ApiFlavorAssetGetByEntryIdRequest) Ks(ks string) ApiFlavorAssetGetByEntryIdRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiFlavorAssetGetByEntryIdRequest) Format(format int32) ApiFlavorAssetGetByEntryIdRequest {
	r.format = &format
	return r
}

func (r ApiFlavorAssetGetByEntryIdRequest) ClientTag(clientTag string) ApiFlavorAssetGetByEntryIdRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiFlavorAssetGetByEntryIdRequest) PartnerId(partnerId int32) ApiFlavorAssetGetByEntryIdRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiFlavorAssetGetByEntryIdRequest) Body(body BaseEntryApproveRequest) ApiFlavorAssetGetByEntryIdRequest {
	r.body = &body
	return r
}

func (r ApiFlavorAssetGetByEntryIdRequest) Execute() ([]KalturaFlavorAsset, *http.Response, error) {
	return r.ApiService.FlavorAssetGetByEntryIdExecute(r)
}

/*
FlavorAssetGetByEntryId Method for FlavorAssetGetByEntryId

Get Flavor Assets for Entry

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFlavorAssetGetByEntryIdRequest

Deprecated
*/
func (a *FlavorAssetApiService) FlavorAssetGetByEntryId(ctx context.Context) ApiFlavorAssetGetByEntryIdRequest {
	return ApiFlavorAssetGetByEntryIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []KalturaFlavorAsset
// Deprecated
func (a *FlavorAssetApiService) FlavorAssetGetByEntryIdExecute(r ApiFlavorAssetGetByEntryIdRequest) ([]KalturaFlavorAsset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KalturaFlavorAsset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlavorAssetApiService.FlavorAssetGetByEntryId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/flavorasset/action/getByEntryId"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlavorAssetGetDownloadUrlRequest struct {
	ctx context.Context
	ApiService *FlavorAssetApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *FlavorAssetGetDownloadUrlRequest
}

func (r ApiFlavorAssetGetDownloadUrlRequest) Ks(ks string) ApiFlavorAssetGetDownloadUrlRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiFlavorAssetGetDownloadUrlRequest) Format(format int32) ApiFlavorAssetGetDownloadUrlRequest {
	r.format = &format
	return r
}

func (r ApiFlavorAssetGetDownloadUrlRequest) ClientTag(clientTag string) ApiFlavorAssetGetDownloadUrlRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiFlavorAssetGetDownloadUrlRequest) PartnerId(partnerId int32) ApiFlavorAssetGetDownloadUrlRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiFlavorAssetGetDownloadUrlRequest) Body(body FlavorAssetGetDownloadUrlRequest) ApiFlavorAssetGetDownloadUrlRequest {
	r.body = &body
	return r
}

func (r ApiFlavorAssetGetDownloadUrlRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.FlavorAssetGetDownloadUrlExecute(r)
}

/*
FlavorAssetGetDownloadUrl Method for FlavorAssetGetDownloadUrl

Get download URL for the Flavor Asset

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFlavorAssetGetDownloadUrlRequest

Deprecated
*/
func (a *FlavorAssetApiService) FlavorAssetGetDownloadUrl(ctx context.Context) ApiFlavorAssetGetDownloadUrlRequest {
	return ApiFlavorAssetGetDownloadUrlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
// Deprecated
func (a *FlavorAssetApiService) FlavorAssetGetDownloadUrlExecute(r ApiFlavorAssetGetDownloadUrlRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlavorAssetApiService.FlavorAssetGetDownloadUrl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/flavorasset/action/getDownloadUrl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlavorAssetGetFlavorAssetsWithParamsRequest struct {
	ctx context.Context
	ApiService *FlavorAssetApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryApproveRequest
}

func (r ApiFlavorAssetGetFlavorAssetsWithParamsRequest) Ks(ks string) ApiFlavorAssetGetFlavorAssetsWithParamsRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiFlavorAssetGetFlavorAssetsWithParamsRequest) Format(format int32) ApiFlavorAssetGetFlavorAssetsWithParamsRequest {
	r.format = &format
	return r
}

func (r ApiFlavorAssetGetFlavorAssetsWithParamsRequest) ClientTag(clientTag string) ApiFlavorAssetGetFlavorAssetsWithParamsRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiFlavorAssetGetFlavorAssetsWithParamsRequest) PartnerId(partnerId int32) ApiFlavorAssetGetFlavorAssetsWithParamsRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiFlavorAssetGetFlavorAssetsWithParamsRequest) Body(body BaseEntryApproveRequest) ApiFlavorAssetGetFlavorAssetsWithParamsRequest {
	r.body = &body
	return r
}

func (r ApiFlavorAssetGetFlavorAssetsWithParamsRequest) Execute() ([]KalturaFlavorAssetWithParams, *http.Response, error) {
	return r.ApiService.FlavorAssetGetFlavorAssetsWithParamsExecute(r)
}

/*
FlavorAssetGetFlavorAssetsWithParams Method for FlavorAssetGetFlavorAssetsWithParams

Get Flavor Asset with the relevant Flavor Params (Flavor Params can exist without Flavor Asset & vice versa)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFlavorAssetGetFlavorAssetsWithParamsRequest
*/
func (a *FlavorAssetApiService) FlavorAssetGetFlavorAssetsWithParams(ctx context.Context) ApiFlavorAssetGetFlavorAssetsWithParamsRequest {
	return ApiFlavorAssetGetFlavorAssetsWithParamsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []KalturaFlavorAssetWithParams
func (a *FlavorAssetApiService) FlavorAssetGetFlavorAssetsWithParamsExecute(r ApiFlavorAssetGetFlavorAssetsWithParamsRequest) ([]KalturaFlavorAssetWithParams, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KalturaFlavorAssetWithParams
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlavorAssetApiService.FlavorAssetGetFlavorAssetsWithParams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/flavorasset/action/getFlavorAssetsWithParams"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlavorAssetGetRemotePathsRequest struct {
	ctx context.Context
	ApiService *FlavorAssetApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AnnotationDeleteRequest
}

func (r ApiFlavorAssetGetRemotePathsRequest) Ks(ks string) ApiFlavorAssetGetRemotePathsRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiFlavorAssetGetRemotePathsRequest) Format(format int32) ApiFlavorAssetGetRemotePathsRequest {
	r.format = &format
	return r
}

func (r ApiFlavorAssetGetRemotePathsRequest) ClientTag(clientTag string) ApiFlavorAssetGetRemotePathsRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiFlavorAssetGetRemotePathsRequest) PartnerId(partnerId int32) ApiFlavorAssetGetRemotePathsRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiFlavorAssetGetRemotePathsRequest) Body(body AnnotationDeleteRequest) ApiFlavorAssetGetRemotePathsRequest {
	r.body = &body
	return r
}

func (r ApiFlavorAssetGetRemotePathsRequest) Execute() (*KalturaRemotePathListResponse, *http.Response, error) {
	return r.ApiService.FlavorAssetGetRemotePathsExecute(r)
}

/*
FlavorAssetGetRemotePaths Method for FlavorAssetGetRemotePaths

Get remote storage existing paths for the asset

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFlavorAssetGetRemotePathsRequest
*/
func (a *FlavorAssetApiService) FlavorAssetGetRemotePaths(ctx context.Context) ApiFlavorAssetGetRemotePathsRequest {
	return ApiFlavorAssetGetRemotePathsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaRemotePathListResponse
func (a *FlavorAssetApiService) FlavorAssetGetRemotePathsExecute(r ApiFlavorAssetGetRemotePathsRequest) (*KalturaRemotePathListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaRemotePathListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlavorAssetApiService.FlavorAssetGetRemotePaths")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/flavorasset/action/getRemotePaths"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlavorAssetGetUrlRequest struct {
	ctx context.Context
	ApiService *FlavorAssetApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *FlavorAssetGetUrlRequest
}

func (r ApiFlavorAssetGetUrlRequest) Ks(ks string) ApiFlavorAssetGetUrlRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiFlavorAssetGetUrlRequest) Format(format int32) ApiFlavorAssetGetUrlRequest {
	r.format = &format
	return r
}

func (r ApiFlavorAssetGetUrlRequest) ClientTag(clientTag string) ApiFlavorAssetGetUrlRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiFlavorAssetGetUrlRequest) PartnerId(partnerId int32) ApiFlavorAssetGetUrlRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiFlavorAssetGetUrlRequest) Body(body FlavorAssetGetUrlRequest) ApiFlavorAssetGetUrlRequest {
	r.body = &body
	return r
}

func (r ApiFlavorAssetGetUrlRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.FlavorAssetGetUrlExecute(r)
}

/*
FlavorAssetGetUrl Method for FlavorAssetGetUrl

Get download URL for the asset

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFlavorAssetGetUrlRequest
*/
func (a *FlavorAssetApiService) FlavorAssetGetUrl(ctx context.Context) ApiFlavorAssetGetUrlRequest {
	return ApiFlavorAssetGetUrlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *FlavorAssetApiService) FlavorAssetGetUrlExecute(r ApiFlavorAssetGetUrlRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlavorAssetApiService.FlavorAssetGetUrl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/flavorasset/action/getUrl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlavorAssetGetVolumeMapRequest struct {
	ctx context.Context
	ApiService *FlavorAssetApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *FlavorAssetGetVolumeMapRequest
}

func (r ApiFlavorAssetGetVolumeMapRequest) Ks(ks string) ApiFlavorAssetGetVolumeMapRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiFlavorAssetGetVolumeMapRequest) Format(format int32) ApiFlavorAssetGetVolumeMapRequest {
	r.format = &format
	return r
}

func (r ApiFlavorAssetGetVolumeMapRequest) ClientTag(clientTag string) ApiFlavorAssetGetVolumeMapRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiFlavorAssetGetVolumeMapRequest) PartnerId(partnerId int32) ApiFlavorAssetGetVolumeMapRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiFlavorAssetGetVolumeMapRequest) Body(body FlavorAssetGetVolumeMapRequest) ApiFlavorAssetGetVolumeMapRequest {
	r.body = &body
	return r
}

func (r ApiFlavorAssetGetVolumeMapRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.FlavorAssetGetVolumeMapExecute(r)
}

/*
FlavorAssetGetVolumeMap Method for FlavorAssetGetVolumeMap

Get volume map by entry id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFlavorAssetGetVolumeMapRequest
*/
func (a *FlavorAssetApiService) FlavorAssetGetVolumeMap(ctx context.Context) ApiFlavorAssetGetVolumeMapRequest {
	return ApiFlavorAssetGetVolumeMapRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *FlavorAssetApiService) FlavorAssetGetVolumeMapExecute(r ApiFlavorAssetGetVolumeMapRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlavorAssetApiService.FlavorAssetGetVolumeMap")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/flavorasset/action/getVolumeMap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlavorAssetGetWebPlayableByEntryIdRequest struct {
	ctx context.Context
	ApiService *FlavorAssetApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryApproveRequest
}

func (r ApiFlavorAssetGetWebPlayableByEntryIdRequest) Ks(ks string) ApiFlavorAssetGetWebPlayableByEntryIdRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiFlavorAssetGetWebPlayableByEntryIdRequest) Format(format int32) ApiFlavorAssetGetWebPlayableByEntryIdRequest {
	r.format = &format
	return r
}

func (r ApiFlavorAssetGetWebPlayableByEntryIdRequest) ClientTag(clientTag string) ApiFlavorAssetGetWebPlayableByEntryIdRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiFlavorAssetGetWebPlayableByEntryIdRequest) PartnerId(partnerId int32) ApiFlavorAssetGetWebPlayableByEntryIdRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiFlavorAssetGetWebPlayableByEntryIdRequest) Body(body BaseEntryApproveRequest) ApiFlavorAssetGetWebPlayableByEntryIdRequest {
	r.body = &body
	return r
}

func (r ApiFlavorAssetGetWebPlayableByEntryIdRequest) Execute() ([]KalturaFlavorAsset, *http.Response, error) {
	return r.ApiService.FlavorAssetGetWebPlayableByEntryIdExecute(r)
}

/*
FlavorAssetGetWebPlayableByEntryId Method for FlavorAssetGetWebPlayableByEntryId

Get web playable Flavor Assets for Entry

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFlavorAssetGetWebPlayableByEntryIdRequest

Deprecated
*/
func (a *FlavorAssetApiService) FlavorAssetGetWebPlayableByEntryId(ctx context.Context) ApiFlavorAssetGetWebPlayableByEntryIdRequest {
	return ApiFlavorAssetGetWebPlayableByEntryIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []KalturaFlavorAsset
// Deprecated
func (a *FlavorAssetApiService) FlavorAssetGetWebPlayableByEntryIdExecute(r ApiFlavorAssetGetWebPlayableByEntryIdRequest) ([]KalturaFlavorAsset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []KalturaFlavorAsset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlavorAssetApiService.FlavorAssetGetWebPlayableByEntryId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/flavorasset/action/getWebPlayableByEntryId"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlavorAssetListRequest struct {
	ctx context.Context
	ApiService *FlavorAssetApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AttachmentAssetListRequest
}

func (r ApiFlavorAssetListRequest) Ks(ks string) ApiFlavorAssetListRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiFlavorAssetListRequest) Format(format int32) ApiFlavorAssetListRequest {
	r.format = &format
	return r
}

func (r ApiFlavorAssetListRequest) ClientTag(clientTag string) ApiFlavorAssetListRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiFlavorAssetListRequest) PartnerId(partnerId int32) ApiFlavorAssetListRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiFlavorAssetListRequest) Body(body AttachmentAssetListRequest) ApiFlavorAssetListRequest {
	r.body = &body
	return r
}

func (r ApiFlavorAssetListRequest) Execute() (*KalturaFlavorAssetListResponse, *http.Response, error) {
	return r.ApiService.FlavorAssetListExecute(r)
}

/*
FlavorAssetList Method for FlavorAssetList

List Flavor Assets by filter and pager

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFlavorAssetListRequest
*/
func (a *FlavorAssetApiService) FlavorAssetList(ctx context.Context) ApiFlavorAssetListRequest {
	return ApiFlavorAssetListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaFlavorAssetListResponse
func (a *FlavorAssetApiService) FlavorAssetListExecute(r ApiFlavorAssetListRequest) (*KalturaFlavorAssetListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaFlavorAssetListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlavorAssetApiService.FlavorAssetList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/flavorasset/action/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlavorAssetReconvertRequest struct {
	ctx context.Context
	ApiService *FlavorAssetApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AnnotationDeleteRequest
}

func (r ApiFlavorAssetReconvertRequest) Ks(ks string) ApiFlavorAssetReconvertRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiFlavorAssetReconvertRequest) Format(format int32) ApiFlavorAssetReconvertRequest {
	r.format = &format
	return r
}

func (r ApiFlavorAssetReconvertRequest) ClientTag(clientTag string) ApiFlavorAssetReconvertRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiFlavorAssetReconvertRequest) PartnerId(partnerId int32) ApiFlavorAssetReconvertRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiFlavorAssetReconvertRequest) Body(body AnnotationDeleteRequest) ApiFlavorAssetReconvertRequest {
	r.body = &body
	return r
}

func (r ApiFlavorAssetReconvertRequest) Execute() (*http.Response, error) {
	return r.ApiService.FlavorAssetReconvertExecute(r)
}

/*
FlavorAssetReconvert Method for FlavorAssetReconvert

Reconvert Flavor Asset by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFlavorAssetReconvertRequest
*/
func (a *FlavorAssetApiService) FlavorAssetReconvert(ctx context.Context) ApiFlavorAssetReconvertRequest {
	return ApiFlavorAssetReconvertRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FlavorAssetApiService) FlavorAssetReconvertExecute(r ApiFlavorAssetReconvertRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlavorAssetApiService.FlavorAssetReconvert")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/flavorasset/action/reconvert"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFlavorAssetServeAdStitchCmdRequest struct {
	ctx context.Context
	ApiService *FlavorAssetApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *FlavorAssetServeAdStitchCmdRequest
}

func (r ApiFlavorAssetServeAdStitchCmdRequest) Ks(ks string) ApiFlavorAssetServeAdStitchCmdRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiFlavorAssetServeAdStitchCmdRequest) Format(format int32) ApiFlavorAssetServeAdStitchCmdRequest {
	r.format = &format
	return r
}

func (r ApiFlavorAssetServeAdStitchCmdRequest) ClientTag(clientTag string) ApiFlavorAssetServeAdStitchCmdRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiFlavorAssetServeAdStitchCmdRequest) PartnerId(partnerId int32) ApiFlavorAssetServeAdStitchCmdRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiFlavorAssetServeAdStitchCmdRequest) Body(body FlavorAssetServeAdStitchCmdRequest) ApiFlavorAssetServeAdStitchCmdRequest {
	r.body = &body
	return r
}

func (r ApiFlavorAssetServeAdStitchCmdRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.FlavorAssetServeAdStitchCmdExecute(r)
}

/*
FlavorAssetServeAdStitchCmd Method for FlavorAssetServeAdStitchCmd

serve cmd line to transcode the ad

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFlavorAssetServeAdStitchCmdRequest
*/
func (a *FlavorAssetApiService) FlavorAssetServeAdStitchCmd(ctx context.Context) ApiFlavorAssetServeAdStitchCmdRequest {
	return ApiFlavorAssetServeAdStitchCmdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *FlavorAssetApiService) FlavorAssetServeAdStitchCmdExecute(r ApiFlavorAssetServeAdStitchCmdRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlavorAssetApiService.FlavorAssetServeAdStitchCmd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/flavorasset/action/serveAdStitchCmd"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlavorAssetSetAsSourceRequest struct {
	ctx context.Context
	ApiService *FlavorAssetApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *ContentDistributionBatchGetAssetUrlRequest
}

func (r ApiFlavorAssetSetAsSourceRequest) Ks(ks string) ApiFlavorAssetSetAsSourceRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiFlavorAssetSetAsSourceRequest) Format(format int32) ApiFlavorAssetSetAsSourceRequest {
	r.format = &format
	return r
}

func (r ApiFlavorAssetSetAsSourceRequest) ClientTag(clientTag string) ApiFlavorAssetSetAsSourceRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiFlavorAssetSetAsSourceRequest) PartnerId(partnerId int32) ApiFlavorAssetSetAsSourceRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiFlavorAssetSetAsSourceRequest) Body(body ContentDistributionBatchGetAssetUrlRequest) ApiFlavorAssetSetAsSourceRequest {
	r.body = &body
	return r
}

func (r ApiFlavorAssetSetAsSourceRequest) Execute() (*http.Response, error) {
	return r.ApiService.FlavorAssetSetAsSourceExecute(r)
}

/*
FlavorAssetSetAsSource Method for FlavorAssetSetAsSource

Set a given flavor as the original flavor

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFlavorAssetSetAsSourceRequest
*/
func (a *FlavorAssetApiService) FlavorAssetSetAsSource(ctx context.Context) ApiFlavorAssetSetAsSourceRequest {
	return ApiFlavorAssetSetAsSourceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *FlavorAssetApiService) FlavorAssetSetAsSourceExecute(r ApiFlavorAssetSetAsSourceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlavorAssetApiService.FlavorAssetSetAsSource")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/flavorasset/action/setAsSource"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFlavorAssetSetContentRequest struct {
	ctx context.Context
	ApiService *FlavorAssetApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AttachmentAssetSetContentRequest
}

func (r ApiFlavorAssetSetContentRequest) Ks(ks string) ApiFlavorAssetSetContentRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiFlavorAssetSetContentRequest) Format(format int32) ApiFlavorAssetSetContentRequest {
	r.format = &format
	return r
}

func (r ApiFlavorAssetSetContentRequest) ClientTag(clientTag string) ApiFlavorAssetSetContentRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiFlavorAssetSetContentRequest) PartnerId(partnerId int32) ApiFlavorAssetSetContentRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiFlavorAssetSetContentRequest) Body(body AttachmentAssetSetContentRequest) ApiFlavorAssetSetContentRequest {
	r.body = &body
	return r
}

func (r ApiFlavorAssetSetContentRequest) Execute() (*KalturaFlavorAsset, *http.Response, error) {
	return r.ApiService.FlavorAssetSetContentExecute(r)
}

/*
FlavorAssetSetContent Method for FlavorAssetSetContent

Update content of flavor asset

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFlavorAssetSetContentRequest
*/
func (a *FlavorAssetApiService) FlavorAssetSetContent(ctx context.Context) ApiFlavorAssetSetContentRequest {
	return ApiFlavorAssetSetContentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaFlavorAsset
func (a *FlavorAssetApiService) FlavorAssetSetContentExecute(r ApiFlavorAssetSetContentRequest) (*KalturaFlavorAsset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaFlavorAsset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlavorAssetApiService.FlavorAssetSetContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/flavorasset/action/setContent"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFlavorAssetUpdateRequest struct {
	ctx context.Context
	ApiService *FlavorAssetApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *FlavorAssetUpdateRequest
}

func (r ApiFlavorAssetUpdateRequest) Ks(ks string) ApiFlavorAssetUpdateRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiFlavorAssetUpdateRequest) Format(format int32) ApiFlavorAssetUpdateRequest {
	r.format = &format
	return r
}

func (r ApiFlavorAssetUpdateRequest) ClientTag(clientTag string) ApiFlavorAssetUpdateRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiFlavorAssetUpdateRequest) PartnerId(partnerId int32) ApiFlavorAssetUpdateRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiFlavorAssetUpdateRequest) Body(body FlavorAssetUpdateRequest) ApiFlavorAssetUpdateRequest {
	r.body = &body
	return r
}

func (r ApiFlavorAssetUpdateRequest) Execute() (*KalturaFlavorAsset, *http.Response, error) {
	return r.ApiService.FlavorAssetUpdateExecute(r)
}

/*
FlavorAssetUpdate Method for FlavorAssetUpdate

Update flavor asset

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFlavorAssetUpdateRequest
*/
func (a *FlavorAssetApiService) FlavorAssetUpdate(ctx context.Context) ApiFlavorAssetUpdateRequest {
	return ApiFlavorAssetUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaFlavorAsset
func (a *FlavorAssetApiService) FlavorAssetUpdateExecute(r ApiFlavorAssetUpdateRequest) (*KalturaFlavorAsset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaFlavorAsset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FlavorAssetApiService.FlavorAssetUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/flavorasset/action/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
