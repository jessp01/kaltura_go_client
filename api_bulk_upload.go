/*
Kaltura VPaaS

The Kaltura VPaaS API

API version: 18.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
)


// BulkUploadApiService BulkUploadApi service
type BulkUploadApiService service

type ApiBulkUploadAbortRequest struct {
	ctx context.Context
	ApiService *BulkUploadApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AccessControlDeleteRequest
}

func (r ApiBulkUploadAbortRequest) Ks(ks string) ApiBulkUploadAbortRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBulkUploadAbortRequest) Format(format int32) ApiBulkUploadAbortRequest {
	r.format = &format
	return r
}

func (r ApiBulkUploadAbortRequest) ClientTag(clientTag string) ApiBulkUploadAbortRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBulkUploadAbortRequest) PartnerId(partnerId int32) ApiBulkUploadAbortRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBulkUploadAbortRequest) Body(body AccessControlDeleteRequest) ApiBulkUploadAbortRequest {
	r.body = &body
	return r
}

func (r ApiBulkUploadAbortRequest) Execute() (*KalturaBulkUpload, *http.Response, error) {
	return r.ApiService.BulkUploadAbortExecute(r)
}

/*
BulkUploadAbort Method for BulkUploadAbort

Aborts the bulk upload and all its child jobs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkUploadAbortRequest
*/
func (a *BulkUploadApiService) BulkUploadAbort(ctx context.Context) ApiBulkUploadAbortRequest {
	return ApiBulkUploadAbortRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBulkUpload
func (a *BulkUploadApiService) BulkUploadAbortExecute(r ApiBulkUploadAbortRequest) (*KalturaBulkUpload, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBulkUpload
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BulkUploadApiService.BulkUploadAbort")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/bulkupload/action/abort"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkUploadAddRequest struct {
	ctx context.Context
	ApiService *BulkUploadApiService
	conversionProfileId *int32
	csvFileData **os.File
	ks *string
	format *int32
	bulkUploadType *string
	uploadedBy *string
	fileName *string
}

// Conversion profile id to use for converting the current bulk (-1 to use partner&#39;s default)
func (r ApiBulkUploadAddRequest) ConversionProfileId(conversionProfileId int32) ApiBulkUploadAddRequest {
	r.conversionProfileId = &conversionProfileId
	return r
}

// bulk upload file
func (r ApiBulkUploadAddRequest) CsvFileData(csvFileData *os.File) ApiBulkUploadAddRequest {
	r.csvFileData = &csvFileData
	return r
}

func (r ApiBulkUploadAddRequest) Ks(ks string) ApiBulkUploadAddRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBulkUploadAddRequest) Format(format int32) ApiBulkUploadAddRequest {
	r.format = &format
	return r
}

// Enum Type: &#x60;KalturaBulkUploadType&#x60;
func (r ApiBulkUploadAddRequest) BulkUploadType(bulkUploadType string) ApiBulkUploadAddRequest {
	r.bulkUploadType = &bulkUploadType
	return r
}

func (r ApiBulkUploadAddRequest) UploadedBy(uploadedBy string) ApiBulkUploadAddRequest {
	r.uploadedBy = &uploadedBy
	return r
}

// Friendly name of the file, used to be recognized later in the logs.
func (r ApiBulkUploadAddRequest) FileName(fileName string) ApiBulkUploadAddRequest {
	r.fileName = &fileName
	return r
}

func (r ApiBulkUploadAddRequest) Execute() (*KalturaBulkUpload, *http.Response, error) {
	return r.ApiService.BulkUploadAddExecute(r)
}

/*
BulkUploadAdd Method for BulkUploadAdd

Add new bulk upload batch job

Conversion profile id can be specified in the API or in the CSV file, the one in the CSV file will be stronger.

If no conversion profile was specified, partner's default will be used

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkUploadAddRequest

Deprecated
*/
func (a *BulkUploadApiService) BulkUploadAdd(ctx context.Context) ApiBulkUploadAddRequest {
	return ApiBulkUploadAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBulkUpload
// Deprecated
func (a *BulkUploadApiService) BulkUploadAddExecute(r ApiBulkUploadAddRequest) (*KalturaBulkUpload, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBulkUpload
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BulkUploadApiService.BulkUploadAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/bulkupload/action/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.conversionProfileId == nil {
		return localVarReturnValue, nil, reportError("conversionProfileId is required and must be specified")
	}
	if r.csvFileData == nil {
		return localVarReturnValue, nil, reportError("csvFileData is required and must be specified")
	}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	localVarQueryParams.Add("conversionProfileId", parameterToString(*r.conversionProfileId, ""))
	if r.bulkUploadType != nil {
		localVarQueryParams.Add("bulkUploadType", parameterToString(*r.bulkUploadType, ""))
	}
	if r.uploadedBy != nil {
		localVarQueryParams.Add("uploadedBy", parameterToString(*r.uploadedBy, ""))
	}
	if r.fileName != nil {
		localVarQueryParams.Add("fileName", parameterToString(*r.fileName, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var csvFileDataLocalVarFormFileName string
	var csvFileDataLocalVarFileName     string
	var csvFileDataLocalVarFileBytes    []byte

	csvFileDataLocalVarFormFileName = "csvFileData"

	csvFileDataLocalVarFile := *r.csvFileData
	if csvFileDataLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(csvFileDataLocalVarFile)
		csvFileDataLocalVarFileBytes = fbs
		csvFileDataLocalVarFileName = csvFileDataLocalVarFile.Name()
		csvFileDataLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: csvFileDataLocalVarFileBytes, fileName: csvFileDataLocalVarFileName, formFileName: csvFileDataLocalVarFormFileName})
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkUploadGetRequest struct {
	ctx context.Context
	ApiService *BulkUploadApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AccessControlDeleteRequest
}

func (r ApiBulkUploadGetRequest) Ks(ks string) ApiBulkUploadGetRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBulkUploadGetRequest) Format(format int32) ApiBulkUploadGetRequest {
	r.format = &format
	return r
}

func (r ApiBulkUploadGetRequest) ClientTag(clientTag string) ApiBulkUploadGetRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBulkUploadGetRequest) PartnerId(partnerId int32) ApiBulkUploadGetRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBulkUploadGetRequest) Body(body AccessControlDeleteRequest) ApiBulkUploadGetRequest {
	r.body = &body
	return r
}

func (r ApiBulkUploadGetRequest) Execute() (*KalturaBulkUpload, *http.Response, error) {
	return r.ApiService.BulkUploadGetExecute(r)
}

/*
BulkUploadGet Method for BulkUploadGet

Get bulk upload batch job by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkUploadGetRequest
*/
func (a *BulkUploadApiService) BulkUploadGet(ctx context.Context) ApiBulkUploadGetRequest {
	return ApiBulkUploadGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBulkUpload
func (a *BulkUploadApiService) BulkUploadGetExecute(r ApiBulkUploadGetRequest) (*KalturaBulkUpload, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBulkUpload
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BulkUploadApiService.BulkUploadGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/bulkupload/action/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkUploadListRequest struct {
	ctx context.Context
	ApiService *BulkUploadApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BulkUploadListRequest
}

func (r ApiBulkUploadListRequest) Ks(ks string) ApiBulkUploadListRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBulkUploadListRequest) Format(format int32) ApiBulkUploadListRequest {
	r.format = &format
	return r
}

func (r ApiBulkUploadListRequest) ClientTag(clientTag string) ApiBulkUploadListRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBulkUploadListRequest) PartnerId(partnerId int32) ApiBulkUploadListRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBulkUploadListRequest) Body(body BulkUploadListRequest) ApiBulkUploadListRequest {
	r.body = &body
	return r
}

func (r ApiBulkUploadListRequest) Execute() (*KalturaBulkUploadListResponse, *http.Response, error) {
	return r.ApiService.BulkUploadListExecute(r)
}

/*
BulkUploadList Method for BulkUploadList

List bulk upload batch jobs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkUploadListRequest
*/
func (a *BulkUploadApiService) BulkUploadList(ctx context.Context) ApiBulkUploadListRequest {
	return ApiBulkUploadListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBulkUploadListResponse
func (a *BulkUploadApiService) BulkUploadListExecute(r ApiBulkUploadListRequest) (*KalturaBulkUploadListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBulkUploadListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BulkUploadApiService.BulkUploadList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/bulkupload/action/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkUploadServeRequest struct {
	ctx context.Context
	ApiService *BulkUploadApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AccessControlDeleteRequest
}

func (r ApiBulkUploadServeRequest) Ks(ks string) ApiBulkUploadServeRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBulkUploadServeRequest) Format(format int32) ApiBulkUploadServeRequest {
	r.format = &format
	return r
}

func (r ApiBulkUploadServeRequest) ClientTag(clientTag string) ApiBulkUploadServeRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBulkUploadServeRequest) PartnerId(partnerId int32) ApiBulkUploadServeRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBulkUploadServeRequest) Body(body AccessControlDeleteRequest) ApiBulkUploadServeRequest {
	r.body = &body
	return r
}

func (r ApiBulkUploadServeRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.BulkUploadServeExecute(r)
}

/*
BulkUploadServe Method for BulkUploadServe

serve action return the original file.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkUploadServeRequest
*/
func (a *BulkUploadApiService) BulkUploadServe(ctx context.Context) ApiBulkUploadServeRequest {
	return ApiBulkUploadServeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *BulkUploadApiService) BulkUploadServeExecute(r ApiBulkUploadServeRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BulkUploadApiService.BulkUploadServe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/bulkupload/action/serve"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkUploadServeLogRequest struct {
	ctx context.Context
	ApiService *BulkUploadApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AccessControlDeleteRequest
}

func (r ApiBulkUploadServeLogRequest) Ks(ks string) ApiBulkUploadServeLogRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiBulkUploadServeLogRequest) Format(format int32) ApiBulkUploadServeLogRequest {
	r.format = &format
	return r
}

func (r ApiBulkUploadServeLogRequest) ClientTag(clientTag string) ApiBulkUploadServeLogRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiBulkUploadServeLogRequest) PartnerId(partnerId int32) ApiBulkUploadServeLogRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiBulkUploadServeLogRequest) Body(body AccessControlDeleteRequest) ApiBulkUploadServeLogRequest {
	r.body = &body
	return r
}

func (r ApiBulkUploadServeLogRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.BulkUploadServeLogExecute(r)
}

/*
BulkUploadServeLog Method for BulkUploadServeLog

serveLog action return the original file.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkUploadServeLogRequest
*/
func (a *BulkUploadApiService) BulkUploadServeLog(ctx context.Context) ApiBulkUploadServeLogRequest {
	return ApiBulkUploadServeLogRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *BulkUploadApiService) BulkUploadServeLogExecute(r ApiBulkUploadServeLogRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BulkUploadApiService.BulkUploadServeLog")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/bulkupload/action/serveLog"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
