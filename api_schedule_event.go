/*
Kaltura VPaaS

The Kaltura VPaaS API

API version: 18.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
)


// ScheduleEventApiService ScheduleEventApi service
type ScheduleEventApiService service

type ApiScheduleEventAddRequest struct {
	ctx context.Context
	ApiService *ScheduleEventApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *ScheduleEventAddRequest
}

func (r ApiScheduleEventAddRequest) Ks(ks string) ApiScheduleEventAddRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiScheduleEventAddRequest) Format(format int32) ApiScheduleEventAddRequest {
	r.format = &format
	return r
}

func (r ApiScheduleEventAddRequest) ClientTag(clientTag string) ApiScheduleEventAddRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiScheduleEventAddRequest) PartnerId(partnerId int32) ApiScheduleEventAddRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiScheduleEventAddRequest) Body(body ScheduleEventAddRequest) ApiScheduleEventAddRequest {
	r.body = &body
	return r
}

func (r ApiScheduleEventAddRequest) Execute() (*KalturaScheduleEvent, *http.Response, error) {
	return r.ApiService.ScheduleEventAddExecute(r)
}

/*
ScheduleEventAdd Method for ScheduleEventAdd

Allows you to add a new KalturaScheduleEvent object

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiScheduleEventAddRequest
*/
func (a *ScheduleEventApiService) ScheduleEventAdd(ctx context.Context) ApiScheduleEventAddRequest {
	return ApiScheduleEventAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaScheduleEvent
func (a *ScheduleEventApiService) ScheduleEventAddExecute(r ApiScheduleEventAddRequest) (*KalturaScheduleEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaScheduleEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduleEventApiService.ScheduleEventAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/schedule_scheduleevent/action/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiScheduleEventAddFromBulkUploadRequest struct {
	ctx context.Context
	ApiService *ScheduleEventApiService
	fileData **os.File
	ks *string
	format *int32
	bulkUploadDataObjectType *string
	bulkUploadDataFileName *string
	bulkUploadDataObjectDataObjectType *string
	bulkUploadDataEmailRecipients *string
	bulkUploadDataNumOfErrorObjects *int32
	bulkUploadDataPrivileges *string
}

func (r ApiScheduleEventAddFromBulkUploadRequest) FileData(fileData *os.File) ApiScheduleEventAddFromBulkUploadRequest {
	r.fileData = &fileData
	return r
}

func (r ApiScheduleEventAddFromBulkUploadRequest) Ks(ks string) ApiScheduleEventAddFromBulkUploadRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiScheduleEventAddFromBulkUploadRequest) Format(format int32) ApiScheduleEventAddFromBulkUploadRequest {
	r.format = &format
	return r
}

func (r ApiScheduleEventAddFromBulkUploadRequest) BulkUploadDataObjectType(bulkUploadDataObjectType string) ApiScheduleEventAddFromBulkUploadRequest {
	r.bulkUploadDataObjectType = &bulkUploadDataObjectType
	return r
}

// Friendly name of the file, used to be recognized later in the logs.
func (r ApiScheduleEventAddFromBulkUploadRequest) BulkUploadDataFileName(bulkUploadDataFileName string) ApiScheduleEventAddFromBulkUploadRequest {
	r.bulkUploadDataFileName = &bulkUploadDataFileName
	return r
}

func (r ApiScheduleEventAddFromBulkUploadRequest) BulkUploadDataObjectDataObjectType(bulkUploadDataObjectDataObjectType string) ApiScheduleEventAddFromBulkUploadRequest {
	r.bulkUploadDataObjectDataObjectType = &bulkUploadDataObjectDataObjectType
	return r
}

// Recipients of the email for bulk upload success/failure
func (r ApiScheduleEventAddFromBulkUploadRequest) BulkUploadDataEmailRecipients(bulkUploadDataEmailRecipients string) ApiScheduleEventAddFromBulkUploadRequest {
	r.bulkUploadDataEmailRecipients = &bulkUploadDataEmailRecipients
	return r
}

// Number of objects that finished on error status
func (r ApiScheduleEventAddFromBulkUploadRequest) BulkUploadDataNumOfErrorObjects(bulkUploadDataNumOfErrorObjects int32) ApiScheduleEventAddFromBulkUploadRequest {
	r.bulkUploadDataNumOfErrorObjects = &bulkUploadDataNumOfErrorObjects
	return r
}

// privileges for the job
func (r ApiScheduleEventAddFromBulkUploadRequest) BulkUploadDataPrivileges(bulkUploadDataPrivileges string) ApiScheduleEventAddFromBulkUploadRequest {
	r.bulkUploadDataPrivileges = &bulkUploadDataPrivileges
	return r
}

func (r ApiScheduleEventAddFromBulkUploadRequest) Execute() (*KalturaBulkUpload, *http.Response, error) {
	return r.ApiService.ScheduleEventAddFromBulkUploadExecute(r)
}

/*
ScheduleEventAddFromBulkUpload Method for ScheduleEventAddFromBulkUpload

Add new bulk upload batch job

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiScheduleEventAddFromBulkUploadRequest
*/
func (a *ScheduleEventApiService) ScheduleEventAddFromBulkUpload(ctx context.Context) ApiScheduleEventAddFromBulkUploadRequest {
	return ApiScheduleEventAddFromBulkUploadRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBulkUpload
func (a *ScheduleEventApiService) ScheduleEventAddFromBulkUploadExecute(r ApiScheduleEventAddFromBulkUploadRequest) (*KalturaBulkUpload, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBulkUpload
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduleEventApiService.ScheduleEventAddFromBulkUpload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/schedule_scheduleevent/action/addFromBulkUpload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileData == nil {
		return localVarReturnValue, nil, reportError("fileData is required and must be specified")
	}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.bulkUploadDataObjectType != nil {
		localVarQueryParams.Add("bulkUploadData[objectType]", parameterToString(*r.bulkUploadDataObjectType, ""))
	}
	if r.bulkUploadDataFileName != nil {
		localVarQueryParams.Add("bulkUploadData[fileName]", parameterToString(*r.bulkUploadDataFileName, ""))
	}
	if r.bulkUploadDataObjectDataObjectType != nil {
		localVarQueryParams.Add("bulkUploadData[objectData][objectType]", parameterToString(*r.bulkUploadDataObjectDataObjectType, ""))
	}
	if r.bulkUploadDataEmailRecipients != nil {
		localVarQueryParams.Add("bulkUploadData[emailRecipients]", parameterToString(*r.bulkUploadDataEmailRecipients, ""))
	}
	if r.bulkUploadDataNumOfErrorObjects != nil {
		localVarQueryParams.Add("bulkUploadData[numOfErrorObjects]", parameterToString(*r.bulkUploadDataNumOfErrorObjects, ""))
	}
	if r.bulkUploadDataPrivileges != nil {
		localVarQueryParams.Add("bulkUploadData[privileges]", parameterToString(*r.bulkUploadDataPrivileges, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileDataLocalVarFormFileName string
	var fileDataLocalVarFileName     string
	var fileDataLocalVarFileBytes    []byte

	fileDataLocalVarFormFileName = "fileData"

	fileDataLocalVarFile := *r.fileData
	if fileDataLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(fileDataLocalVarFile)
		fileDataLocalVarFileBytes = fbs
		fileDataLocalVarFileName = fileDataLocalVarFile.Name()
		fileDataLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: fileDataLocalVarFileBytes, fileName: fileDataLocalVarFileName, formFileName: fileDataLocalVarFormFileName})
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiScheduleEventCancelRequest struct {
	ctx context.Context
	ApiService *ScheduleEventApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *ScheduleEventCancelRequest
}

func (r ApiScheduleEventCancelRequest) Ks(ks string) ApiScheduleEventCancelRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiScheduleEventCancelRequest) Format(format int32) ApiScheduleEventCancelRequest {
	r.format = &format
	return r
}

func (r ApiScheduleEventCancelRequest) ClientTag(clientTag string) ApiScheduleEventCancelRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiScheduleEventCancelRequest) PartnerId(partnerId int32) ApiScheduleEventCancelRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiScheduleEventCancelRequest) Body(body ScheduleEventCancelRequest) ApiScheduleEventCancelRequest {
	r.body = &body
	return r
}

func (r ApiScheduleEventCancelRequest) Execute() (*KalturaScheduleEvent, *http.Response, error) {
	return r.ApiService.ScheduleEventCancelExecute(r)
}

/*
ScheduleEventCancel Method for ScheduleEventCancel

Mark the KalturaScheduleEvent object as cancelled

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiScheduleEventCancelRequest
*/
func (a *ScheduleEventApiService) ScheduleEventCancel(ctx context.Context) ApiScheduleEventCancelRequest {
	return ApiScheduleEventCancelRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaScheduleEvent
func (a *ScheduleEventApiService) ScheduleEventCancelExecute(r ApiScheduleEventCancelRequest) (*KalturaScheduleEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaScheduleEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduleEventApiService.ScheduleEventCancel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/schedule_scheduleevent/action/cancel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiScheduleEventDeleteRequest struct {
	ctx context.Context
	ApiService *ScheduleEventApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *ScheduleEventCancelRequest
}

func (r ApiScheduleEventDeleteRequest) Ks(ks string) ApiScheduleEventDeleteRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiScheduleEventDeleteRequest) Format(format int32) ApiScheduleEventDeleteRequest {
	r.format = &format
	return r
}

func (r ApiScheduleEventDeleteRequest) ClientTag(clientTag string) ApiScheduleEventDeleteRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiScheduleEventDeleteRequest) PartnerId(partnerId int32) ApiScheduleEventDeleteRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiScheduleEventDeleteRequest) Body(body ScheduleEventCancelRequest) ApiScheduleEventDeleteRequest {
	r.body = &body
	return r
}

func (r ApiScheduleEventDeleteRequest) Execute() (*KalturaScheduleEvent, *http.Response, error) {
	return r.ApiService.ScheduleEventDeleteExecute(r)
}

/*
ScheduleEventDelete Method for ScheduleEventDelete

Mark the KalturaScheduleEvent object as deleted

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiScheduleEventDeleteRequest
*/
func (a *ScheduleEventApiService) ScheduleEventDelete(ctx context.Context) ApiScheduleEventDeleteRequest {
	return ApiScheduleEventDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaScheduleEvent
func (a *ScheduleEventApiService) ScheduleEventDeleteExecute(r ApiScheduleEventDeleteRequest) (*KalturaScheduleEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaScheduleEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduleEventApiService.ScheduleEventDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/schedule_scheduleevent/action/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiScheduleEventGetRequest struct {
	ctx context.Context
	ApiService *ScheduleEventApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *ScheduleEventCancelRequest
}

func (r ApiScheduleEventGetRequest) Ks(ks string) ApiScheduleEventGetRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiScheduleEventGetRequest) Format(format int32) ApiScheduleEventGetRequest {
	r.format = &format
	return r
}

func (r ApiScheduleEventGetRequest) ClientTag(clientTag string) ApiScheduleEventGetRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiScheduleEventGetRequest) PartnerId(partnerId int32) ApiScheduleEventGetRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiScheduleEventGetRequest) Body(body ScheduleEventCancelRequest) ApiScheduleEventGetRequest {
	r.body = &body
	return r
}

func (r ApiScheduleEventGetRequest) Execute() (*KalturaScheduleEvent, *http.Response, error) {
	return r.ApiService.ScheduleEventGetExecute(r)
}

/*
ScheduleEventGet Method for ScheduleEventGet

Retrieve a KalturaScheduleEvent object by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiScheduleEventGetRequest
*/
func (a *ScheduleEventApiService) ScheduleEventGet(ctx context.Context) ApiScheduleEventGetRequest {
	return ApiScheduleEventGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaScheduleEvent
func (a *ScheduleEventApiService) ScheduleEventGetExecute(r ApiScheduleEventGetRequest) (*KalturaScheduleEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaScheduleEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduleEventApiService.ScheduleEventGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/schedule_scheduleevent/action/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiScheduleEventGetConflictsRequest struct {
	ctx context.Context
	ApiService *ScheduleEventApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *ScheduleEventGetConflictsRequest
}

func (r ApiScheduleEventGetConflictsRequest) Ks(ks string) ApiScheduleEventGetConflictsRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiScheduleEventGetConflictsRequest) Format(format int32) ApiScheduleEventGetConflictsRequest {
	r.format = &format
	return r
}

func (r ApiScheduleEventGetConflictsRequest) ClientTag(clientTag string) ApiScheduleEventGetConflictsRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiScheduleEventGetConflictsRequest) PartnerId(partnerId int32) ApiScheduleEventGetConflictsRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiScheduleEventGetConflictsRequest) Body(body ScheduleEventGetConflictsRequest) ApiScheduleEventGetConflictsRequest {
	r.body = &body
	return r
}

func (r ApiScheduleEventGetConflictsRequest) Execute() (*KalturaScheduleEventListResponse, *http.Response, error) {
	return r.ApiService.ScheduleEventGetConflictsExecute(r)
}

/*
ScheduleEventGetConflicts Method for ScheduleEventGetConflicts

List conflicting events for resourcesIds by event's dates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiScheduleEventGetConflictsRequest
*/
func (a *ScheduleEventApiService) ScheduleEventGetConflicts(ctx context.Context) ApiScheduleEventGetConflictsRequest {
	return ApiScheduleEventGetConflictsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaScheduleEventListResponse
func (a *ScheduleEventApiService) ScheduleEventGetConflictsExecute(r ApiScheduleEventGetConflictsRequest) (*KalturaScheduleEventListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaScheduleEventListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduleEventApiService.ScheduleEventGetConflicts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/schedule_scheduleevent/action/getConflicts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiScheduleEventListRequest struct {
	ctx context.Context
	ApiService *ScheduleEventApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *ScheduleEventListRequest
}

func (r ApiScheduleEventListRequest) Ks(ks string) ApiScheduleEventListRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiScheduleEventListRequest) Format(format int32) ApiScheduleEventListRequest {
	r.format = &format
	return r
}

func (r ApiScheduleEventListRequest) ClientTag(clientTag string) ApiScheduleEventListRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiScheduleEventListRequest) PartnerId(partnerId int32) ApiScheduleEventListRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiScheduleEventListRequest) Body(body ScheduleEventListRequest) ApiScheduleEventListRequest {
	r.body = &body
	return r
}

func (r ApiScheduleEventListRequest) Execute() (*KalturaScheduleEventListResponse, *http.Response, error) {
	return r.ApiService.ScheduleEventListExecute(r)
}

/*
ScheduleEventList Method for ScheduleEventList

List KalturaScheduleEvent objects

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiScheduleEventListRequest
*/
func (a *ScheduleEventApiService) ScheduleEventList(ctx context.Context) ApiScheduleEventListRequest {
	return ApiScheduleEventListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaScheduleEventListResponse
func (a *ScheduleEventApiService) ScheduleEventListExecute(r ApiScheduleEventListRequest) (*KalturaScheduleEventListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaScheduleEventListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduleEventApiService.ScheduleEventList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/schedule_scheduleevent/action/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiScheduleEventUpdateRequest struct {
	ctx context.Context
	ApiService *ScheduleEventApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *ScheduleEventUpdateRequest
}

func (r ApiScheduleEventUpdateRequest) Ks(ks string) ApiScheduleEventUpdateRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiScheduleEventUpdateRequest) Format(format int32) ApiScheduleEventUpdateRequest {
	r.format = &format
	return r
}

func (r ApiScheduleEventUpdateRequest) ClientTag(clientTag string) ApiScheduleEventUpdateRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiScheduleEventUpdateRequest) PartnerId(partnerId int32) ApiScheduleEventUpdateRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiScheduleEventUpdateRequest) Body(body ScheduleEventUpdateRequest) ApiScheduleEventUpdateRequest {
	r.body = &body
	return r
}

func (r ApiScheduleEventUpdateRequest) Execute() (*KalturaScheduleEvent, *http.Response, error) {
	return r.ApiService.ScheduleEventUpdateExecute(r)
}

/*
ScheduleEventUpdate Method for ScheduleEventUpdate

Update an existing KalturaScheduleEvent object

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiScheduleEventUpdateRequest
*/
func (a *ScheduleEventApiService) ScheduleEventUpdate(ctx context.Context) ApiScheduleEventUpdateRequest {
	return ApiScheduleEventUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaScheduleEvent
func (a *ScheduleEventApiService) ScheduleEventUpdateExecute(r ApiScheduleEventUpdateRequest) (*KalturaScheduleEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaScheduleEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduleEventApiService.ScheduleEventUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/schedule_scheduleevent/action/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiScheduleEventUpdateLiveFeatureRequest struct {
	ctx context.Context
	ApiService *ScheduleEventApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *ScheduleEventUpdateLiveFeatureRequest
}

func (r ApiScheduleEventUpdateLiveFeatureRequest) Ks(ks string) ApiScheduleEventUpdateLiveFeatureRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiScheduleEventUpdateLiveFeatureRequest) Format(format int32) ApiScheduleEventUpdateLiveFeatureRequest {
	r.format = &format
	return r
}

func (r ApiScheduleEventUpdateLiveFeatureRequest) ClientTag(clientTag string) ApiScheduleEventUpdateLiveFeatureRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiScheduleEventUpdateLiveFeatureRequest) PartnerId(partnerId int32) ApiScheduleEventUpdateLiveFeatureRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiScheduleEventUpdateLiveFeatureRequest) Body(body ScheduleEventUpdateLiveFeatureRequest) ApiScheduleEventUpdateLiveFeatureRequest {
	r.body = &body
	return r
}

func (r ApiScheduleEventUpdateLiveFeatureRequest) Execute() (*KalturaLiveStreamScheduleEvent, *http.Response, error) {
	return r.ApiService.ScheduleEventUpdateLiveFeatureExecute(r)
}

/*
ScheduleEventUpdateLiveFeature Method for ScheduleEventUpdateLiveFeature

Add feature to live event

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiScheduleEventUpdateLiveFeatureRequest
*/
func (a *ScheduleEventApiService) ScheduleEventUpdateLiveFeature(ctx context.Context) ApiScheduleEventUpdateLiveFeatureRequest {
	return ApiScheduleEventUpdateLiveFeatureRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaLiveStreamScheduleEvent
func (a *ScheduleEventApiService) ScheduleEventUpdateLiveFeatureExecute(r ApiScheduleEventUpdateLiveFeatureRequest) (*KalturaLiveStreamScheduleEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaLiveStreamScheduleEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ScheduleEventApiService.ScheduleEventUpdateLiveFeature")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/schedule_scheduleevent/action/updateLiveFeature"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
