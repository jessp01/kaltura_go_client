/*
Kaltura VPaaS

The Kaltura VPaaS API

API version: 18.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
)


// CategoryUserApiService CategoryUserApi service
type CategoryUserApiService service

type ApiCategoryUserActivateRequest struct {
	ctx context.Context
	ApiService *CategoryUserApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *CategoryUserActivateRequest
}

func (r ApiCategoryUserActivateRequest) Ks(ks string) ApiCategoryUserActivateRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiCategoryUserActivateRequest) Format(format int32) ApiCategoryUserActivateRequest {
	r.format = &format
	return r
}

func (r ApiCategoryUserActivateRequest) ClientTag(clientTag string) ApiCategoryUserActivateRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiCategoryUserActivateRequest) PartnerId(partnerId int32) ApiCategoryUserActivateRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiCategoryUserActivateRequest) Body(body CategoryUserActivateRequest) ApiCategoryUserActivateRequest {
	r.body = &body
	return r
}

func (r ApiCategoryUserActivateRequest) Execute() (*KalturaCategoryUser, *http.Response, error) {
	return r.ApiService.CategoryUserActivateExecute(r)
}

/*
CategoryUserActivate Method for CategoryUserActivate

activate CategoryUser

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCategoryUserActivateRequest
*/
func (a *CategoryUserApiService) CategoryUserActivate(ctx context.Context) ApiCategoryUserActivateRequest {
	return ApiCategoryUserActivateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaCategoryUser
func (a *CategoryUserApiService) CategoryUserActivateExecute(r ApiCategoryUserActivateRequest) (*KalturaCategoryUser, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaCategoryUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CategoryUserApiService.CategoryUserActivate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/categoryuser/action/activate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCategoryUserAddRequest struct {
	ctx context.Context
	ApiService *CategoryUserApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *CategoryUserAddRequest
}

func (r ApiCategoryUserAddRequest) Ks(ks string) ApiCategoryUserAddRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiCategoryUserAddRequest) Format(format int32) ApiCategoryUserAddRequest {
	r.format = &format
	return r
}

func (r ApiCategoryUserAddRequest) ClientTag(clientTag string) ApiCategoryUserAddRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiCategoryUserAddRequest) PartnerId(partnerId int32) ApiCategoryUserAddRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiCategoryUserAddRequest) Body(body CategoryUserAddRequest) ApiCategoryUserAddRequest {
	r.body = &body
	return r
}

func (r ApiCategoryUserAddRequest) Execute() (*KalturaCategoryUser, *http.Response, error) {
	return r.ApiService.CategoryUserAddExecute(r)
}

/*
CategoryUserAdd Method for CategoryUserAdd

Add new CategoryUser

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCategoryUserAddRequest
*/
func (a *CategoryUserApiService) CategoryUserAdd(ctx context.Context) ApiCategoryUserAddRequest {
	return ApiCategoryUserAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaCategoryUser
func (a *CategoryUserApiService) CategoryUserAddExecute(r ApiCategoryUserAddRequest) (*KalturaCategoryUser, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaCategoryUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CategoryUserApiService.CategoryUserAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/categoryuser/action/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCategoryUserAddFromBulkUploadRequest struct {
	ctx context.Context
	ApiService *CategoryUserApiService
	fileData **os.File
	ks *string
	format *int32
	bulkUploadDataObjectType *string
	bulkUploadDataFileName *string
	bulkUploadDataObjectDataObjectType *string
	bulkUploadDataEmailRecipients *string
	bulkUploadDataNumOfErrorObjects *int32
	bulkUploadDataPrivileges *string
	bulkUploadCategoryUserDataObjectType *string
}

func (r ApiCategoryUserAddFromBulkUploadRequest) FileData(fileData *os.File) ApiCategoryUserAddFromBulkUploadRequest {
	r.fileData = &fileData
	return r
}

func (r ApiCategoryUserAddFromBulkUploadRequest) Ks(ks string) ApiCategoryUserAddFromBulkUploadRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiCategoryUserAddFromBulkUploadRequest) Format(format int32) ApiCategoryUserAddFromBulkUploadRequest {
	r.format = &format
	return r
}

func (r ApiCategoryUserAddFromBulkUploadRequest) BulkUploadDataObjectType(bulkUploadDataObjectType string) ApiCategoryUserAddFromBulkUploadRequest {
	r.bulkUploadDataObjectType = &bulkUploadDataObjectType
	return r
}

// Friendly name of the file, used to be recognized later in the logs.
func (r ApiCategoryUserAddFromBulkUploadRequest) BulkUploadDataFileName(bulkUploadDataFileName string) ApiCategoryUserAddFromBulkUploadRequest {
	r.bulkUploadDataFileName = &bulkUploadDataFileName
	return r
}

func (r ApiCategoryUserAddFromBulkUploadRequest) BulkUploadDataObjectDataObjectType(bulkUploadDataObjectDataObjectType string) ApiCategoryUserAddFromBulkUploadRequest {
	r.bulkUploadDataObjectDataObjectType = &bulkUploadDataObjectDataObjectType
	return r
}

// Recipients of the email for bulk upload success/failure
func (r ApiCategoryUserAddFromBulkUploadRequest) BulkUploadDataEmailRecipients(bulkUploadDataEmailRecipients string) ApiCategoryUserAddFromBulkUploadRequest {
	r.bulkUploadDataEmailRecipients = &bulkUploadDataEmailRecipients
	return r
}

// Number of objects that finished on error status
func (r ApiCategoryUserAddFromBulkUploadRequest) BulkUploadDataNumOfErrorObjects(bulkUploadDataNumOfErrorObjects int32) ApiCategoryUserAddFromBulkUploadRequest {
	r.bulkUploadDataNumOfErrorObjects = &bulkUploadDataNumOfErrorObjects
	return r
}

// privileges for the job
func (r ApiCategoryUserAddFromBulkUploadRequest) BulkUploadDataPrivileges(bulkUploadDataPrivileges string) ApiCategoryUserAddFromBulkUploadRequest {
	r.bulkUploadDataPrivileges = &bulkUploadDataPrivileges
	return r
}

func (r ApiCategoryUserAddFromBulkUploadRequest) BulkUploadCategoryUserDataObjectType(bulkUploadCategoryUserDataObjectType string) ApiCategoryUserAddFromBulkUploadRequest {
	r.bulkUploadCategoryUserDataObjectType = &bulkUploadCategoryUserDataObjectType
	return r
}

func (r ApiCategoryUserAddFromBulkUploadRequest) Execute() (*KalturaBulkUpload, *http.Response, error) {
	return r.ApiService.CategoryUserAddFromBulkUploadExecute(r)
}

/*
CategoryUserAddFromBulkUpload Method for CategoryUserAddFromBulkUpload

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCategoryUserAddFromBulkUploadRequest
*/
func (a *CategoryUserApiService) CategoryUserAddFromBulkUpload(ctx context.Context) ApiCategoryUserAddFromBulkUploadRequest {
	return ApiCategoryUserAddFromBulkUploadRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBulkUpload
func (a *CategoryUserApiService) CategoryUserAddFromBulkUploadExecute(r ApiCategoryUserAddFromBulkUploadRequest) (*KalturaBulkUpload, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBulkUpload
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CategoryUserApiService.CategoryUserAddFromBulkUpload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/categoryuser/action/addFromBulkUpload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileData == nil {
		return localVarReturnValue, nil, reportError("fileData is required and must be specified")
	}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.bulkUploadDataObjectType != nil {
		localVarQueryParams.Add("bulkUploadData[objectType]", parameterToString(*r.bulkUploadDataObjectType, ""))
	}
	if r.bulkUploadDataFileName != nil {
		localVarQueryParams.Add("bulkUploadData[fileName]", parameterToString(*r.bulkUploadDataFileName, ""))
	}
	if r.bulkUploadDataObjectDataObjectType != nil {
		localVarQueryParams.Add("bulkUploadData[objectData][objectType]", parameterToString(*r.bulkUploadDataObjectDataObjectType, ""))
	}
	if r.bulkUploadDataEmailRecipients != nil {
		localVarQueryParams.Add("bulkUploadData[emailRecipients]", parameterToString(*r.bulkUploadDataEmailRecipients, ""))
	}
	if r.bulkUploadDataNumOfErrorObjects != nil {
		localVarQueryParams.Add("bulkUploadData[numOfErrorObjects]", parameterToString(*r.bulkUploadDataNumOfErrorObjects, ""))
	}
	if r.bulkUploadDataPrivileges != nil {
		localVarQueryParams.Add("bulkUploadData[privileges]", parameterToString(*r.bulkUploadDataPrivileges, ""))
	}
	if r.bulkUploadCategoryUserDataObjectType != nil {
		localVarQueryParams.Add("bulkUploadCategoryUserData[objectType]", parameterToString(*r.bulkUploadCategoryUserDataObjectType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileDataLocalVarFormFileName string
	var fileDataLocalVarFileName     string
	var fileDataLocalVarFileBytes    []byte

	fileDataLocalVarFormFileName = "fileData"

	fileDataLocalVarFile := *r.fileData
	if fileDataLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(fileDataLocalVarFile)
		fileDataLocalVarFileBytes = fbs
		fileDataLocalVarFileName = fileDataLocalVarFile.Name()
		fileDataLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: fileDataLocalVarFileBytes, fileName: fileDataLocalVarFileName, formFileName: fileDataLocalVarFormFileName})
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCategoryUserCopyFromCategoryRequest struct {
	ctx context.Context
	ApiService *CategoryUserApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *CategoryUserCopyFromCategoryRequest
}

func (r ApiCategoryUserCopyFromCategoryRequest) Ks(ks string) ApiCategoryUserCopyFromCategoryRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiCategoryUserCopyFromCategoryRequest) Format(format int32) ApiCategoryUserCopyFromCategoryRequest {
	r.format = &format
	return r
}

func (r ApiCategoryUserCopyFromCategoryRequest) ClientTag(clientTag string) ApiCategoryUserCopyFromCategoryRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiCategoryUserCopyFromCategoryRequest) PartnerId(partnerId int32) ApiCategoryUserCopyFromCategoryRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiCategoryUserCopyFromCategoryRequest) Body(body CategoryUserCopyFromCategoryRequest) ApiCategoryUserCopyFromCategoryRequest {
	r.body = &body
	return r
}

func (r ApiCategoryUserCopyFromCategoryRequest) Execute() (*http.Response, error) {
	return r.ApiService.CategoryUserCopyFromCategoryExecute(r)
}

/*
CategoryUserCopyFromCategory Method for CategoryUserCopyFromCategory

Copy all member from parent category

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCategoryUserCopyFromCategoryRequest
*/
func (a *CategoryUserApiService) CategoryUserCopyFromCategory(ctx context.Context) ApiCategoryUserCopyFromCategoryRequest {
	return ApiCategoryUserCopyFromCategoryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CategoryUserApiService) CategoryUserCopyFromCategoryExecute(r ApiCategoryUserCopyFromCategoryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CategoryUserApiService.CategoryUserCopyFromCategory")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/categoryuser/action/copyFromCategory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCategoryUserDeactivateRequest struct {
	ctx context.Context
	ApiService *CategoryUserApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *CategoryUserActivateRequest
}

func (r ApiCategoryUserDeactivateRequest) Ks(ks string) ApiCategoryUserDeactivateRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiCategoryUserDeactivateRequest) Format(format int32) ApiCategoryUserDeactivateRequest {
	r.format = &format
	return r
}

func (r ApiCategoryUserDeactivateRequest) ClientTag(clientTag string) ApiCategoryUserDeactivateRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiCategoryUserDeactivateRequest) PartnerId(partnerId int32) ApiCategoryUserDeactivateRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiCategoryUserDeactivateRequest) Body(body CategoryUserActivateRequest) ApiCategoryUserDeactivateRequest {
	r.body = &body
	return r
}

func (r ApiCategoryUserDeactivateRequest) Execute() (*KalturaCategoryUser, *http.Response, error) {
	return r.ApiService.CategoryUserDeactivateExecute(r)
}

/*
CategoryUserDeactivate Method for CategoryUserDeactivate

reject CategoryUser

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCategoryUserDeactivateRequest
*/
func (a *CategoryUserApiService) CategoryUserDeactivate(ctx context.Context) ApiCategoryUserDeactivateRequest {
	return ApiCategoryUserDeactivateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaCategoryUser
func (a *CategoryUserApiService) CategoryUserDeactivateExecute(r ApiCategoryUserDeactivateRequest) (*KalturaCategoryUser, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaCategoryUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CategoryUserApiService.CategoryUserDeactivate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/categoryuser/action/deactivate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCategoryUserDeleteRequest struct {
	ctx context.Context
	ApiService *CategoryUserApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *CategoryUserActivateRequest
}

func (r ApiCategoryUserDeleteRequest) Ks(ks string) ApiCategoryUserDeleteRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiCategoryUserDeleteRequest) Format(format int32) ApiCategoryUserDeleteRequest {
	r.format = &format
	return r
}

func (r ApiCategoryUserDeleteRequest) ClientTag(clientTag string) ApiCategoryUserDeleteRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiCategoryUserDeleteRequest) PartnerId(partnerId int32) ApiCategoryUserDeleteRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiCategoryUserDeleteRequest) Body(body CategoryUserActivateRequest) ApiCategoryUserDeleteRequest {
	r.body = &body
	return r
}

func (r ApiCategoryUserDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CategoryUserDeleteExecute(r)
}

/*
CategoryUserDelete Method for CategoryUserDelete

Delete a CategoryUser

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCategoryUserDeleteRequest
*/
func (a *CategoryUserApiService) CategoryUserDelete(ctx context.Context) ApiCategoryUserDeleteRequest {
	return ApiCategoryUserDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *CategoryUserApiService) CategoryUserDeleteExecute(r ApiCategoryUserDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CategoryUserApiService.CategoryUserDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/categoryuser/action/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCategoryUserGetRequest struct {
	ctx context.Context
	ApiService *CategoryUserApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *CategoryUserActivateRequest
}

func (r ApiCategoryUserGetRequest) Ks(ks string) ApiCategoryUserGetRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiCategoryUserGetRequest) Format(format int32) ApiCategoryUserGetRequest {
	r.format = &format
	return r
}

func (r ApiCategoryUserGetRequest) ClientTag(clientTag string) ApiCategoryUserGetRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiCategoryUserGetRequest) PartnerId(partnerId int32) ApiCategoryUserGetRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiCategoryUserGetRequest) Body(body CategoryUserActivateRequest) ApiCategoryUserGetRequest {
	r.body = &body
	return r
}

func (r ApiCategoryUserGetRequest) Execute() (*KalturaCategoryUser, *http.Response, error) {
	return r.ApiService.CategoryUserGetExecute(r)
}

/*
CategoryUserGet Method for CategoryUserGet

Get CategoryUser by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCategoryUserGetRequest
*/
func (a *CategoryUserApiService) CategoryUserGet(ctx context.Context) ApiCategoryUserGetRequest {
	return ApiCategoryUserGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaCategoryUser
func (a *CategoryUserApiService) CategoryUserGetExecute(r ApiCategoryUserGetRequest) (*KalturaCategoryUser, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaCategoryUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CategoryUserApiService.CategoryUserGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/categoryuser/action/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCategoryUserIndexRequest struct {
	ctx context.Context
	ApiService *CategoryUserApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *CategoryUserIndexRequest
}

func (r ApiCategoryUserIndexRequest) Ks(ks string) ApiCategoryUserIndexRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiCategoryUserIndexRequest) Format(format int32) ApiCategoryUserIndexRequest {
	r.format = &format
	return r
}

func (r ApiCategoryUserIndexRequest) ClientTag(clientTag string) ApiCategoryUserIndexRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiCategoryUserIndexRequest) PartnerId(partnerId int32) ApiCategoryUserIndexRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiCategoryUserIndexRequest) Body(body CategoryUserIndexRequest) ApiCategoryUserIndexRequest {
	r.body = &body
	return r
}

func (r ApiCategoryUserIndexRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.CategoryUserIndexExecute(r)
}

/*
CategoryUserIndex Method for CategoryUserIndex

Index CategoryUser by userid and category id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCategoryUserIndexRequest
*/
func (a *CategoryUserApiService) CategoryUserIndex(ctx context.Context) ApiCategoryUserIndexRequest {
	return ApiCategoryUserIndexRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return int32
func (a *CategoryUserApiService) CategoryUserIndexExecute(r ApiCategoryUserIndexRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CategoryUserApiService.CategoryUserIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/categoryuser/action/index"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCategoryUserListRequest struct {
	ctx context.Context
	ApiService *CategoryUserApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *CategoryUserListRequest
}

func (r ApiCategoryUserListRequest) Ks(ks string) ApiCategoryUserListRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiCategoryUserListRequest) Format(format int32) ApiCategoryUserListRequest {
	r.format = &format
	return r
}

func (r ApiCategoryUserListRequest) ClientTag(clientTag string) ApiCategoryUserListRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiCategoryUserListRequest) PartnerId(partnerId int32) ApiCategoryUserListRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiCategoryUserListRequest) Body(body CategoryUserListRequest) ApiCategoryUserListRequest {
	r.body = &body
	return r
}

func (r ApiCategoryUserListRequest) Execute() (*KalturaCategoryUserListResponse, *http.Response, error) {
	return r.ApiService.CategoryUserListExecute(r)
}

/*
CategoryUserList Method for CategoryUserList

List all categories

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCategoryUserListRequest
*/
func (a *CategoryUserApiService) CategoryUserList(ctx context.Context) ApiCategoryUserListRequest {
	return ApiCategoryUserListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaCategoryUserListResponse
func (a *CategoryUserApiService) CategoryUserListExecute(r ApiCategoryUserListRequest) (*KalturaCategoryUserListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaCategoryUserListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CategoryUserApiService.CategoryUserList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/categoryuser/action/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCategoryUserUpdateRequest struct {
	ctx context.Context
	ApiService *CategoryUserApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *CategoryUserUpdateRequest
}

func (r ApiCategoryUserUpdateRequest) Ks(ks string) ApiCategoryUserUpdateRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiCategoryUserUpdateRequest) Format(format int32) ApiCategoryUserUpdateRequest {
	r.format = &format
	return r
}

func (r ApiCategoryUserUpdateRequest) ClientTag(clientTag string) ApiCategoryUserUpdateRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiCategoryUserUpdateRequest) PartnerId(partnerId int32) ApiCategoryUserUpdateRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiCategoryUserUpdateRequest) Body(body CategoryUserUpdateRequest) ApiCategoryUserUpdateRequest {
	r.body = &body
	return r
}

func (r ApiCategoryUserUpdateRequest) Execute() (*KalturaCategoryUser, *http.Response, error) {
	return r.ApiService.CategoryUserUpdateExecute(r)
}

/*
CategoryUserUpdate Method for CategoryUserUpdate

Update CategoryUser by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCategoryUserUpdateRequest
*/
func (a *CategoryUserApiService) CategoryUserUpdate(ctx context.Context) ApiCategoryUserUpdateRequest {
	return ApiCategoryUserUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaCategoryUser
func (a *CategoryUserApiService) CategoryUserUpdateExecute(r ApiCategoryUserUpdateRequest) (*KalturaCategoryUser, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaCategoryUser
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CategoryUserApiService.CategoryUserUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/categoryuser/action/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
