/*
Kaltura VPaaS

The Kaltura VPaaS API

API version: 18.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// JobsApiService JobsApi service
type JobsApiService service

type ApiJobsAbortBulkUploadRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsAbortBulkUploadRequest) Ks(ks string) ApiJobsAbortBulkUploadRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsAbortBulkUploadRequest) Format(format int32) ApiJobsAbortBulkUploadRequest {
	r.format = &format
	return r
}

func (r ApiJobsAbortBulkUploadRequest) ClientTag(clientTag string) ApiJobsAbortBulkUploadRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsAbortBulkUploadRequest) PartnerId(partnerId int32) ApiJobsAbortBulkUploadRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsAbortBulkUploadRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsAbortBulkUploadRequest {
	r.body = &body
	return r
}

func (r ApiJobsAbortBulkUploadRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsAbortBulkUploadExecute(r)
}

/*
JobsAbortBulkUpload Method for JobsAbortBulkUpload

batch abortBulkUploadAction aborts and returns the status of bulk upload task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsAbortBulkUploadRequest
*/
func (a *JobsApiService) JobsAbortBulkUpload(ctx context.Context) ApiJobsAbortBulkUploadRequest {
	return ApiJobsAbortBulkUploadRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsAbortBulkUploadExecute(r ApiJobsAbortBulkUploadRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsAbortBulkUpload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/abortBulkUpload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsAbortCaptureThumbRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsAbortCaptureThumbRequest) Ks(ks string) ApiJobsAbortCaptureThumbRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsAbortCaptureThumbRequest) Format(format int32) ApiJobsAbortCaptureThumbRequest {
	r.format = &format
	return r
}

func (r ApiJobsAbortCaptureThumbRequest) ClientTag(clientTag string) ApiJobsAbortCaptureThumbRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsAbortCaptureThumbRequest) PartnerId(partnerId int32) ApiJobsAbortCaptureThumbRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsAbortCaptureThumbRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsAbortCaptureThumbRequest {
	r.body = &body
	return r
}

func (r ApiJobsAbortCaptureThumbRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsAbortCaptureThumbExecute(r)
}

/*
JobsAbortCaptureThumb Method for JobsAbortCaptureThumb

batch abortCaptureThumbAction aborts and returns the status of capture thumbnail task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsAbortCaptureThumbRequest
*/
func (a *JobsApiService) JobsAbortCaptureThumb(ctx context.Context) ApiJobsAbortCaptureThumbRequest {
	return ApiJobsAbortCaptureThumbRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsAbortCaptureThumbExecute(r ApiJobsAbortCaptureThumbRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsAbortCaptureThumb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/abortCaptureThumb"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsAbortConvertRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsAbortConvertRequest) Ks(ks string) ApiJobsAbortConvertRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsAbortConvertRequest) Format(format int32) ApiJobsAbortConvertRequest {
	r.format = &format
	return r
}

func (r ApiJobsAbortConvertRequest) ClientTag(clientTag string) ApiJobsAbortConvertRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsAbortConvertRequest) PartnerId(partnerId int32) ApiJobsAbortConvertRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsAbortConvertRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsAbortConvertRequest {
	r.body = &body
	return r
}

func (r ApiJobsAbortConvertRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsAbortConvertExecute(r)
}

/*
JobsAbortConvert Method for JobsAbortConvert

batch abortConvertAction aborts and returns the status of convert task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsAbortConvertRequest
*/
func (a *JobsApiService) JobsAbortConvert(ctx context.Context) ApiJobsAbortConvertRequest {
	return ApiJobsAbortConvertRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsAbortConvertExecute(r ApiJobsAbortConvertRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsAbortConvert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/abortConvert"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsAbortConvertCollectionRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsAbortConvertCollectionRequest) Ks(ks string) ApiJobsAbortConvertCollectionRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsAbortConvertCollectionRequest) Format(format int32) ApiJobsAbortConvertCollectionRequest {
	r.format = &format
	return r
}

func (r ApiJobsAbortConvertCollectionRequest) ClientTag(clientTag string) ApiJobsAbortConvertCollectionRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsAbortConvertCollectionRequest) PartnerId(partnerId int32) ApiJobsAbortConvertCollectionRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsAbortConvertCollectionRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsAbortConvertCollectionRequest {
	r.body = &body
	return r
}

func (r ApiJobsAbortConvertCollectionRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsAbortConvertCollectionExecute(r)
}

/*
JobsAbortConvertCollection Method for JobsAbortConvertCollection

batch abortConvertCollectionAction aborts and returns the status of convert profile task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsAbortConvertCollectionRequest
*/
func (a *JobsApiService) JobsAbortConvertCollection(ctx context.Context) ApiJobsAbortConvertCollectionRequest {
	return ApiJobsAbortConvertCollectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsAbortConvertCollectionExecute(r ApiJobsAbortConvertCollectionRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsAbortConvertCollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/abortConvertCollection"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsAbortConvertProfileRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsAbortConvertProfileRequest) Ks(ks string) ApiJobsAbortConvertProfileRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsAbortConvertProfileRequest) Format(format int32) ApiJobsAbortConvertProfileRequest {
	r.format = &format
	return r
}

func (r ApiJobsAbortConvertProfileRequest) ClientTag(clientTag string) ApiJobsAbortConvertProfileRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsAbortConvertProfileRequest) PartnerId(partnerId int32) ApiJobsAbortConvertProfileRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsAbortConvertProfileRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsAbortConvertProfileRequest {
	r.body = &body
	return r
}

func (r ApiJobsAbortConvertProfileRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsAbortConvertProfileExecute(r)
}

/*
JobsAbortConvertProfile Method for JobsAbortConvertProfile

batch abortConvertProfileAction aborts and returns the status of convert profile task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsAbortConvertProfileRequest
*/
func (a *JobsApiService) JobsAbortConvertProfile(ctx context.Context) ApiJobsAbortConvertProfileRequest {
	return ApiJobsAbortConvertProfileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsAbortConvertProfileExecute(r ApiJobsAbortConvertProfileRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsAbortConvertProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/abortConvertProfile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsAbortExtractMediaRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsAbortExtractMediaRequest) Ks(ks string) ApiJobsAbortExtractMediaRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsAbortExtractMediaRequest) Format(format int32) ApiJobsAbortExtractMediaRequest {
	r.format = &format
	return r
}

func (r ApiJobsAbortExtractMediaRequest) ClientTag(clientTag string) ApiJobsAbortExtractMediaRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsAbortExtractMediaRequest) PartnerId(partnerId int32) ApiJobsAbortExtractMediaRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsAbortExtractMediaRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsAbortExtractMediaRequest {
	r.body = &body
	return r
}

func (r ApiJobsAbortExtractMediaRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsAbortExtractMediaExecute(r)
}

/*
JobsAbortExtractMedia Method for JobsAbortExtractMedia

batch abortExtractMediaAction aborts and returns the status of extract media task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsAbortExtractMediaRequest
*/
func (a *JobsApiService) JobsAbortExtractMedia(ctx context.Context) ApiJobsAbortExtractMediaRequest {
	return ApiJobsAbortExtractMediaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsAbortExtractMediaExecute(r ApiJobsAbortExtractMediaRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsAbortExtractMedia")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/abortExtractMedia"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsAbortImportRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsAbortImportRequest) Ks(ks string) ApiJobsAbortImportRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsAbortImportRequest) Format(format int32) ApiJobsAbortImportRequest {
	r.format = &format
	return r
}

func (r ApiJobsAbortImportRequest) ClientTag(clientTag string) ApiJobsAbortImportRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsAbortImportRequest) PartnerId(partnerId int32) ApiJobsAbortImportRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsAbortImportRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsAbortImportRequest {
	r.body = &body
	return r
}

func (r ApiJobsAbortImportRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsAbortImportExecute(r)
}

/*
JobsAbortImport Method for JobsAbortImport

batch abortImportAction aborts and returns the status of import task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsAbortImportRequest
*/
func (a *JobsApiService) JobsAbortImport(ctx context.Context) ApiJobsAbortImportRequest {
	return ApiJobsAbortImportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsAbortImportExecute(r ApiJobsAbortImportRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsAbortImport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/abortImport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsAbortJobRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortJobRequest
}

func (r ApiJobsAbortJobRequest) Ks(ks string) ApiJobsAbortJobRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsAbortJobRequest) Format(format int32) ApiJobsAbortJobRequest {
	r.format = &format
	return r
}

func (r ApiJobsAbortJobRequest) ClientTag(clientTag string) ApiJobsAbortJobRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsAbortJobRequest) PartnerId(partnerId int32) ApiJobsAbortJobRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsAbortJobRequest) Body(body JobsAbortJobRequest) ApiJobsAbortJobRequest {
	r.body = &body
	return r
}

func (r ApiJobsAbortJobRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsAbortJobExecute(r)
}

/*
JobsAbortJob Method for JobsAbortJob

batch abortJobAction aborts and returns the status of task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsAbortJobRequest
*/
func (a *JobsApiService) JobsAbortJob(ctx context.Context) ApiJobsAbortJobRequest {
	return ApiJobsAbortJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsAbortJobExecute(r ApiJobsAbortJobRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsAbortJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/abortJob"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsAbortMailRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsAbortMailRequest) Ks(ks string) ApiJobsAbortMailRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsAbortMailRequest) Format(format int32) ApiJobsAbortMailRequest {
	r.format = &format
	return r
}

func (r ApiJobsAbortMailRequest) ClientTag(clientTag string) ApiJobsAbortMailRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsAbortMailRequest) PartnerId(partnerId int32) ApiJobsAbortMailRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsAbortMailRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsAbortMailRequest {
	r.body = &body
	return r
}

func (r ApiJobsAbortMailRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsAbortMailExecute(r)
}

/*
JobsAbortMail Method for JobsAbortMail

batch abortMailAction aborts and returns the status of mail task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsAbortMailRequest
*/
func (a *JobsApiService) JobsAbortMail(ctx context.Context) ApiJobsAbortMailRequest {
	return ApiJobsAbortMailRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsAbortMailExecute(r ApiJobsAbortMailRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsAbortMail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/abortMail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsAbortNotificationRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsAbortNotificationRequest) Ks(ks string) ApiJobsAbortNotificationRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsAbortNotificationRequest) Format(format int32) ApiJobsAbortNotificationRequest {
	r.format = &format
	return r
}

func (r ApiJobsAbortNotificationRequest) ClientTag(clientTag string) ApiJobsAbortNotificationRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsAbortNotificationRequest) PartnerId(partnerId int32) ApiJobsAbortNotificationRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsAbortNotificationRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsAbortNotificationRequest {
	r.body = &body
	return r
}

func (r ApiJobsAbortNotificationRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsAbortNotificationExecute(r)
}

/*
JobsAbortNotification Method for JobsAbortNotification

batch abortNotificationAction aborts and returns the status of notification task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsAbortNotificationRequest
*/
func (a *JobsApiService) JobsAbortNotification(ctx context.Context) ApiJobsAbortNotificationRequest {
	return ApiJobsAbortNotificationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsAbortNotificationExecute(r ApiJobsAbortNotificationRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsAbortNotification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/abortNotification"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsAbortPostConvertRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsAbortPostConvertRequest) Ks(ks string) ApiJobsAbortPostConvertRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsAbortPostConvertRequest) Format(format int32) ApiJobsAbortPostConvertRequest {
	r.format = &format
	return r
}

func (r ApiJobsAbortPostConvertRequest) ClientTag(clientTag string) ApiJobsAbortPostConvertRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsAbortPostConvertRequest) PartnerId(partnerId int32) ApiJobsAbortPostConvertRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsAbortPostConvertRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsAbortPostConvertRequest {
	r.body = &body
	return r
}

func (r ApiJobsAbortPostConvertRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsAbortPostConvertExecute(r)
}

/*
JobsAbortPostConvert Method for JobsAbortPostConvert

batch abortPostConvertAction aborts and returns the status of post convert task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsAbortPostConvertRequest
*/
func (a *JobsApiService) JobsAbortPostConvert(ctx context.Context) ApiJobsAbortPostConvertRequest {
	return ApiJobsAbortPostConvertRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsAbortPostConvertExecute(r ApiJobsAbortPostConvertRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsAbortPostConvert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/abortPostConvert"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsAbortProvisionDeleteRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsAbortProvisionDeleteRequest) Ks(ks string) ApiJobsAbortProvisionDeleteRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsAbortProvisionDeleteRequest) Format(format int32) ApiJobsAbortProvisionDeleteRequest {
	r.format = &format
	return r
}

func (r ApiJobsAbortProvisionDeleteRequest) ClientTag(clientTag string) ApiJobsAbortProvisionDeleteRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsAbortProvisionDeleteRequest) PartnerId(partnerId int32) ApiJobsAbortProvisionDeleteRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsAbortProvisionDeleteRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsAbortProvisionDeleteRequest {
	r.body = &body
	return r
}

func (r ApiJobsAbortProvisionDeleteRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsAbortProvisionDeleteExecute(r)
}

/*
JobsAbortProvisionDelete Method for JobsAbortProvisionDelete

batch abortProvisionDeleteAction aborts and returns the status of ProvisionDelete task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsAbortProvisionDeleteRequest
*/
func (a *JobsApiService) JobsAbortProvisionDelete(ctx context.Context) ApiJobsAbortProvisionDeleteRequest {
	return ApiJobsAbortProvisionDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsAbortProvisionDeleteExecute(r ApiJobsAbortProvisionDeleteRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsAbortProvisionDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/abortProvisionDelete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsAbortProvisionProvideRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsAbortProvisionProvideRequest) Ks(ks string) ApiJobsAbortProvisionProvideRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsAbortProvisionProvideRequest) Format(format int32) ApiJobsAbortProvisionProvideRequest {
	r.format = &format
	return r
}

func (r ApiJobsAbortProvisionProvideRequest) ClientTag(clientTag string) ApiJobsAbortProvisionProvideRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsAbortProvisionProvideRequest) PartnerId(partnerId int32) ApiJobsAbortProvisionProvideRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsAbortProvisionProvideRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsAbortProvisionProvideRequest {
	r.body = &body
	return r
}

func (r ApiJobsAbortProvisionProvideRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsAbortProvisionProvideExecute(r)
}

/*
JobsAbortProvisionProvide Method for JobsAbortProvisionProvide

batch abortProvisionProvideAction aborts and returns the status of ProvisionProvide task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsAbortProvisionProvideRequest
*/
func (a *JobsApiService) JobsAbortProvisionProvide(ctx context.Context) ApiJobsAbortProvisionProvideRequest {
	return ApiJobsAbortProvisionProvideRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsAbortProvisionProvideExecute(r ApiJobsAbortProvisionProvideRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsAbortProvisionProvide")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/abortProvisionProvide"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsAbortStorageDeleteRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsAbortStorageDeleteRequest) Ks(ks string) ApiJobsAbortStorageDeleteRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsAbortStorageDeleteRequest) Format(format int32) ApiJobsAbortStorageDeleteRequest {
	r.format = &format
	return r
}

func (r ApiJobsAbortStorageDeleteRequest) ClientTag(clientTag string) ApiJobsAbortStorageDeleteRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsAbortStorageDeleteRequest) PartnerId(partnerId int32) ApiJobsAbortStorageDeleteRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsAbortStorageDeleteRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsAbortStorageDeleteRequest {
	r.body = &body
	return r
}

func (r ApiJobsAbortStorageDeleteRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsAbortStorageDeleteExecute(r)
}

/*
JobsAbortStorageDelete Method for JobsAbortStorageDelete

batch abortStorageDeleteAction aborts and returns the status of export task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsAbortStorageDeleteRequest
*/
func (a *JobsApiService) JobsAbortStorageDelete(ctx context.Context) ApiJobsAbortStorageDeleteRequest {
	return ApiJobsAbortStorageDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsAbortStorageDeleteExecute(r ApiJobsAbortStorageDeleteRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsAbortStorageDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/abortStorageDelete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsAbortStorageExportRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsAbortStorageExportRequest) Ks(ks string) ApiJobsAbortStorageExportRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsAbortStorageExportRequest) Format(format int32) ApiJobsAbortStorageExportRequest {
	r.format = &format
	return r
}

func (r ApiJobsAbortStorageExportRequest) ClientTag(clientTag string) ApiJobsAbortStorageExportRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsAbortStorageExportRequest) PartnerId(partnerId int32) ApiJobsAbortStorageExportRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsAbortStorageExportRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsAbortStorageExportRequest {
	r.body = &body
	return r
}

func (r ApiJobsAbortStorageExportRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsAbortStorageExportExecute(r)
}

/*
JobsAbortStorageExport Method for JobsAbortStorageExport

batch abortStorageExportAction aborts and returns the status of export task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsAbortStorageExportRequest
*/
func (a *JobsApiService) JobsAbortStorageExport(ctx context.Context) ApiJobsAbortStorageExportRequest {
	return ApiJobsAbortStorageExportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsAbortStorageExportExecute(r ApiJobsAbortStorageExportRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsAbortStorageExport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/abortStorageExport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsAddBatchJobRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAddBatchJobRequest
}

func (r ApiJobsAddBatchJobRequest) Ks(ks string) ApiJobsAddBatchJobRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsAddBatchJobRequest) Format(format int32) ApiJobsAddBatchJobRequest {
	r.format = &format
	return r
}

func (r ApiJobsAddBatchJobRequest) ClientTag(clientTag string) ApiJobsAddBatchJobRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsAddBatchJobRequest) PartnerId(partnerId int32) ApiJobsAddBatchJobRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsAddBatchJobRequest) Body(body JobsAddBatchJobRequest) ApiJobsAddBatchJobRequest {
	r.body = &body
	return r
}

func (r ApiJobsAddBatchJobRequest) Execute() (*KalturaBatchJob, *http.Response, error) {
	return r.ApiService.JobsAddBatchJobExecute(r)
}

/*
JobsAddBatchJob Method for JobsAddBatchJob

batch addBatchJob action allows to add a generic BatchJob

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsAddBatchJobRequest
*/
func (a *JobsApiService) JobsAddBatchJob(ctx context.Context) ApiJobsAddBatchJobRequest {
	return ApiJobsAddBatchJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJob
func (a *JobsApiService) JobsAddBatchJobExecute(r ApiJobsAddBatchJobRequest) (*KalturaBatchJob, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJob
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsAddBatchJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/addBatchJob"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsAddConvertProfileJobRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryApproveRequest
}

func (r ApiJobsAddConvertProfileJobRequest) Ks(ks string) ApiJobsAddConvertProfileJobRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsAddConvertProfileJobRequest) Format(format int32) ApiJobsAddConvertProfileJobRequest {
	r.format = &format
	return r
}

func (r ApiJobsAddConvertProfileJobRequest) ClientTag(clientTag string) ApiJobsAddConvertProfileJobRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsAddConvertProfileJobRequest) PartnerId(partnerId int32) ApiJobsAddConvertProfileJobRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsAddConvertProfileJobRequest) Body(body BaseEntryApproveRequest) ApiJobsAddConvertProfileJobRequest {
	r.body = &body
	return r
}

func (r ApiJobsAddConvertProfileJobRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsAddConvertProfileJobExecute(r)
}

/*
JobsAddConvertProfileJob Method for JobsAddConvertProfileJob

batch addConvertProfileJobAction creates a new convert profile job

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsAddConvertProfileJobRequest
*/
func (a *JobsApiService) JobsAddConvertProfileJob(ctx context.Context) ApiJobsAddConvertProfileJobRequest {
	return ApiJobsAddConvertProfileJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsAddConvertProfileJobExecute(r ApiJobsAddConvertProfileJobRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsAddConvertProfileJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/addConvertProfileJob"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsAddMailJobRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAddMailJobRequest
}

func (r ApiJobsAddMailJobRequest) Ks(ks string) ApiJobsAddMailJobRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsAddMailJobRequest) Format(format int32) ApiJobsAddMailJobRequest {
	r.format = &format
	return r
}

func (r ApiJobsAddMailJobRequest) ClientTag(clientTag string) ApiJobsAddMailJobRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsAddMailJobRequest) PartnerId(partnerId int32) ApiJobsAddMailJobRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsAddMailJobRequest) Body(body JobsAddMailJobRequest) ApiJobsAddMailJobRequest {
	r.body = &body
	return r
}

func (r ApiJobsAddMailJobRequest) Execute() (*http.Response, error) {
	return r.ApiService.JobsAddMailJobExecute(r)
}

/*
JobsAddMailJob Method for JobsAddMailJob

Adds new mail job

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsAddMailJobRequest
*/
func (a *JobsApiService) JobsAddMailJob(ctx context.Context) ApiJobsAddMailJobRequest {
	return ApiJobsAddMailJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *JobsApiService) JobsAddMailJobExecute(r ApiJobsAddMailJobRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsAddMailJob")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/addMailJob"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobsBoostEntryJobsRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryApproveRequest
}

func (r ApiJobsBoostEntryJobsRequest) Ks(ks string) ApiJobsBoostEntryJobsRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsBoostEntryJobsRequest) Format(format int32) ApiJobsBoostEntryJobsRequest {
	r.format = &format
	return r
}

func (r ApiJobsBoostEntryJobsRequest) ClientTag(clientTag string) ApiJobsBoostEntryJobsRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsBoostEntryJobsRequest) PartnerId(partnerId int32) ApiJobsBoostEntryJobsRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsBoostEntryJobsRequest) Body(body BaseEntryApproveRequest) ApiJobsBoostEntryJobsRequest {
	r.body = &body
	return r
}

func (r ApiJobsBoostEntryJobsRequest) Execute() (*http.Response, error) {
	return r.ApiService.JobsBoostEntryJobsExecute(r)
}

/*
JobsBoostEntryJobs Method for JobsBoostEntryJobs

batch boostEntryJobsAction boosts all the jobs associated with the entry

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsBoostEntryJobsRequest
*/
func (a *JobsApiService) JobsBoostEntryJobs(ctx context.Context) ApiJobsBoostEntryJobsRequest {
	return ApiJobsBoostEntryJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *JobsApiService) JobsBoostEntryJobsExecute(r ApiJobsBoostEntryJobsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsBoostEntryJobs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/boostEntryJobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiJobsDeleteBulkUploadRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsDeleteBulkUploadRequest) Ks(ks string) ApiJobsDeleteBulkUploadRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsDeleteBulkUploadRequest) Format(format int32) ApiJobsDeleteBulkUploadRequest {
	r.format = &format
	return r
}

func (r ApiJobsDeleteBulkUploadRequest) ClientTag(clientTag string) ApiJobsDeleteBulkUploadRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsDeleteBulkUploadRequest) PartnerId(partnerId int32) ApiJobsDeleteBulkUploadRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsDeleteBulkUploadRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsDeleteBulkUploadRequest {
	r.body = &body
	return r
}

func (r ApiJobsDeleteBulkUploadRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsDeleteBulkUploadExecute(r)
}

/*
JobsDeleteBulkUpload Method for JobsDeleteBulkUpload

batch deleteBulkUploadAction deletes and returns the status of bulk upload task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsDeleteBulkUploadRequest
*/
func (a *JobsApiService) JobsDeleteBulkUpload(ctx context.Context) ApiJobsDeleteBulkUploadRequest {
	return ApiJobsDeleteBulkUploadRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsDeleteBulkUploadExecute(r ApiJobsDeleteBulkUploadRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsDeleteBulkUpload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/deleteBulkUpload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsDeleteCaptureThumbRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsDeleteCaptureThumbRequest) Ks(ks string) ApiJobsDeleteCaptureThumbRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsDeleteCaptureThumbRequest) Format(format int32) ApiJobsDeleteCaptureThumbRequest {
	r.format = &format
	return r
}

func (r ApiJobsDeleteCaptureThumbRequest) ClientTag(clientTag string) ApiJobsDeleteCaptureThumbRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsDeleteCaptureThumbRequest) PartnerId(partnerId int32) ApiJobsDeleteCaptureThumbRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsDeleteCaptureThumbRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsDeleteCaptureThumbRequest {
	r.body = &body
	return r
}

func (r ApiJobsDeleteCaptureThumbRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsDeleteCaptureThumbExecute(r)
}

/*
JobsDeleteCaptureThumb Method for JobsDeleteCaptureThumb

batch deleteCaptureThumbAction deletes and returns the status of capture thumbnail task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsDeleteCaptureThumbRequest
*/
func (a *JobsApiService) JobsDeleteCaptureThumb(ctx context.Context) ApiJobsDeleteCaptureThumbRequest {
	return ApiJobsDeleteCaptureThumbRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsDeleteCaptureThumbExecute(r ApiJobsDeleteCaptureThumbRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsDeleteCaptureThumb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/deleteCaptureThumb"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsDeleteConvertRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsDeleteConvertRequest) Ks(ks string) ApiJobsDeleteConvertRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsDeleteConvertRequest) Format(format int32) ApiJobsDeleteConvertRequest {
	r.format = &format
	return r
}

func (r ApiJobsDeleteConvertRequest) ClientTag(clientTag string) ApiJobsDeleteConvertRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsDeleteConvertRequest) PartnerId(partnerId int32) ApiJobsDeleteConvertRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsDeleteConvertRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsDeleteConvertRequest {
	r.body = &body
	return r
}

func (r ApiJobsDeleteConvertRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsDeleteConvertExecute(r)
}

/*
JobsDeleteConvert Method for JobsDeleteConvert

batch deleteConvertAction deletes and returns the status of convert task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsDeleteConvertRequest
*/
func (a *JobsApiService) JobsDeleteConvert(ctx context.Context) ApiJobsDeleteConvertRequest {
	return ApiJobsDeleteConvertRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsDeleteConvertExecute(r ApiJobsDeleteConvertRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsDeleteConvert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/deleteConvert"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsDeleteConvertCollectionRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsDeleteConvertCollectionRequest) Ks(ks string) ApiJobsDeleteConvertCollectionRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsDeleteConvertCollectionRequest) Format(format int32) ApiJobsDeleteConvertCollectionRequest {
	r.format = &format
	return r
}

func (r ApiJobsDeleteConvertCollectionRequest) ClientTag(clientTag string) ApiJobsDeleteConvertCollectionRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsDeleteConvertCollectionRequest) PartnerId(partnerId int32) ApiJobsDeleteConvertCollectionRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsDeleteConvertCollectionRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsDeleteConvertCollectionRequest {
	r.body = &body
	return r
}

func (r ApiJobsDeleteConvertCollectionRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsDeleteConvertCollectionExecute(r)
}

/*
JobsDeleteConvertCollection Method for JobsDeleteConvertCollection

batch deleteConvertCollectionAction deletes and returns the status of convert profile task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsDeleteConvertCollectionRequest
*/
func (a *JobsApiService) JobsDeleteConvertCollection(ctx context.Context) ApiJobsDeleteConvertCollectionRequest {
	return ApiJobsDeleteConvertCollectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsDeleteConvertCollectionExecute(r ApiJobsDeleteConvertCollectionRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsDeleteConvertCollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/deleteConvertCollection"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsDeleteConvertProfileRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsDeleteConvertProfileRequest) Ks(ks string) ApiJobsDeleteConvertProfileRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsDeleteConvertProfileRequest) Format(format int32) ApiJobsDeleteConvertProfileRequest {
	r.format = &format
	return r
}

func (r ApiJobsDeleteConvertProfileRequest) ClientTag(clientTag string) ApiJobsDeleteConvertProfileRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsDeleteConvertProfileRequest) PartnerId(partnerId int32) ApiJobsDeleteConvertProfileRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsDeleteConvertProfileRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsDeleteConvertProfileRequest {
	r.body = &body
	return r
}

func (r ApiJobsDeleteConvertProfileRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsDeleteConvertProfileExecute(r)
}

/*
JobsDeleteConvertProfile Method for JobsDeleteConvertProfile

batch deleteConvertProfileAction deletes and returns the status of convert profile task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsDeleteConvertProfileRequest
*/
func (a *JobsApiService) JobsDeleteConvertProfile(ctx context.Context) ApiJobsDeleteConvertProfileRequest {
	return ApiJobsDeleteConvertProfileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsDeleteConvertProfileExecute(r ApiJobsDeleteConvertProfileRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsDeleteConvertProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/deleteConvertProfile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsDeleteExtractMediaRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsDeleteExtractMediaRequest) Ks(ks string) ApiJobsDeleteExtractMediaRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsDeleteExtractMediaRequest) Format(format int32) ApiJobsDeleteExtractMediaRequest {
	r.format = &format
	return r
}

func (r ApiJobsDeleteExtractMediaRequest) ClientTag(clientTag string) ApiJobsDeleteExtractMediaRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsDeleteExtractMediaRequest) PartnerId(partnerId int32) ApiJobsDeleteExtractMediaRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsDeleteExtractMediaRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsDeleteExtractMediaRequest {
	r.body = &body
	return r
}

func (r ApiJobsDeleteExtractMediaRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsDeleteExtractMediaExecute(r)
}

/*
JobsDeleteExtractMedia Method for JobsDeleteExtractMedia

batch deleteExtractMediaAction deletes and returns the status of extract media task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsDeleteExtractMediaRequest
*/
func (a *JobsApiService) JobsDeleteExtractMedia(ctx context.Context) ApiJobsDeleteExtractMediaRequest {
	return ApiJobsDeleteExtractMediaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsDeleteExtractMediaExecute(r ApiJobsDeleteExtractMediaRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsDeleteExtractMedia")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/deleteExtractMedia"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsDeleteImportRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsDeleteImportRequest) Ks(ks string) ApiJobsDeleteImportRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsDeleteImportRequest) Format(format int32) ApiJobsDeleteImportRequest {
	r.format = &format
	return r
}

func (r ApiJobsDeleteImportRequest) ClientTag(clientTag string) ApiJobsDeleteImportRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsDeleteImportRequest) PartnerId(partnerId int32) ApiJobsDeleteImportRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsDeleteImportRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsDeleteImportRequest {
	r.body = &body
	return r
}

func (r ApiJobsDeleteImportRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsDeleteImportExecute(r)
}

/*
JobsDeleteImport Method for JobsDeleteImport

batch deleteImportAction deletes and returns the status of import task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsDeleteImportRequest
*/
func (a *JobsApiService) JobsDeleteImport(ctx context.Context) ApiJobsDeleteImportRequest {
	return ApiJobsDeleteImportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsDeleteImportExecute(r ApiJobsDeleteImportRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsDeleteImport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/deleteImport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsDeleteJobRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortJobRequest
}

func (r ApiJobsDeleteJobRequest) Ks(ks string) ApiJobsDeleteJobRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsDeleteJobRequest) Format(format int32) ApiJobsDeleteJobRequest {
	r.format = &format
	return r
}

func (r ApiJobsDeleteJobRequest) ClientTag(clientTag string) ApiJobsDeleteJobRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsDeleteJobRequest) PartnerId(partnerId int32) ApiJobsDeleteJobRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsDeleteJobRequest) Body(body JobsAbortJobRequest) ApiJobsDeleteJobRequest {
	r.body = &body
	return r
}

func (r ApiJobsDeleteJobRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsDeleteJobExecute(r)
}

/*
JobsDeleteJob Method for JobsDeleteJob

batch deleteJobAction deletes and returns the status of task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsDeleteJobRequest
*/
func (a *JobsApiService) JobsDeleteJob(ctx context.Context) ApiJobsDeleteJobRequest {
	return ApiJobsDeleteJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsDeleteJobExecute(r ApiJobsDeleteJobRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsDeleteJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/deleteJob"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsDeleteMailRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsDeleteMailRequest) Ks(ks string) ApiJobsDeleteMailRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsDeleteMailRequest) Format(format int32) ApiJobsDeleteMailRequest {
	r.format = &format
	return r
}

func (r ApiJobsDeleteMailRequest) ClientTag(clientTag string) ApiJobsDeleteMailRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsDeleteMailRequest) PartnerId(partnerId int32) ApiJobsDeleteMailRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsDeleteMailRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsDeleteMailRequest {
	r.body = &body
	return r
}

func (r ApiJobsDeleteMailRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsDeleteMailExecute(r)
}

/*
JobsDeleteMail Method for JobsDeleteMail

batch deleteMailAction deletes and returns the status of mail task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsDeleteMailRequest
*/
func (a *JobsApiService) JobsDeleteMail(ctx context.Context) ApiJobsDeleteMailRequest {
	return ApiJobsDeleteMailRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsDeleteMailExecute(r ApiJobsDeleteMailRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsDeleteMail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/deleteMail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsDeleteNotificationRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsDeleteNotificationRequest) Ks(ks string) ApiJobsDeleteNotificationRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsDeleteNotificationRequest) Format(format int32) ApiJobsDeleteNotificationRequest {
	r.format = &format
	return r
}

func (r ApiJobsDeleteNotificationRequest) ClientTag(clientTag string) ApiJobsDeleteNotificationRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsDeleteNotificationRequest) PartnerId(partnerId int32) ApiJobsDeleteNotificationRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsDeleteNotificationRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsDeleteNotificationRequest {
	r.body = &body
	return r
}

func (r ApiJobsDeleteNotificationRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsDeleteNotificationExecute(r)
}

/*
JobsDeleteNotification Method for JobsDeleteNotification

batch deleteNotificationAction deletes and returns the status of notification task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsDeleteNotificationRequest
*/
func (a *JobsApiService) JobsDeleteNotification(ctx context.Context) ApiJobsDeleteNotificationRequest {
	return ApiJobsDeleteNotificationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsDeleteNotificationExecute(r ApiJobsDeleteNotificationRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsDeleteNotification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/deleteNotification"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsDeletePostConvertRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsDeletePostConvertRequest) Ks(ks string) ApiJobsDeletePostConvertRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsDeletePostConvertRequest) Format(format int32) ApiJobsDeletePostConvertRequest {
	r.format = &format
	return r
}

func (r ApiJobsDeletePostConvertRequest) ClientTag(clientTag string) ApiJobsDeletePostConvertRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsDeletePostConvertRequest) PartnerId(partnerId int32) ApiJobsDeletePostConvertRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsDeletePostConvertRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsDeletePostConvertRequest {
	r.body = &body
	return r
}

func (r ApiJobsDeletePostConvertRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsDeletePostConvertExecute(r)
}

/*
JobsDeletePostConvert Method for JobsDeletePostConvert

batch deletePostConvertAction deletes and returns the status of post convert task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsDeletePostConvertRequest
*/
func (a *JobsApiService) JobsDeletePostConvert(ctx context.Context) ApiJobsDeletePostConvertRequest {
	return ApiJobsDeletePostConvertRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsDeletePostConvertExecute(r ApiJobsDeletePostConvertRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsDeletePostConvert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/deletePostConvert"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsDeleteProvisionDeleteRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsDeleteProvisionDeleteRequest) Ks(ks string) ApiJobsDeleteProvisionDeleteRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsDeleteProvisionDeleteRequest) Format(format int32) ApiJobsDeleteProvisionDeleteRequest {
	r.format = &format
	return r
}

func (r ApiJobsDeleteProvisionDeleteRequest) ClientTag(clientTag string) ApiJobsDeleteProvisionDeleteRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsDeleteProvisionDeleteRequest) PartnerId(partnerId int32) ApiJobsDeleteProvisionDeleteRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsDeleteProvisionDeleteRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsDeleteProvisionDeleteRequest {
	r.body = &body
	return r
}

func (r ApiJobsDeleteProvisionDeleteRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsDeleteProvisionDeleteExecute(r)
}

/*
JobsDeleteProvisionDelete Method for JobsDeleteProvisionDelete

batch deleteProvisionDeleteAction deletes and returns the status of ProvisionDelete task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsDeleteProvisionDeleteRequest
*/
func (a *JobsApiService) JobsDeleteProvisionDelete(ctx context.Context) ApiJobsDeleteProvisionDeleteRequest {
	return ApiJobsDeleteProvisionDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsDeleteProvisionDeleteExecute(r ApiJobsDeleteProvisionDeleteRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsDeleteProvisionDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/deleteProvisionDelete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsDeleteProvisionProvideRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsDeleteProvisionProvideRequest) Ks(ks string) ApiJobsDeleteProvisionProvideRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsDeleteProvisionProvideRequest) Format(format int32) ApiJobsDeleteProvisionProvideRequest {
	r.format = &format
	return r
}

func (r ApiJobsDeleteProvisionProvideRequest) ClientTag(clientTag string) ApiJobsDeleteProvisionProvideRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsDeleteProvisionProvideRequest) PartnerId(partnerId int32) ApiJobsDeleteProvisionProvideRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsDeleteProvisionProvideRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsDeleteProvisionProvideRequest {
	r.body = &body
	return r
}

func (r ApiJobsDeleteProvisionProvideRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsDeleteProvisionProvideExecute(r)
}

/*
JobsDeleteProvisionProvide Method for JobsDeleteProvisionProvide

batch deleteProvisionProvideAction deletes and returns the status of ProvisionProvide task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsDeleteProvisionProvideRequest
*/
func (a *JobsApiService) JobsDeleteProvisionProvide(ctx context.Context) ApiJobsDeleteProvisionProvideRequest {
	return ApiJobsDeleteProvisionProvideRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsDeleteProvisionProvideExecute(r ApiJobsDeleteProvisionProvideRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsDeleteProvisionProvide")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/deleteProvisionProvide"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsDeleteStorageDeleteRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsDeleteStorageDeleteRequest) Ks(ks string) ApiJobsDeleteStorageDeleteRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsDeleteStorageDeleteRequest) Format(format int32) ApiJobsDeleteStorageDeleteRequest {
	r.format = &format
	return r
}

func (r ApiJobsDeleteStorageDeleteRequest) ClientTag(clientTag string) ApiJobsDeleteStorageDeleteRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsDeleteStorageDeleteRequest) PartnerId(partnerId int32) ApiJobsDeleteStorageDeleteRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsDeleteStorageDeleteRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsDeleteStorageDeleteRequest {
	r.body = &body
	return r
}

func (r ApiJobsDeleteStorageDeleteRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsDeleteStorageDeleteExecute(r)
}

/*
JobsDeleteStorageDelete Method for JobsDeleteStorageDelete

batch deleteStorageDeleteAction deletes and returns the status of export task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsDeleteStorageDeleteRequest
*/
func (a *JobsApiService) JobsDeleteStorageDelete(ctx context.Context) ApiJobsDeleteStorageDeleteRequest {
	return ApiJobsDeleteStorageDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsDeleteStorageDeleteExecute(r ApiJobsDeleteStorageDeleteRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsDeleteStorageDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/deleteStorageDelete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsDeleteStorageExportRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsDeleteStorageExportRequest) Ks(ks string) ApiJobsDeleteStorageExportRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsDeleteStorageExportRequest) Format(format int32) ApiJobsDeleteStorageExportRequest {
	r.format = &format
	return r
}

func (r ApiJobsDeleteStorageExportRequest) ClientTag(clientTag string) ApiJobsDeleteStorageExportRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsDeleteStorageExportRequest) PartnerId(partnerId int32) ApiJobsDeleteStorageExportRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsDeleteStorageExportRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsDeleteStorageExportRequest {
	r.body = &body
	return r
}

func (r ApiJobsDeleteStorageExportRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsDeleteStorageExportExecute(r)
}

/*
JobsDeleteStorageExport Method for JobsDeleteStorageExport

batch deleteStorageExportAction deletes and returns the status of export task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsDeleteStorageExportRequest
*/
func (a *JobsApiService) JobsDeleteStorageExport(ctx context.Context) ApiJobsDeleteStorageExportRequest {
	return ApiJobsDeleteStorageExportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsDeleteStorageExportExecute(r ApiJobsDeleteStorageExportRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsDeleteStorageExport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/deleteStorageExport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsGetBulkUploadStatusRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsGetBulkUploadStatusRequest) Ks(ks string) ApiJobsGetBulkUploadStatusRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsGetBulkUploadStatusRequest) Format(format int32) ApiJobsGetBulkUploadStatusRequest {
	r.format = &format
	return r
}

func (r ApiJobsGetBulkUploadStatusRequest) ClientTag(clientTag string) ApiJobsGetBulkUploadStatusRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsGetBulkUploadStatusRequest) PartnerId(partnerId int32) ApiJobsGetBulkUploadStatusRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsGetBulkUploadStatusRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsGetBulkUploadStatusRequest {
	r.body = &body
	return r
}

func (r ApiJobsGetBulkUploadStatusRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsGetBulkUploadStatusExecute(r)
}

/*
JobsGetBulkUploadStatus Method for JobsGetBulkUploadStatus

// --------------------------------- ProvisionDeleteJob functions 	--------------------------------- //

// --------------------------------- BulkUploadJob functions 	--------------------------------- //

/batch getBulkUploadStatusAction returns the status of bulk upload task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsGetBulkUploadStatusRequest
*/
func (a *JobsApiService) JobsGetBulkUploadStatus(ctx context.Context) ApiJobsGetBulkUploadStatusRequest {
	return ApiJobsGetBulkUploadStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsGetBulkUploadStatusExecute(r ApiJobsGetBulkUploadStatusRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsGetBulkUploadStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/getBulkUploadStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsGetCaptureThumbStatusRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsGetCaptureThumbStatusRequest) Ks(ks string) ApiJobsGetCaptureThumbStatusRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsGetCaptureThumbStatusRequest) Format(format int32) ApiJobsGetCaptureThumbStatusRequest {
	r.format = &format
	return r
}

func (r ApiJobsGetCaptureThumbStatusRequest) ClientTag(clientTag string) ApiJobsGetCaptureThumbStatusRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsGetCaptureThumbStatusRequest) PartnerId(partnerId int32) ApiJobsGetCaptureThumbStatusRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsGetCaptureThumbStatusRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsGetCaptureThumbStatusRequest {
	r.body = &body
	return r
}

func (r ApiJobsGetCaptureThumbStatusRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsGetCaptureThumbStatusExecute(r)
}

/*
JobsGetCaptureThumbStatus Method for JobsGetCaptureThumbStatus

batch getCaptureThumbStatusAction returns the status of capture thumbnail task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsGetCaptureThumbStatusRequest
*/
func (a *JobsApiService) JobsGetCaptureThumbStatus(ctx context.Context) ApiJobsGetCaptureThumbStatusRequest {
	return ApiJobsGetCaptureThumbStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsGetCaptureThumbStatusExecute(r ApiJobsGetCaptureThumbStatusRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsGetCaptureThumbStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/getCaptureThumbStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsGetConvertCollectionStatusRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsGetConvertCollectionStatusRequest) Ks(ks string) ApiJobsGetConvertCollectionStatusRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsGetConvertCollectionStatusRequest) Format(format int32) ApiJobsGetConvertCollectionStatusRequest {
	r.format = &format
	return r
}

func (r ApiJobsGetConvertCollectionStatusRequest) ClientTag(clientTag string) ApiJobsGetConvertCollectionStatusRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsGetConvertCollectionStatusRequest) PartnerId(partnerId int32) ApiJobsGetConvertCollectionStatusRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsGetConvertCollectionStatusRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsGetConvertCollectionStatusRequest {
	r.body = &body
	return r
}

func (r ApiJobsGetConvertCollectionStatusRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsGetConvertCollectionStatusExecute(r)
}

/*
JobsGetConvertCollectionStatus Method for JobsGetConvertCollectionStatus

batch getConvertCollectionStatusAction returns the status of convert task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsGetConvertCollectionStatusRequest
*/
func (a *JobsApiService) JobsGetConvertCollectionStatus(ctx context.Context) ApiJobsGetConvertCollectionStatusRequest {
	return ApiJobsGetConvertCollectionStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsGetConvertCollectionStatusExecute(r ApiJobsGetConvertCollectionStatusRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsGetConvertCollectionStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/getConvertCollectionStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsGetConvertProfileStatusRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsGetConvertProfileStatusRequest) Ks(ks string) ApiJobsGetConvertProfileStatusRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsGetConvertProfileStatusRequest) Format(format int32) ApiJobsGetConvertProfileStatusRequest {
	r.format = &format
	return r
}

func (r ApiJobsGetConvertProfileStatusRequest) ClientTag(clientTag string) ApiJobsGetConvertProfileStatusRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsGetConvertProfileStatusRequest) PartnerId(partnerId int32) ApiJobsGetConvertProfileStatusRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsGetConvertProfileStatusRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsGetConvertProfileStatusRequest {
	r.body = &body
	return r
}

func (r ApiJobsGetConvertProfileStatusRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsGetConvertProfileStatusExecute(r)
}

/*
JobsGetConvertProfileStatus Method for JobsGetConvertProfileStatus

batch getConvertProfileStatusAction returns the status of convert task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsGetConvertProfileStatusRequest
*/
func (a *JobsApiService) JobsGetConvertProfileStatus(ctx context.Context) ApiJobsGetConvertProfileStatusRequest {
	return ApiJobsGetConvertProfileStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsGetConvertProfileStatusExecute(r ApiJobsGetConvertProfileStatusRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsGetConvertProfileStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/getConvertProfileStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsGetConvertStatusRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsGetConvertStatusRequest) Ks(ks string) ApiJobsGetConvertStatusRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsGetConvertStatusRequest) Format(format int32) ApiJobsGetConvertStatusRequest {
	r.format = &format
	return r
}

func (r ApiJobsGetConvertStatusRequest) ClientTag(clientTag string) ApiJobsGetConvertStatusRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsGetConvertStatusRequest) PartnerId(partnerId int32) ApiJobsGetConvertStatusRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsGetConvertStatusRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsGetConvertStatusRequest {
	r.body = &body
	return r
}

func (r ApiJobsGetConvertStatusRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsGetConvertStatusExecute(r)
}

/*
JobsGetConvertStatus Method for JobsGetConvertStatus

batch getConvertStatusAction returns the status of convert task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsGetConvertStatusRequest
*/
func (a *JobsApiService) JobsGetConvertStatus(ctx context.Context) ApiJobsGetConvertStatusRequest {
	return ApiJobsGetConvertStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsGetConvertStatusExecute(r ApiJobsGetConvertStatusRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsGetConvertStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/getConvertStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsGetExtractMediaStatusRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsGetExtractMediaStatusRequest) Ks(ks string) ApiJobsGetExtractMediaStatusRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsGetExtractMediaStatusRequest) Format(format int32) ApiJobsGetExtractMediaStatusRequest {
	r.format = &format
	return r
}

func (r ApiJobsGetExtractMediaStatusRequest) ClientTag(clientTag string) ApiJobsGetExtractMediaStatusRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsGetExtractMediaStatusRequest) PartnerId(partnerId int32) ApiJobsGetExtractMediaStatusRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsGetExtractMediaStatusRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsGetExtractMediaStatusRequest {
	r.body = &body
	return r
}

func (r ApiJobsGetExtractMediaStatusRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsGetExtractMediaStatusExecute(r)
}

/*
JobsGetExtractMediaStatus Method for JobsGetExtractMediaStatus

batch getExtractMediaStatusAction returns the status of extract media task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsGetExtractMediaStatusRequest
*/
func (a *JobsApiService) JobsGetExtractMediaStatus(ctx context.Context) ApiJobsGetExtractMediaStatusRequest {
	return ApiJobsGetExtractMediaStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsGetExtractMediaStatusExecute(r ApiJobsGetExtractMediaStatusRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsGetExtractMediaStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/getExtractMediaStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsGetImportStatusRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsGetImportStatusRequest) Ks(ks string) ApiJobsGetImportStatusRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsGetImportStatusRequest) Format(format int32) ApiJobsGetImportStatusRequest {
	r.format = &format
	return r
}

func (r ApiJobsGetImportStatusRequest) ClientTag(clientTag string) ApiJobsGetImportStatusRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsGetImportStatusRequest) PartnerId(partnerId int32) ApiJobsGetImportStatusRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsGetImportStatusRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsGetImportStatusRequest {
	r.body = &body
	return r
}

func (r ApiJobsGetImportStatusRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsGetImportStatusExecute(r)
}

/*
JobsGetImportStatus Method for JobsGetImportStatus

batch getImportStatusAction returns the status of import task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsGetImportStatusRequest
*/
func (a *JobsApiService) JobsGetImportStatus(ctx context.Context) ApiJobsGetImportStatusRequest {
	return ApiJobsGetImportStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsGetImportStatusExecute(r ApiJobsGetImportStatusRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsGetImportStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/getImportStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsGetMailStatusRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsGetMailStatusRequest) Ks(ks string) ApiJobsGetMailStatusRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsGetMailStatusRequest) Format(format int32) ApiJobsGetMailStatusRequest {
	r.format = &format
	return r
}

func (r ApiJobsGetMailStatusRequest) ClientTag(clientTag string) ApiJobsGetMailStatusRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsGetMailStatusRequest) PartnerId(partnerId int32) ApiJobsGetMailStatusRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsGetMailStatusRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsGetMailStatusRequest {
	r.body = &body
	return r
}

func (r ApiJobsGetMailStatusRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsGetMailStatusExecute(r)
}

/*
JobsGetMailStatus Method for JobsGetMailStatus

batch getMailStatusAction returns the status of mail task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsGetMailStatusRequest
*/
func (a *JobsApiService) JobsGetMailStatus(ctx context.Context) ApiJobsGetMailStatusRequest {
	return ApiJobsGetMailStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsGetMailStatusExecute(r ApiJobsGetMailStatusRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsGetMailStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/getMailStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsGetNotificationStatusRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsGetNotificationStatusRequest) Ks(ks string) ApiJobsGetNotificationStatusRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsGetNotificationStatusRequest) Format(format int32) ApiJobsGetNotificationStatusRequest {
	r.format = &format
	return r
}

func (r ApiJobsGetNotificationStatusRequest) ClientTag(clientTag string) ApiJobsGetNotificationStatusRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsGetNotificationStatusRequest) PartnerId(partnerId int32) ApiJobsGetNotificationStatusRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsGetNotificationStatusRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsGetNotificationStatusRequest {
	r.body = &body
	return r
}

func (r ApiJobsGetNotificationStatusRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsGetNotificationStatusExecute(r)
}

/*
JobsGetNotificationStatus Method for JobsGetNotificationStatus

batch getNotificationStatusAction returns the status of Notification task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsGetNotificationStatusRequest
*/
func (a *JobsApiService) JobsGetNotificationStatus(ctx context.Context) ApiJobsGetNotificationStatusRequest {
	return ApiJobsGetNotificationStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsGetNotificationStatusExecute(r ApiJobsGetNotificationStatusRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsGetNotificationStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/getNotificationStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsGetPostConvertStatusRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsGetPostConvertStatusRequest) Ks(ks string) ApiJobsGetPostConvertStatusRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsGetPostConvertStatusRequest) Format(format int32) ApiJobsGetPostConvertStatusRequest {
	r.format = &format
	return r
}

func (r ApiJobsGetPostConvertStatusRequest) ClientTag(clientTag string) ApiJobsGetPostConvertStatusRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsGetPostConvertStatusRequest) PartnerId(partnerId int32) ApiJobsGetPostConvertStatusRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsGetPostConvertStatusRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsGetPostConvertStatusRequest {
	r.body = &body
	return r
}

func (r ApiJobsGetPostConvertStatusRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsGetPostConvertStatusExecute(r)
}

/*
JobsGetPostConvertStatus Method for JobsGetPostConvertStatus

batch getPostConvertStatusAction returns the status of post convert task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsGetPostConvertStatusRequest
*/
func (a *JobsApiService) JobsGetPostConvertStatus(ctx context.Context) ApiJobsGetPostConvertStatusRequest {
	return ApiJobsGetPostConvertStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsGetPostConvertStatusExecute(r ApiJobsGetPostConvertStatusRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsGetPostConvertStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/getPostConvertStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsGetProvisionDeleteStatusRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsGetProvisionDeleteStatusRequest) Ks(ks string) ApiJobsGetProvisionDeleteStatusRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsGetProvisionDeleteStatusRequest) Format(format int32) ApiJobsGetProvisionDeleteStatusRequest {
	r.format = &format
	return r
}

func (r ApiJobsGetProvisionDeleteStatusRequest) ClientTag(clientTag string) ApiJobsGetProvisionDeleteStatusRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsGetProvisionDeleteStatusRequest) PartnerId(partnerId int32) ApiJobsGetProvisionDeleteStatusRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsGetProvisionDeleteStatusRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsGetProvisionDeleteStatusRequest {
	r.body = &body
	return r
}

func (r ApiJobsGetProvisionDeleteStatusRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsGetProvisionDeleteStatusExecute(r)
}

/*
JobsGetProvisionDeleteStatus Method for JobsGetProvisionDeleteStatus

// --------------------------------- ProvisionProvideJob functions 	--------------------------------- //

// --------------------------------- ProvisionDeleteJob functions 	--------------------------------- //

/batch getProvisionDeleteStatusAction returns the status of ProvisionDelete task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsGetProvisionDeleteStatusRequest
*/
func (a *JobsApiService) JobsGetProvisionDeleteStatus(ctx context.Context) ApiJobsGetProvisionDeleteStatusRequest {
	return ApiJobsGetProvisionDeleteStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsGetProvisionDeleteStatusExecute(r ApiJobsGetProvisionDeleteStatusRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsGetProvisionDeleteStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/getProvisionDeleteStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsGetProvisionProvideStatusRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsGetProvisionProvideStatusRequest) Ks(ks string) ApiJobsGetProvisionProvideStatusRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsGetProvisionProvideStatusRequest) Format(format int32) ApiJobsGetProvisionProvideStatusRequest {
	r.format = &format
	return r
}

func (r ApiJobsGetProvisionProvideStatusRequest) ClientTag(clientTag string) ApiJobsGetProvisionProvideStatusRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsGetProvisionProvideStatusRequest) PartnerId(partnerId int32) ApiJobsGetProvisionProvideStatusRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsGetProvisionProvideStatusRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsGetProvisionProvideStatusRequest {
	r.body = &body
	return r
}

func (r ApiJobsGetProvisionProvideStatusRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsGetProvisionProvideStatusExecute(r)
}

/*
JobsGetProvisionProvideStatus Method for JobsGetProvisionProvideStatus

// --------------------------------- ImportJob functions 	--------------------------------- //

// --------------------------------- ProvisionProvideJob functions 	--------------------------------- //

/batch getProvisionProvideStatusAction returns the status of ProvisionProvide task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsGetProvisionProvideStatusRequest
*/
func (a *JobsApiService) JobsGetProvisionProvideStatus(ctx context.Context) ApiJobsGetProvisionProvideStatusRequest {
	return ApiJobsGetProvisionProvideStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsGetProvisionProvideStatusExecute(r ApiJobsGetProvisionProvideStatusRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsGetProvisionProvideStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/getProvisionProvideStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsGetStatusRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsGetStatusRequest
}

func (r ApiJobsGetStatusRequest) Ks(ks string) ApiJobsGetStatusRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsGetStatusRequest) Format(format int32) ApiJobsGetStatusRequest {
	r.format = &format
	return r
}

func (r ApiJobsGetStatusRequest) ClientTag(clientTag string) ApiJobsGetStatusRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsGetStatusRequest) PartnerId(partnerId int32) ApiJobsGetStatusRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsGetStatusRequest) Body(body JobsGetStatusRequest) ApiJobsGetStatusRequest {
	r.body = &body
	return r
}

func (r ApiJobsGetStatusRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsGetStatusExecute(r)
}

/*
JobsGetStatus Method for JobsGetStatus

batch getStatusAction returns the status of task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsGetStatusRequest
*/
func (a *JobsApiService) JobsGetStatus(ctx context.Context) ApiJobsGetStatusRequest {
	return ApiJobsGetStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsGetStatusExecute(r ApiJobsGetStatusRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsGetStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/getStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsGetStorageDeleteStatusRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsGetStorageDeleteStatusRequest) Ks(ks string) ApiJobsGetStorageDeleteStatusRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsGetStorageDeleteStatusRequest) Format(format int32) ApiJobsGetStorageDeleteStatusRequest {
	r.format = &format
	return r
}

func (r ApiJobsGetStorageDeleteStatusRequest) ClientTag(clientTag string) ApiJobsGetStorageDeleteStatusRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsGetStorageDeleteStatusRequest) PartnerId(partnerId int32) ApiJobsGetStorageDeleteStatusRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsGetStorageDeleteStatusRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsGetStorageDeleteStatusRequest {
	r.body = &body
	return r
}

func (r ApiJobsGetStorageDeleteStatusRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsGetStorageDeleteStatusExecute(r)
}

/*
JobsGetStorageDeleteStatus Method for JobsGetStorageDeleteStatus

batch getStorageDeleteStatusAction returns the status of export task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsGetStorageDeleteStatusRequest
*/
func (a *JobsApiService) JobsGetStorageDeleteStatus(ctx context.Context) ApiJobsGetStorageDeleteStatusRequest {
	return ApiJobsGetStorageDeleteStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsGetStorageDeleteStatusExecute(r ApiJobsGetStorageDeleteStatusRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsGetStorageDeleteStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/getStorageDeleteStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsGetStorageExportStatusRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsGetStorageExportStatusRequest) Ks(ks string) ApiJobsGetStorageExportStatusRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsGetStorageExportStatusRequest) Format(format int32) ApiJobsGetStorageExportStatusRequest {
	r.format = &format
	return r
}

func (r ApiJobsGetStorageExportStatusRequest) ClientTag(clientTag string) ApiJobsGetStorageExportStatusRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsGetStorageExportStatusRequest) PartnerId(partnerId int32) ApiJobsGetStorageExportStatusRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsGetStorageExportStatusRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsGetStorageExportStatusRequest {
	r.body = &body
	return r
}

func (r ApiJobsGetStorageExportStatusRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsGetStorageExportStatusExecute(r)
}

/*
JobsGetStorageExportStatus Method for JobsGetStorageExportStatus

batch getStorageExportStatusAction returns the status of export task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsGetStorageExportStatusRequest
*/
func (a *JobsApiService) JobsGetStorageExportStatus(ctx context.Context) ApiJobsGetStorageExportStatusRequest {
	return ApiJobsGetStorageExportStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsGetStorageExportStatusExecute(r ApiJobsGetStorageExportStatusRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsGetStorageExportStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/getStorageExportStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsListBatchJobsRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsListBatchJobsRequest
}

func (r ApiJobsListBatchJobsRequest) Ks(ks string) ApiJobsListBatchJobsRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsListBatchJobsRequest) Format(format int32) ApiJobsListBatchJobsRequest {
	r.format = &format
	return r
}

func (r ApiJobsListBatchJobsRequest) ClientTag(clientTag string) ApiJobsListBatchJobsRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsListBatchJobsRequest) PartnerId(partnerId int32) ApiJobsListBatchJobsRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsListBatchJobsRequest) Body(body JobsListBatchJobsRequest) ApiJobsListBatchJobsRequest {
	r.body = &body
	return r
}

func (r ApiJobsListBatchJobsRequest) Execute() (*KalturaBatchJobListResponse, *http.Response, error) {
	return r.ApiService.JobsListBatchJobsExecute(r)
}

/*
JobsListBatchJobs Method for JobsListBatchJobs

list Batch Jobs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsListBatchJobsRequest
*/
func (a *JobsApiService) JobsListBatchJobs(ctx context.Context) ApiJobsListBatchJobsRequest {
	return ApiJobsListBatchJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobListResponse
func (a *JobsApiService) JobsListBatchJobsExecute(r ApiJobsListBatchJobsRequest) (*KalturaBatchJobListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsListBatchJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/listBatchJobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsRetryBulkUploadRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsRetryBulkUploadRequest) Ks(ks string) ApiJobsRetryBulkUploadRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsRetryBulkUploadRequest) Format(format int32) ApiJobsRetryBulkUploadRequest {
	r.format = &format
	return r
}

func (r ApiJobsRetryBulkUploadRequest) ClientTag(clientTag string) ApiJobsRetryBulkUploadRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsRetryBulkUploadRequest) PartnerId(partnerId int32) ApiJobsRetryBulkUploadRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsRetryBulkUploadRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsRetryBulkUploadRequest {
	r.body = &body
	return r
}

func (r ApiJobsRetryBulkUploadRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsRetryBulkUploadExecute(r)
}

/*
JobsRetryBulkUpload Method for JobsRetryBulkUpload

batch retryBulkUploadAction retries and returns the status of bulk upload task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsRetryBulkUploadRequest
*/
func (a *JobsApiService) JobsRetryBulkUpload(ctx context.Context) ApiJobsRetryBulkUploadRequest {
	return ApiJobsRetryBulkUploadRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsRetryBulkUploadExecute(r ApiJobsRetryBulkUploadRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsRetryBulkUpload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/retryBulkUpload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsRetryCaptureThumbRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsRetryCaptureThumbRequest) Ks(ks string) ApiJobsRetryCaptureThumbRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsRetryCaptureThumbRequest) Format(format int32) ApiJobsRetryCaptureThumbRequest {
	r.format = &format
	return r
}

func (r ApiJobsRetryCaptureThumbRequest) ClientTag(clientTag string) ApiJobsRetryCaptureThumbRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsRetryCaptureThumbRequest) PartnerId(partnerId int32) ApiJobsRetryCaptureThumbRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsRetryCaptureThumbRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsRetryCaptureThumbRequest {
	r.body = &body
	return r
}

func (r ApiJobsRetryCaptureThumbRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsRetryCaptureThumbExecute(r)
}

/*
JobsRetryCaptureThumb Method for JobsRetryCaptureThumb

batch retryCaptureThumbAction retries and returns the status of capture thumbnail task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsRetryCaptureThumbRequest
*/
func (a *JobsApiService) JobsRetryCaptureThumb(ctx context.Context) ApiJobsRetryCaptureThumbRequest {
	return ApiJobsRetryCaptureThumbRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsRetryCaptureThumbExecute(r ApiJobsRetryCaptureThumbRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsRetryCaptureThumb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/retryCaptureThumb"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsRetryConvertRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsRetryConvertRequest) Ks(ks string) ApiJobsRetryConvertRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsRetryConvertRequest) Format(format int32) ApiJobsRetryConvertRequest {
	r.format = &format
	return r
}

func (r ApiJobsRetryConvertRequest) ClientTag(clientTag string) ApiJobsRetryConvertRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsRetryConvertRequest) PartnerId(partnerId int32) ApiJobsRetryConvertRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsRetryConvertRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsRetryConvertRequest {
	r.body = &body
	return r
}

func (r ApiJobsRetryConvertRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsRetryConvertExecute(r)
}

/*
JobsRetryConvert Method for JobsRetryConvert

batch retryConvertAction retries and returns the status of convert task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsRetryConvertRequest
*/
func (a *JobsApiService) JobsRetryConvert(ctx context.Context) ApiJobsRetryConvertRequest {
	return ApiJobsRetryConvertRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsRetryConvertExecute(r ApiJobsRetryConvertRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsRetryConvert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/retryConvert"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsRetryConvertCollectionRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsRetryConvertCollectionRequest) Ks(ks string) ApiJobsRetryConvertCollectionRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsRetryConvertCollectionRequest) Format(format int32) ApiJobsRetryConvertCollectionRequest {
	r.format = &format
	return r
}

func (r ApiJobsRetryConvertCollectionRequest) ClientTag(clientTag string) ApiJobsRetryConvertCollectionRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsRetryConvertCollectionRequest) PartnerId(partnerId int32) ApiJobsRetryConvertCollectionRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsRetryConvertCollectionRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsRetryConvertCollectionRequest {
	r.body = &body
	return r
}

func (r ApiJobsRetryConvertCollectionRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsRetryConvertCollectionExecute(r)
}

/*
JobsRetryConvertCollection Method for JobsRetryConvertCollection

batch retryConvertCollectionAction retries and returns the status of convert profile task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsRetryConvertCollectionRequest
*/
func (a *JobsApiService) JobsRetryConvertCollection(ctx context.Context) ApiJobsRetryConvertCollectionRequest {
	return ApiJobsRetryConvertCollectionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsRetryConvertCollectionExecute(r ApiJobsRetryConvertCollectionRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsRetryConvertCollection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/retryConvertCollection"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsRetryConvertProfileRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsRetryConvertProfileRequest) Ks(ks string) ApiJobsRetryConvertProfileRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsRetryConvertProfileRequest) Format(format int32) ApiJobsRetryConvertProfileRequest {
	r.format = &format
	return r
}

func (r ApiJobsRetryConvertProfileRequest) ClientTag(clientTag string) ApiJobsRetryConvertProfileRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsRetryConvertProfileRequest) PartnerId(partnerId int32) ApiJobsRetryConvertProfileRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsRetryConvertProfileRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsRetryConvertProfileRequest {
	r.body = &body
	return r
}

func (r ApiJobsRetryConvertProfileRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsRetryConvertProfileExecute(r)
}

/*
JobsRetryConvertProfile Method for JobsRetryConvertProfile

batch retryConvertProfileAction retries and returns the status of convert profile task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsRetryConvertProfileRequest
*/
func (a *JobsApiService) JobsRetryConvertProfile(ctx context.Context) ApiJobsRetryConvertProfileRequest {
	return ApiJobsRetryConvertProfileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsRetryConvertProfileExecute(r ApiJobsRetryConvertProfileRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsRetryConvertProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/retryConvertProfile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsRetryExtractMediaRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsRetryExtractMediaRequest) Ks(ks string) ApiJobsRetryExtractMediaRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsRetryExtractMediaRequest) Format(format int32) ApiJobsRetryExtractMediaRequest {
	r.format = &format
	return r
}

func (r ApiJobsRetryExtractMediaRequest) ClientTag(clientTag string) ApiJobsRetryExtractMediaRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsRetryExtractMediaRequest) PartnerId(partnerId int32) ApiJobsRetryExtractMediaRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsRetryExtractMediaRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsRetryExtractMediaRequest {
	r.body = &body
	return r
}

func (r ApiJobsRetryExtractMediaRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsRetryExtractMediaExecute(r)
}

/*
JobsRetryExtractMedia Method for JobsRetryExtractMedia

batch retryExtractMediaAction retries and returns the status of extract media task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsRetryExtractMediaRequest
*/
func (a *JobsApiService) JobsRetryExtractMedia(ctx context.Context) ApiJobsRetryExtractMediaRequest {
	return ApiJobsRetryExtractMediaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsRetryExtractMediaExecute(r ApiJobsRetryExtractMediaRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsRetryExtractMedia")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/retryExtractMedia"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsRetryImportRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsRetryImportRequest) Ks(ks string) ApiJobsRetryImportRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsRetryImportRequest) Format(format int32) ApiJobsRetryImportRequest {
	r.format = &format
	return r
}

func (r ApiJobsRetryImportRequest) ClientTag(clientTag string) ApiJobsRetryImportRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsRetryImportRequest) PartnerId(partnerId int32) ApiJobsRetryImportRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsRetryImportRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsRetryImportRequest {
	r.body = &body
	return r
}

func (r ApiJobsRetryImportRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsRetryImportExecute(r)
}

/*
JobsRetryImport Method for JobsRetryImport

batch retryImportAction retries and returns the status of import task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsRetryImportRequest
*/
func (a *JobsApiService) JobsRetryImport(ctx context.Context) ApiJobsRetryImportRequest {
	return ApiJobsRetryImportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsRetryImportExecute(r ApiJobsRetryImportRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsRetryImport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/retryImport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsRetryJobRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsRetryJobRequest
}

func (r ApiJobsRetryJobRequest) Ks(ks string) ApiJobsRetryJobRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsRetryJobRequest) Format(format int32) ApiJobsRetryJobRequest {
	r.format = &format
	return r
}

func (r ApiJobsRetryJobRequest) ClientTag(clientTag string) ApiJobsRetryJobRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsRetryJobRequest) PartnerId(partnerId int32) ApiJobsRetryJobRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsRetryJobRequest) Body(body JobsRetryJobRequest) ApiJobsRetryJobRequest {
	r.body = &body
	return r
}

func (r ApiJobsRetryJobRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsRetryJobExecute(r)
}

/*
JobsRetryJob Method for JobsRetryJob

batch retryJobAction aborts and returns the status of task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsRetryJobRequest
*/
func (a *JobsApiService) JobsRetryJob(ctx context.Context) ApiJobsRetryJobRequest {
	return ApiJobsRetryJobRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsRetryJobExecute(r ApiJobsRetryJobRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsRetryJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/retryJob"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsRetryMailRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsRetryMailRequest) Ks(ks string) ApiJobsRetryMailRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsRetryMailRequest) Format(format int32) ApiJobsRetryMailRequest {
	r.format = &format
	return r
}

func (r ApiJobsRetryMailRequest) ClientTag(clientTag string) ApiJobsRetryMailRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsRetryMailRequest) PartnerId(partnerId int32) ApiJobsRetryMailRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsRetryMailRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsRetryMailRequest {
	r.body = &body
	return r
}

func (r ApiJobsRetryMailRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsRetryMailExecute(r)
}

/*
JobsRetryMail Method for JobsRetryMail

batch retryMailAction retries and returns the status of mail task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsRetryMailRequest
*/
func (a *JobsApiService) JobsRetryMail(ctx context.Context) ApiJobsRetryMailRequest {
	return ApiJobsRetryMailRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsRetryMailExecute(r ApiJobsRetryMailRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsRetryMail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/retryMail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsRetryNotificationRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsRetryNotificationRequest) Ks(ks string) ApiJobsRetryNotificationRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsRetryNotificationRequest) Format(format int32) ApiJobsRetryNotificationRequest {
	r.format = &format
	return r
}

func (r ApiJobsRetryNotificationRequest) ClientTag(clientTag string) ApiJobsRetryNotificationRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsRetryNotificationRequest) PartnerId(partnerId int32) ApiJobsRetryNotificationRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsRetryNotificationRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsRetryNotificationRequest {
	r.body = &body
	return r
}

func (r ApiJobsRetryNotificationRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsRetryNotificationExecute(r)
}

/*
JobsRetryNotification Method for JobsRetryNotification

batch retryNotificationAction retries and returns the status of notification task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsRetryNotificationRequest
*/
func (a *JobsApiService) JobsRetryNotification(ctx context.Context) ApiJobsRetryNotificationRequest {
	return ApiJobsRetryNotificationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsRetryNotificationExecute(r ApiJobsRetryNotificationRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsRetryNotification")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/retryNotification"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsRetryPostConvertRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsRetryPostConvertRequest) Ks(ks string) ApiJobsRetryPostConvertRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsRetryPostConvertRequest) Format(format int32) ApiJobsRetryPostConvertRequest {
	r.format = &format
	return r
}

func (r ApiJobsRetryPostConvertRequest) ClientTag(clientTag string) ApiJobsRetryPostConvertRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsRetryPostConvertRequest) PartnerId(partnerId int32) ApiJobsRetryPostConvertRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsRetryPostConvertRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsRetryPostConvertRequest {
	r.body = &body
	return r
}

func (r ApiJobsRetryPostConvertRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsRetryPostConvertExecute(r)
}

/*
JobsRetryPostConvert Method for JobsRetryPostConvert

batch retryPostConvertAction retries and returns the status of post convert task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsRetryPostConvertRequest
*/
func (a *JobsApiService) JobsRetryPostConvert(ctx context.Context) ApiJobsRetryPostConvertRequest {
	return ApiJobsRetryPostConvertRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsRetryPostConvertExecute(r ApiJobsRetryPostConvertRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsRetryPostConvert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/retryPostConvert"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsRetryProvisionDeleteRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsRetryProvisionDeleteRequest) Ks(ks string) ApiJobsRetryProvisionDeleteRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsRetryProvisionDeleteRequest) Format(format int32) ApiJobsRetryProvisionDeleteRequest {
	r.format = &format
	return r
}

func (r ApiJobsRetryProvisionDeleteRequest) ClientTag(clientTag string) ApiJobsRetryProvisionDeleteRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsRetryProvisionDeleteRequest) PartnerId(partnerId int32) ApiJobsRetryProvisionDeleteRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsRetryProvisionDeleteRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsRetryProvisionDeleteRequest {
	r.body = &body
	return r
}

func (r ApiJobsRetryProvisionDeleteRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsRetryProvisionDeleteExecute(r)
}

/*
JobsRetryProvisionDelete Method for JobsRetryProvisionDelete

batch retryProvisionDeleteAction retries and returns the status of ProvisionDelete task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsRetryProvisionDeleteRequest
*/
func (a *JobsApiService) JobsRetryProvisionDelete(ctx context.Context) ApiJobsRetryProvisionDeleteRequest {
	return ApiJobsRetryProvisionDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsRetryProvisionDeleteExecute(r ApiJobsRetryProvisionDeleteRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsRetryProvisionDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/retryProvisionDelete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsRetryProvisionProvideRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsRetryProvisionProvideRequest) Ks(ks string) ApiJobsRetryProvisionProvideRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsRetryProvisionProvideRequest) Format(format int32) ApiJobsRetryProvisionProvideRequest {
	r.format = &format
	return r
}

func (r ApiJobsRetryProvisionProvideRequest) ClientTag(clientTag string) ApiJobsRetryProvisionProvideRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsRetryProvisionProvideRequest) PartnerId(partnerId int32) ApiJobsRetryProvisionProvideRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsRetryProvisionProvideRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsRetryProvisionProvideRequest {
	r.body = &body
	return r
}

func (r ApiJobsRetryProvisionProvideRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsRetryProvisionProvideExecute(r)
}

/*
JobsRetryProvisionProvide Method for JobsRetryProvisionProvide

batch retryProvisionProvideAction retries and returns the status of ProvisionProvide task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsRetryProvisionProvideRequest
*/
func (a *JobsApiService) JobsRetryProvisionProvide(ctx context.Context) ApiJobsRetryProvisionProvideRequest {
	return ApiJobsRetryProvisionProvideRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsRetryProvisionProvideExecute(r ApiJobsRetryProvisionProvideRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsRetryProvisionProvide")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/retryProvisionProvide"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsRetryStorageDeleteRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsRetryStorageDeleteRequest) Ks(ks string) ApiJobsRetryStorageDeleteRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsRetryStorageDeleteRequest) Format(format int32) ApiJobsRetryStorageDeleteRequest {
	r.format = &format
	return r
}

func (r ApiJobsRetryStorageDeleteRequest) ClientTag(clientTag string) ApiJobsRetryStorageDeleteRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsRetryStorageDeleteRequest) PartnerId(partnerId int32) ApiJobsRetryStorageDeleteRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsRetryStorageDeleteRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsRetryStorageDeleteRequest {
	r.body = &body
	return r
}

func (r ApiJobsRetryStorageDeleteRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsRetryStorageDeleteExecute(r)
}

/*
JobsRetryStorageDelete Method for JobsRetryStorageDelete

batch retryStorageDeleteAction retries and returns the status of export task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsRetryStorageDeleteRequest
*/
func (a *JobsApiService) JobsRetryStorageDelete(ctx context.Context) ApiJobsRetryStorageDeleteRequest {
	return ApiJobsRetryStorageDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsRetryStorageDeleteExecute(r ApiJobsRetryStorageDeleteRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsRetryStorageDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/retryStorageDelete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobsRetryStorageExportRequest struct {
	ctx context.Context
	ApiService *JobsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *JobsAbortBulkUploadRequest
}

func (r ApiJobsRetryStorageExportRequest) Ks(ks string) ApiJobsRetryStorageExportRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiJobsRetryStorageExportRequest) Format(format int32) ApiJobsRetryStorageExportRequest {
	r.format = &format
	return r
}

func (r ApiJobsRetryStorageExportRequest) ClientTag(clientTag string) ApiJobsRetryStorageExportRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiJobsRetryStorageExportRequest) PartnerId(partnerId int32) ApiJobsRetryStorageExportRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiJobsRetryStorageExportRequest) Body(body JobsAbortBulkUploadRequest) ApiJobsRetryStorageExportRequest {
	r.body = &body
	return r
}

func (r ApiJobsRetryStorageExportRequest) Execute() (*KalturaBatchJobResponse, *http.Response, error) {
	return r.ApiService.JobsRetryStorageExportExecute(r)
}

/*
JobsRetryStorageExport Method for JobsRetryStorageExport

batch retryStorageExportAction retries and returns the status of export task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiJobsRetryStorageExportRequest
*/
func (a *JobsApiService) JobsRetryStorageExport(ctx context.Context) ApiJobsRetryStorageExportRequest {
	return ApiJobsRetryStorageExportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBatchJobResponse
func (a *JobsApiService) JobsRetryStorageExportExecute(r ApiJobsRetryStorageExportRequest) (*KalturaBatchJobResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBatchJobResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsApiService.JobsRetryStorageExport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/jobs/action/retryStorageExport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
