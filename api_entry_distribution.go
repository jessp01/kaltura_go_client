/*
Kaltura VPaaS

The Kaltura VPaaS API

API version: 18.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// EntryDistributionApiService EntryDistributionApi service
type EntryDistributionApiService service

type ApiEntryDistributionAddRequest struct {
	ctx context.Context
	ApiService *EntryDistributionApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *EntryDistributionAddRequest
}

func (r ApiEntryDistributionAddRequest) Ks(ks string) ApiEntryDistributionAddRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryDistributionAddRequest) Format(format int32) ApiEntryDistributionAddRequest {
	r.format = &format
	return r
}

func (r ApiEntryDistributionAddRequest) ClientTag(clientTag string) ApiEntryDistributionAddRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryDistributionAddRequest) PartnerId(partnerId int32) ApiEntryDistributionAddRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryDistributionAddRequest) Body(body EntryDistributionAddRequest) ApiEntryDistributionAddRequest {
	r.body = &body
	return r
}

func (r ApiEntryDistributionAddRequest) Execute() (*KalturaEntryDistribution, *http.Response, error) {
	return r.ApiService.EntryDistributionAddExecute(r)
}

/*
EntryDistributionAdd Method for EntryDistributionAdd

Add new Entry Distribution

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryDistributionAddRequest
*/
func (a *EntryDistributionApiService) EntryDistributionAdd(ctx context.Context) ApiEntryDistributionAddRequest {
	return ApiEntryDistributionAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEntryDistribution
func (a *EntryDistributionApiService) EntryDistributionAddExecute(r ApiEntryDistributionAddRequest) (*KalturaEntryDistribution, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEntryDistribution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryDistributionApiService.EntryDistributionAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/contentdistribution_entrydistribution/action/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEntryDistributionDeleteRequest struct {
	ctx context.Context
	ApiService *EntryDistributionApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AccessControlDeleteRequest
}

func (r ApiEntryDistributionDeleteRequest) Ks(ks string) ApiEntryDistributionDeleteRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryDistributionDeleteRequest) Format(format int32) ApiEntryDistributionDeleteRequest {
	r.format = &format
	return r
}

func (r ApiEntryDistributionDeleteRequest) ClientTag(clientTag string) ApiEntryDistributionDeleteRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryDistributionDeleteRequest) PartnerId(partnerId int32) ApiEntryDistributionDeleteRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryDistributionDeleteRequest) Body(body AccessControlDeleteRequest) ApiEntryDistributionDeleteRequest {
	r.body = &body
	return r
}

func (r ApiEntryDistributionDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.EntryDistributionDeleteExecute(r)
}

/*
EntryDistributionDelete Method for EntryDistributionDelete

Delete Entry Distribution by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryDistributionDeleteRequest
*/
func (a *EntryDistributionApiService) EntryDistributionDelete(ctx context.Context) ApiEntryDistributionDeleteRequest {
	return ApiEntryDistributionDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EntryDistributionApiService) EntryDistributionDeleteExecute(r ApiEntryDistributionDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryDistributionApiService.EntryDistributionDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/contentdistribution_entrydistribution/action/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEntryDistributionGetRequest struct {
	ctx context.Context
	ApiService *EntryDistributionApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AccessControlDeleteRequest
}

func (r ApiEntryDistributionGetRequest) Ks(ks string) ApiEntryDistributionGetRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryDistributionGetRequest) Format(format int32) ApiEntryDistributionGetRequest {
	r.format = &format
	return r
}

func (r ApiEntryDistributionGetRequest) ClientTag(clientTag string) ApiEntryDistributionGetRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryDistributionGetRequest) PartnerId(partnerId int32) ApiEntryDistributionGetRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryDistributionGetRequest) Body(body AccessControlDeleteRequest) ApiEntryDistributionGetRequest {
	r.body = &body
	return r
}

func (r ApiEntryDistributionGetRequest) Execute() (*KalturaEntryDistribution, *http.Response, error) {
	return r.ApiService.EntryDistributionGetExecute(r)
}

/*
EntryDistributionGet Method for EntryDistributionGet

Get Entry Distribution by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryDistributionGetRequest
*/
func (a *EntryDistributionApiService) EntryDistributionGet(ctx context.Context) ApiEntryDistributionGetRequest {
	return ApiEntryDistributionGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEntryDistribution
func (a *EntryDistributionApiService) EntryDistributionGetExecute(r ApiEntryDistributionGetRequest) (*KalturaEntryDistribution, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEntryDistribution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryDistributionApiService.EntryDistributionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/contentdistribution_entrydistribution/action/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEntryDistributionListRequest struct {
	ctx context.Context
	ApiService *EntryDistributionApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *EntryDistributionListRequest
}

func (r ApiEntryDistributionListRequest) Ks(ks string) ApiEntryDistributionListRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryDistributionListRequest) Format(format int32) ApiEntryDistributionListRequest {
	r.format = &format
	return r
}

func (r ApiEntryDistributionListRequest) ClientTag(clientTag string) ApiEntryDistributionListRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryDistributionListRequest) PartnerId(partnerId int32) ApiEntryDistributionListRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryDistributionListRequest) Body(body EntryDistributionListRequest) ApiEntryDistributionListRequest {
	r.body = &body
	return r
}

func (r ApiEntryDistributionListRequest) Execute() (*KalturaEntryDistributionListResponse, *http.Response, error) {
	return r.ApiService.EntryDistributionListExecute(r)
}

/*
EntryDistributionList Method for EntryDistributionList

List all distribution providers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryDistributionListRequest
*/
func (a *EntryDistributionApiService) EntryDistributionList(ctx context.Context) ApiEntryDistributionListRequest {
	return ApiEntryDistributionListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEntryDistributionListResponse
func (a *EntryDistributionApiService) EntryDistributionListExecute(r ApiEntryDistributionListRequest) (*KalturaEntryDistributionListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEntryDistributionListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryDistributionApiService.EntryDistributionList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/contentdistribution_entrydistribution/action/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEntryDistributionRetrySubmitRequest struct {
	ctx context.Context
	ApiService *EntryDistributionApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AccessControlDeleteRequest
}

func (r ApiEntryDistributionRetrySubmitRequest) Ks(ks string) ApiEntryDistributionRetrySubmitRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryDistributionRetrySubmitRequest) Format(format int32) ApiEntryDistributionRetrySubmitRequest {
	r.format = &format
	return r
}

func (r ApiEntryDistributionRetrySubmitRequest) ClientTag(clientTag string) ApiEntryDistributionRetrySubmitRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryDistributionRetrySubmitRequest) PartnerId(partnerId int32) ApiEntryDistributionRetrySubmitRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryDistributionRetrySubmitRequest) Body(body AccessControlDeleteRequest) ApiEntryDistributionRetrySubmitRequest {
	r.body = &body
	return r
}

func (r ApiEntryDistributionRetrySubmitRequest) Execute() (*KalturaEntryDistribution, *http.Response, error) {
	return r.ApiService.EntryDistributionRetrySubmitExecute(r)
}

/*
EntryDistributionRetrySubmit Method for EntryDistributionRetrySubmit

Retries last submit action

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryDistributionRetrySubmitRequest
*/
func (a *EntryDistributionApiService) EntryDistributionRetrySubmit(ctx context.Context) ApiEntryDistributionRetrySubmitRequest {
	return ApiEntryDistributionRetrySubmitRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEntryDistribution
func (a *EntryDistributionApiService) EntryDistributionRetrySubmitExecute(r ApiEntryDistributionRetrySubmitRequest) (*KalturaEntryDistribution, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEntryDistribution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryDistributionApiService.EntryDistributionRetrySubmit")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/contentdistribution_entrydistribution/action/retrySubmit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEntryDistributionServeReturnedDataRequest struct {
	ctx context.Context
	ApiService *EntryDistributionApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *EntryDistributionServeReturnedDataRequest
}

func (r ApiEntryDistributionServeReturnedDataRequest) Ks(ks string) ApiEntryDistributionServeReturnedDataRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryDistributionServeReturnedDataRequest) Format(format int32) ApiEntryDistributionServeReturnedDataRequest {
	r.format = &format
	return r
}

func (r ApiEntryDistributionServeReturnedDataRequest) ClientTag(clientTag string) ApiEntryDistributionServeReturnedDataRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryDistributionServeReturnedDataRequest) PartnerId(partnerId int32) ApiEntryDistributionServeReturnedDataRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryDistributionServeReturnedDataRequest) Body(body EntryDistributionServeReturnedDataRequest) ApiEntryDistributionServeReturnedDataRequest {
	r.body = &body
	return r
}

func (r ApiEntryDistributionServeReturnedDataRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.EntryDistributionServeReturnedDataExecute(r)
}

/*
EntryDistributionServeReturnedData Method for EntryDistributionServeReturnedData

Serves entry distribution returned data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryDistributionServeReturnedDataRequest
*/
func (a *EntryDistributionApiService) EntryDistributionServeReturnedData(ctx context.Context) ApiEntryDistributionServeReturnedDataRequest {
	return ApiEntryDistributionServeReturnedDataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *EntryDistributionApiService) EntryDistributionServeReturnedDataExecute(r ApiEntryDistributionServeReturnedDataRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryDistributionApiService.EntryDistributionServeReturnedData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/contentdistribution_entrydistribution/action/serveReturnedData"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEntryDistributionServeSentDataRequest struct {
	ctx context.Context
	ApiService *EntryDistributionApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *EntryDistributionServeReturnedDataRequest
}

func (r ApiEntryDistributionServeSentDataRequest) Ks(ks string) ApiEntryDistributionServeSentDataRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryDistributionServeSentDataRequest) Format(format int32) ApiEntryDistributionServeSentDataRequest {
	r.format = &format
	return r
}

func (r ApiEntryDistributionServeSentDataRequest) ClientTag(clientTag string) ApiEntryDistributionServeSentDataRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryDistributionServeSentDataRequest) PartnerId(partnerId int32) ApiEntryDistributionServeSentDataRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryDistributionServeSentDataRequest) Body(body EntryDistributionServeReturnedDataRequest) ApiEntryDistributionServeSentDataRequest {
	r.body = &body
	return r
}

func (r ApiEntryDistributionServeSentDataRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.EntryDistributionServeSentDataExecute(r)
}

/*
EntryDistributionServeSentData Method for EntryDistributionServeSentData

Serves entry distribution sent data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryDistributionServeSentDataRequest
*/
func (a *EntryDistributionApiService) EntryDistributionServeSentData(ctx context.Context) ApiEntryDistributionServeSentDataRequest {
	return ApiEntryDistributionServeSentDataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *EntryDistributionApiService) EntryDistributionServeSentDataExecute(r ApiEntryDistributionServeSentDataRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryDistributionApiService.EntryDistributionServeSentData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/contentdistribution_entrydistribution/action/serveSentData"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEntryDistributionSubmitAddRequest struct {
	ctx context.Context
	ApiService *EntryDistributionApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *EntryDistributionSubmitAddRequest
}

func (r ApiEntryDistributionSubmitAddRequest) Ks(ks string) ApiEntryDistributionSubmitAddRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryDistributionSubmitAddRequest) Format(format int32) ApiEntryDistributionSubmitAddRequest {
	r.format = &format
	return r
}

func (r ApiEntryDistributionSubmitAddRequest) ClientTag(clientTag string) ApiEntryDistributionSubmitAddRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryDistributionSubmitAddRequest) PartnerId(partnerId int32) ApiEntryDistributionSubmitAddRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryDistributionSubmitAddRequest) Body(body EntryDistributionSubmitAddRequest) ApiEntryDistributionSubmitAddRequest {
	r.body = &body
	return r
}

func (r ApiEntryDistributionSubmitAddRequest) Execute() (*KalturaEntryDistribution, *http.Response, error) {
	return r.ApiService.EntryDistributionSubmitAddExecute(r)
}

/*
EntryDistributionSubmitAdd Method for EntryDistributionSubmitAdd

Submits Entry Distribution to the remote destination

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryDistributionSubmitAddRequest
*/
func (a *EntryDistributionApiService) EntryDistributionSubmitAdd(ctx context.Context) ApiEntryDistributionSubmitAddRequest {
	return ApiEntryDistributionSubmitAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEntryDistribution
func (a *EntryDistributionApiService) EntryDistributionSubmitAddExecute(r ApiEntryDistributionSubmitAddRequest) (*KalturaEntryDistribution, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEntryDistribution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryDistributionApiService.EntryDistributionSubmitAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/contentdistribution_entrydistribution/action/submitAdd"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEntryDistributionSubmitDeleteRequest struct {
	ctx context.Context
	ApiService *EntryDistributionApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AccessControlDeleteRequest
}

func (r ApiEntryDistributionSubmitDeleteRequest) Ks(ks string) ApiEntryDistributionSubmitDeleteRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryDistributionSubmitDeleteRequest) Format(format int32) ApiEntryDistributionSubmitDeleteRequest {
	r.format = &format
	return r
}

func (r ApiEntryDistributionSubmitDeleteRequest) ClientTag(clientTag string) ApiEntryDistributionSubmitDeleteRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryDistributionSubmitDeleteRequest) PartnerId(partnerId int32) ApiEntryDistributionSubmitDeleteRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryDistributionSubmitDeleteRequest) Body(body AccessControlDeleteRequest) ApiEntryDistributionSubmitDeleteRequest {
	r.body = &body
	return r
}

func (r ApiEntryDistributionSubmitDeleteRequest) Execute() (*KalturaEntryDistribution, *http.Response, error) {
	return r.ApiService.EntryDistributionSubmitDeleteExecute(r)
}

/*
EntryDistributionSubmitDelete Method for EntryDistributionSubmitDelete

Deletes Entry Distribution from the remote destination

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryDistributionSubmitDeleteRequest
*/
func (a *EntryDistributionApiService) EntryDistributionSubmitDelete(ctx context.Context) ApiEntryDistributionSubmitDeleteRequest {
	return ApiEntryDistributionSubmitDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEntryDistribution
func (a *EntryDistributionApiService) EntryDistributionSubmitDeleteExecute(r ApiEntryDistributionSubmitDeleteRequest) (*KalturaEntryDistribution, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEntryDistribution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryDistributionApiService.EntryDistributionSubmitDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/contentdistribution_entrydistribution/action/submitDelete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEntryDistributionSubmitFetchReportRequest struct {
	ctx context.Context
	ApiService *EntryDistributionApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AccessControlDeleteRequest
}

func (r ApiEntryDistributionSubmitFetchReportRequest) Ks(ks string) ApiEntryDistributionSubmitFetchReportRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryDistributionSubmitFetchReportRequest) Format(format int32) ApiEntryDistributionSubmitFetchReportRequest {
	r.format = &format
	return r
}

func (r ApiEntryDistributionSubmitFetchReportRequest) ClientTag(clientTag string) ApiEntryDistributionSubmitFetchReportRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryDistributionSubmitFetchReportRequest) PartnerId(partnerId int32) ApiEntryDistributionSubmitFetchReportRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryDistributionSubmitFetchReportRequest) Body(body AccessControlDeleteRequest) ApiEntryDistributionSubmitFetchReportRequest {
	r.body = &body
	return r
}

func (r ApiEntryDistributionSubmitFetchReportRequest) Execute() (*KalturaEntryDistribution, *http.Response, error) {
	return r.ApiService.EntryDistributionSubmitFetchReportExecute(r)
}

/*
EntryDistributionSubmitFetchReport Method for EntryDistributionSubmitFetchReport

Submits Entry Distribution report request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryDistributionSubmitFetchReportRequest
*/
func (a *EntryDistributionApiService) EntryDistributionSubmitFetchReport(ctx context.Context) ApiEntryDistributionSubmitFetchReportRequest {
	return ApiEntryDistributionSubmitFetchReportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEntryDistribution
func (a *EntryDistributionApiService) EntryDistributionSubmitFetchReportExecute(r ApiEntryDistributionSubmitFetchReportRequest) (*KalturaEntryDistribution, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEntryDistribution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryDistributionApiService.EntryDistributionSubmitFetchReport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/contentdistribution_entrydistribution/action/submitFetchReport"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEntryDistributionSubmitUpdateRequest struct {
	ctx context.Context
	ApiService *EntryDistributionApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AccessControlDeleteRequest
}

func (r ApiEntryDistributionSubmitUpdateRequest) Ks(ks string) ApiEntryDistributionSubmitUpdateRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryDistributionSubmitUpdateRequest) Format(format int32) ApiEntryDistributionSubmitUpdateRequest {
	r.format = &format
	return r
}

func (r ApiEntryDistributionSubmitUpdateRequest) ClientTag(clientTag string) ApiEntryDistributionSubmitUpdateRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryDistributionSubmitUpdateRequest) PartnerId(partnerId int32) ApiEntryDistributionSubmitUpdateRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryDistributionSubmitUpdateRequest) Body(body AccessControlDeleteRequest) ApiEntryDistributionSubmitUpdateRequest {
	r.body = &body
	return r
}

func (r ApiEntryDistributionSubmitUpdateRequest) Execute() (*KalturaEntryDistribution, *http.Response, error) {
	return r.ApiService.EntryDistributionSubmitUpdateExecute(r)
}

/*
EntryDistributionSubmitUpdate Method for EntryDistributionSubmitUpdate

Submits Entry Distribution changes to the remote destination

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryDistributionSubmitUpdateRequest
*/
func (a *EntryDistributionApiService) EntryDistributionSubmitUpdate(ctx context.Context) ApiEntryDistributionSubmitUpdateRequest {
	return ApiEntryDistributionSubmitUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEntryDistribution
func (a *EntryDistributionApiService) EntryDistributionSubmitUpdateExecute(r ApiEntryDistributionSubmitUpdateRequest) (*KalturaEntryDistribution, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEntryDistribution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryDistributionApiService.EntryDistributionSubmitUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/contentdistribution_entrydistribution/action/submitUpdate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEntryDistributionUpdateRequest struct {
	ctx context.Context
	ApiService *EntryDistributionApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *EntryDistributionUpdateRequest
}

func (r ApiEntryDistributionUpdateRequest) Ks(ks string) ApiEntryDistributionUpdateRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryDistributionUpdateRequest) Format(format int32) ApiEntryDistributionUpdateRequest {
	r.format = &format
	return r
}

func (r ApiEntryDistributionUpdateRequest) ClientTag(clientTag string) ApiEntryDistributionUpdateRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryDistributionUpdateRequest) PartnerId(partnerId int32) ApiEntryDistributionUpdateRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryDistributionUpdateRequest) Body(body EntryDistributionUpdateRequest) ApiEntryDistributionUpdateRequest {
	r.body = &body
	return r
}

func (r ApiEntryDistributionUpdateRequest) Execute() (*KalturaEntryDistribution, *http.Response, error) {
	return r.ApiService.EntryDistributionUpdateExecute(r)
}

/*
EntryDistributionUpdate Method for EntryDistributionUpdate

Update Entry Distribution by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryDistributionUpdateRequest
*/
func (a *EntryDistributionApiService) EntryDistributionUpdate(ctx context.Context) ApiEntryDistributionUpdateRequest {
	return ApiEntryDistributionUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEntryDistribution
func (a *EntryDistributionApiService) EntryDistributionUpdateExecute(r ApiEntryDistributionUpdateRequest) (*KalturaEntryDistribution, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEntryDistribution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryDistributionApiService.EntryDistributionUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/contentdistribution_entrydistribution/action/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEntryDistributionValidateRequest struct {
	ctx context.Context
	ApiService *EntryDistributionApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AccessControlDeleteRequest
}

func (r ApiEntryDistributionValidateRequest) Ks(ks string) ApiEntryDistributionValidateRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEntryDistributionValidateRequest) Format(format int32) ApiEntryDistributionValidateRequest {
	r.format = &format
	return r
}

func (r ApiEntryDistributionValidateRequest) ClientTag(clientTag string) ApiEntryDistributionValidateRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEntryDistributionValidateRequest) PartnerId(partnerId int32) ApiEntryDistributionValidateRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEntryDistributionValidateRequest) Body(body AccessControlDeleteRequest) ApiEntryDistributionValidateRequest {
	r.body = &body
	return r
}

func (r ApiEntryDistributionValidateRequest) Execute() (*KalturaEntryDistribution, *http.Response, error) {
	return r.ApiService.EntryDistributionValidateExecute(r)
}

/*
EntryDistributionValidate Method for EntryDistributionValidate

Validates Entry Distribution by id for submission

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEntryDistributionValidateRequest
*/
func (a *EntryDistributionApiService) EntryDistributionValidate(ctx context.Context) ApiEntryDistributionValidateRequest {
	return ApiEntryDistributionValidateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEntryDistribution
func (a *EntryDistributionApiService) EntryDistributionValidateExecute(r ApiEntryDistributionValidateRequest) (*KalturaEntryDistribution, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEntryDistribution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EntryDistributionApiService.EntryDistributionValidate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/contentdistribution_entrydistribution/action/validate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
