/*
Kaltura VPaaS

The Kaltura VPaaS API

API version: 18.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
)


// MediaApiService MediaApi service
type MediaApiService service

type ApiMediaAddRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *MediaAddRequest
}

func (r ApiMediaAddRequest) Ks(ks string) ApiMediaAddRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaAddRequest) Format(format int32) ApiMediaAddRequest {
	r.format = &format
	return r
}

func (r ApiMediaAddRequest) ClientTag(clientTag string) ApiMediaAddRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaAddRequest) PartnerId(partnerId int32) ApiMediaAddRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaAddRequest) Body(body MediaAddRequest) ApiMediaAddRequest {
	r.body = &body
	return r
}

func (r ApiMediaAddRequest) Execute() (*KalturaMediaEntry, *http.Response, error) {
	return r.ApiService.MediaAddExecute(r)
}

/*
MediaAdd Method for MediaAdd

Add entry

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaAddRequest
*/
func (a *MediaApiService) MediaAdd(ctx context.Context) ApiMediaAddRequest {
	return ApiMediaAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMediaEntry
func (a *MediaApiService) MediaAddExecute(r ApiMediaAddRequest) (*KalturaMediaEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMediaEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaAddContentRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *MediaAddContentRequest
}

func (r ApiMediaAddContentRequest) Ks(ks string) ApiMediaAddContentRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaAddContentRequest) Format(format int32) ApiMediaAddContentRequest {
	r.format = &format
	return r
}

func (r ApiMediaAddContentRequest) ClientTag(clientTag string) ApiMediaAddContentRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaAddContentRequest) PartnerId(partnerId int32) ApiMediaAddContentRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaAddContentRequest) Body(body MediaAddContentRequest) ApiMediaAddContentRequest {
	r.body = &body
	return r
}

func (r ApiMediaAddContentRequest) Execute() (*KalturaMediaEntry, *http.Response, error) {
	return r.ApiService.MediaAddContentExecute(r)
}

/*
MediaAddContent Method for MediaAddContent

Add content to media entry which is not yet associated with content (therefore is in status NO_CONTENT).
     If the requirement is to replace the entry's associated content, use action updateContent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaAddContentRequest
*/
func (a *MediaApiService) MediaAddContent(ctx context.Context) ApiMediaAddContentRequest {
	return ApiMediaAddContentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMediaEntry
func (a *MediaApiService) MediaAddContentExecute(r ApiMediaAddContentRequest) (*KalturaMediaEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMediaEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaAddContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/addContent"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaAddFromBulkRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *MediaAddFromBulkRequest
}

func (r ApiMediaAddFromBulkRequest) Ks(ks string) ApiMediaAddFromBulkRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaAddFromBulkRequest) Format(format int32) ApiMediaAddFromBulkRequest {
	r.format = &format
	return r
}

func (r ApiMediaAddFromBulkRequest) ClientTag(clientTag string) ApiMediaAddFromBulkRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaAddFromBulkRequest) PartnerId(partnerId int32) ApiMediaAddFromBulkRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaAddFromBulkRequest) Body(body MediaAddFromBulkRequest) ApiMediaAddFromBulkRequest {
	r.body = &body
	return r
}

func (r ApiMediaAddFromBulkRequest) Execute() (*KalturaMediaEntry, *http.Response, error) {
	return r.ApiService.MediaAddFromBulkExecute(r)
}

/*
MediaAddFromBulk Method for MediaAddFromBulk

Adds new media entry by importing an HTTP or FTP URL.

The entry will be queued for import and then for conversion.

This action should be exposed only to the batches

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaAddFromBulkRequest

Deprecated
*/
func (a *MediaApiService) MediaAddFromBulk(ctx context.Context) ApiMediaAddFromBulkRequest {
	return ApiMediaAddFromBulkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMediaEntry
// Deprecated
func (a *MediaApiService) MediaAddFromBulkExecute(r ApiMediaAddFromBulkRequest) (*KalturaMediaEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMediaEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaAddFromBulk")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/addFromBulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaAddFromEntryRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *MediaAddFromEntryRequest
}

func (r ApiMediaAddFromEntryRequest) Ks(ks string) ApiMediaAddFromEntryRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaAddFromEntryRequest) Format(format int32) ApiMediaAddFromEntryRequest {
	r.format = &format
	return r
}

func (r ApiMediaAddFromEntryRequest) ClientTag(clientTag string) ApiMediaAddFromEntryRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaAddFromEntryRequest) PartnerId(partnerId int32) ApiMediaAddFromEntryRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaAddFromEntryRequest) Body(body MediaAddFromEntryRequest) ApiMediaAddFromEntryRequest {
	r.body = &body
	return r
}

func (r ApiMediaAddFromEntryRequest) Execute() (*KalturaMediaEntry, *http.Response, error) {
	return r.ApiService.MediaAddFromEntryExecute(r)
}

/*
MediaAddFromEntry Method for MediaAddFromEntry

Copy entry into new entry

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaAddFromEntryRequest

Deprecated
*/
func (a *MediaApiService) MediaAddFromEntry(ctx context.Context) ApiMediaAddFromEntryRequest {
	return ApiMediaAddFromEntryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMediaEntry
// Deprecated
func (a *MediaApiService) MediaAddFromEntryExecute(r ApiMediaAddFromEntryRequest) (*KalturaMediaEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMediaEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaAddFromEntry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/addFromEntry"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaAddFromFlavorAssetRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *MediaAddFromFlavorAssetRequest
}

func (r ApiMediaAddFromFlavorAssetRequest) Ks(ks string) ApiMediaAddFromFlavorAssetRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaAddFromFlavorAssetRequest) Format(format int32) ApiMediaAddFromFlavorAssetRequest {
	r.format = &format
	return r
}

func (r ApiMediaAddFromFlavorAssetRequest) ClientTag(clientTag string) ApiMediaAddFromFlavorAssetRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaAddFromFlavorAssetRequest) PartnerId(partnerId int32) ApiMediaAddFromFlavorAssetRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaAddFromFlavorAssetRequest) Body(body MediaAddFromFlavorAssetRequest) ApiMediaAddFromFlavorAssetRequest {
	r.body = &body
	return r
}

func (r ApiMediaAddFromFlavorAssetRequest) Execute() (*KalturaMediaEntry, *http.Response, error) {
	return r.ApiService.MediaAddFromFlavorAssetExecute(r)
}

/*
MediaAddFromFlavorAsset Method for MediaAddFromFlavorAsset

Copy flavor asset into new entry

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaAddFromFlavorAssetRequest

Deprecated
*/
func (a *MediaApiService) MediaAddFromFlavorAsset(ctx context.Context) ApiMediaAddFromFlavorAssetRequest {
	return ApiMediaAddFromFlavorAssetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMediaEntry
// Deprecated
func (a *MediaApiService) MediaAddFromFlavorAssetExecute(r ApiMediaAddFromFlavorAssetRequest) (*KalturaMediaEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMediaEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaAddFromFlavorAsset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/addFromFlavorAsset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaAddFromRecordedWebcamRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *MediaAddFromRecordedWebcamRequest
}

func (r ApiMediaAddFromRecordedWebcamRequest) Ks(ks string) ApiMediaAddFromRecordedWebcamRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaAddFromRecordedWebcamRequest) Format(format int32) ApiMediaAddFromRecordedWebcamRequest {
	r.format = &format
	return r
}

func (r ApiMediaAddFromRecordedWebcamRequest) ClientTag(clientTag string) ApiMediaAddFromRecordedWebcamRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaAddFromRecordedWebcamRequest) PartnerId(partnerId int32) ApiMediaAddFromRecordedWebcamRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaAddFromRecordedWebcamRequest) Body(body MediaAddFromRecordedWebcamRequest) ApiMediaAddFromRecordedWebcamRequest {
	r.body = &body
	return r
}

func (r ApiMediaAddFromRecordedWebcamRequest) Execute() (*KalturaMediaEntry, *http.Response, error) {
	return r.ApiService.MediaAddFromRecordedWebcamExecute(r)
}

/*
MediaAddFromRecordedWebcam Method for MediaAddFromRecordedWebcam

Add new entry after the file was recorded on the server and the token id exists

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaAddFromRecordedWebcamRequest

Deprecated
*/
func (a *MediaApiService) MediaAddFromRecordedWebcam(ctx context.Context) ApiMediaAddFromRecordedWebcamRequest {
	return ApiMediaAddFromRecordedWebcamRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMediaEntry
// Deprecated
func (a *MediaApiService) MediaAddFromRecordedWebcamExecute(r ApiMediaAddFromRecordedWebcamRequest) (*KalturaMediaEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMediaEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaAddFromRecordedWebcam")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/addFromRecordedWebcam"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaAddFromSearchResultRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *MediaAddFromSearchResultRequest
}

func (r ApiMediaAddFromSearchResultRequest) Ks(ks string) ApiMediaAddFromSearchResultRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaAddFromSearchResultRequest) Format(format int32) ApiMediaAddFromSearchResultRequest {
	r.format = &format
	return r
}

func (r ApiMediaAddFromSearchResultRequest) ClientTag(clientTag string) ApiMediaAddFromSearchResultRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaAddFromSearchResultRequest) PartnerId(partnerId int32) ApiMediaAddFromSearchResultRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaAddFromSearchResultRequest) Body(body MediaAddFromSearchResultRequest) ApiMediaAddFromSearchResultRequest {
	r.body = &body
	return r
}

func (r ApiMediaAddFromSearchResultRequest) Execute() (*KalturaMediaEntry, *http.Response, error) {
	return r.ApiService.MediaAddFromSearchResultExecute(r)
}

/*
MediaAddFromSearchResult Method for MediaAddFromSearchResult

Adds new media entry by importing the media file from a search provider.

This action should be used with the search service result.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaAddFromSearchResultRequest

Deprecated
*/
func (a *MediaApiService) MediaAddFromSearchResult(ctx context.Context) ApiMediaAddFromSearchResultRequest {
	return ApiMediaAddFromSearchResultRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMediaEntry
// Deprecated
func (a *MediaApiService) MediaAddFromSearchResultExecute(r ApiMediaAddFromSearchResultRequest) (*KalturaMediaEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMediaEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaAddFromSearchResult")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/addFromSearchResult"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaAddFromUploadedFileRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *MediaAddFromUploadedFileRequest
}

func (r ApiMediaAddFromUploadedFileRequest) Ks(ks string) ApiMediaAddFromUploadedFileRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaAddFromUploadedFileRequest) Format(format int32) ApiMediaAddFromUploadedFileRequest {
	r.format = &format
	return r
}

func (r ApiMediaAddFromUploadedFileRequest) ClientTag(clientTag string) ApiMediaAddFromUploadedFileRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaAddFromUploadedFileRequest) PartnerId(partnerId int32) ApiMediaAddFromUploadedFileRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaAddFromUploadedFileRequest) Body(body MediaAddFromUploadedFileRequest) ApiMediaAddFromUploadedFileRequest {
	r.body = &body
	return r
}

func (r ApiMediaAddFromUploadedFileRequest) Execute() (*KalturaMediaEntry, *http.Response, error) {
	return r.ApiService.MediaAddFromUploadedFileExecute(r)
}

/*
MediaAddFromUploadedFile Method for MediaAddFromUploadedFile

Add new entry after the specific media file was uploaded and the upload token id exists

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaAddFromUploadedFileRequest

Deprecated
*/
func (a *MediaApiService) MediaAddFromUploadedFile(ctx context.Context) ApiMediaAddFromUploadedFileRequest {
	return ApiMediaAddFromUploadedFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMediaEntry
// Deprecated
func (a *MediaApiService) MediaAddFromUploadedFileExecute(r ApiMediaAddFromUploadedFileRequest) (*KalturaMediaEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMediaEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaAddFromUploadedFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/addFromUploadedFile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaAddFromUrlRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *MediaAddFromUrlRequest
}

func (r ApiMediaAddFromUrlRequest) Ks(ks string) ApiMediaAddFromUrlRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaAddFromUrlRequest) Format(format int32) ApiMediaAddFromUrlRequest {
	r.format = &format
	return r
}

func (r ApiMediaAddFromUrlRequest) ClientTag(clientTag string) ApiMediaAddFromUrlRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaAddFromUrlRequest) PartnerId(partnerId int32) ApiMediaAddFromUrlRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaAddFromUrlRequest) Body(body MediaAddFromUrlRequest) ApiMediaAddFromUrlRequest {
	r.body = &body
	return r
}

func (r ApiMediaAddFromUrlRequest) Execute() (*KalturaMediaEntry, *http.Response, error) {
	return r.ApiService.MediaAddFromUrlExecute(r)
}

/*
MediaAddFromUrl Method for MediaAddFromUrl

Adds new media entry by importing an HTTP or FTP URL.

The entry will be queued for import and then for conversion.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaAddFromUrlRequest

Deprecated
*/
func (a *MediaApiService) MediaAddFromUrl(ctx context.Context) ApiMediaAddFromUrlRequest {
	return ApiMediaAddFromUrlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMediaEntry
// Deprecated
func (a *MediaApiService) MediaAddFromUrlExecute(r ApiMediaAddFromUrlRequest) (*KalturaMediaEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMediaEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaAddFromUrl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/addFromUrl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaAnonymousRankRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryAnonymousRankRequest
}

func (r ApiMediaAnonymousRankRequest) Ks(ks string) ApiMediaAnonymousRankRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaAnonymousRankRequest) Format(format int32) ApiMediaAnonymousRankRequest {
	r.format = &format
	return r
}

func (r ApiMediaAnonymousRankRequest) ClientTag(clientTag string) ApiMediaAnonymousRankRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaAnonymousRankRequest) PartnerId(partnerId int32) ApiMediaAnonymousRankRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaAnonymousRankRequest) Body(body BaseEntryAnonymousRankRequest) ApiMediaAnonymousRankRequest {
	r.body = &body
	return r
}

func (r ApiMediaAnonymousRankRequest) Execute() (*http.Response, error) {
	return r.ApiService.MediaAnonymousRankExecute(r)
}

/*
MediaAnonymousRank Method for MediaAnonymousRank

Anonymously rank a media entry, no validation is done on duplicate rankings

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaAnonymousRankRequest
*/
func (a *MediaApiService) MediaAnonymousRank(ctx context.Context) ApiMediaAnonymousRankRequest {
	return ApiMediaAnonymousRankRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MediaApiService) MediaAnonymousRankExecute(r ApiMediaAnonymousRankRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaAnonymousRank")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/anonymousRank"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMediaApproveRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryApproveRequest
}

func (r ApiMediaApproveRequest) Ks(ks string) ApiMediaApproveRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaApproveRequest) Format(format int32) ApiMediaApproveRequest {
	r.format = &format
	return r
}

func (r ApiMediaApproveRequest) ClientTag(clientTag string) ApiMediaApproveRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaApproveRequest) PartnerId(partnerId int32) ApiMediaApproveRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaApproveRequest) Body(body BaseEntryApproveRequest) ApiMediaApproveRequest {
	r.body = &body
	return r
}

func (r ApiMediaApproveRequest) Execute() (*http.Response, error) {
	return r.ApiService.MediaApproveExecute(r)
}

/*
MediaApprove Method for MediaApprove

Approve the media entry and mark the pending flags (if any) as moderated (this will make the entry playable)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaApproveRequest
*/
func (a *MediaApiService) MediaApprove(ctx context.Context) ApiMediaApproveRequest {
	return ApiMediaApproveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MediaApiService) MediaApproveExecute(r ApiMediaApproveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaApprove")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/approve"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMediaApproveReplaceRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryApproveRequest
}

func (r ApiMediaApproveReplaceRequest) Ks(ks string) ApiMediaApproveReplaceRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaApproveReplaceRequest) Format(format int32) ApiMediaApproveReplaceRequest {
	r.format = &format
	return r
}

func (r ApiMediaApproveReplaceRequest) ClientTag(clientTag string) ApiMediaApproveReplaceRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaApproveReplaceRequest) PartnerId(partnerId int32) ApiMediaApproveReplaceRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaApproveReplaceRequest) Body(body BaseEntryApproveRequest) ApiMediaApproveReplaceRequest {
	r.body = &body
	return r
}

func (r ApiMediaApproveReplaceRequest) Execute() (*KalturaMediaEntry, *http.Response, error) {
	return r.ApiService.MediaApproveReplaceExecute(r)
}

/*
MediaApproveReplace Method for MediaApproveReplace

Approves media replacement

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaApproveReplaceRequest
*/
func (a *MediaApiService) MediaApproveReplace(ctx context.Context) ApiMediaApproveReplaceRequest {
	return ApiMediaApproveReplaceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMediaEntry
func (a *MediaApiService) MediaApproveReplaceExecute(r ApiMediaApproveReplaceRequest) (*KalturaMediaEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMediaEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaApproveReplace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/approveReplace"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaBulkUploadAddRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	fileData **os.File
	ks *string
	format *int32
	bulkUploadDataObjectType *string
	bulkUploadDataFileName *string
	bulkUploadDataObjectDataObjectType *string
	bulkUploadDataEmailRecipients *string
	bulkUploadDataNumOfErrorObjects *int32
	bulkUploadDataPrivileges *string
	bulkUploadEntryDataObjectType *string
	bulkUploadEntryDataConversionProfileId *int32
}

func (r ApiMediaBulkUploadAddRequest) FileData(fileData *os.File) ApiMediaBulkUploadAddRequest {
	r.fileData = &fileData
	return r
}

func (r ApiMediaBulkUploadAddRequest) Ks(ks string) ApiMediaBulkUploadAddRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaBulkUploadAddRequest) Format(format int32) ApiMediaBulkUploadAddRequest {
	r.format = &format
	return r
}

func (r ApiMediaBulkUploadAddRequest) BulkUploadDataObjectType(bulkUploadDataObjectType string) ApiMediaBulkUploadAddRequest {
	r.bulkUploadDataObjectType = &bulkUploadDataObjectType
	return r
}

// Friendly name of the file, used to be recognized later in the logs.
func (r ApiMediaBulkUploadAddRequest) BulkUploadDataFileName(bulkUploadDataFileName string) ApiMediaBulkUploadAddRequest {
	r.bulkUploadDataFileName = &bulkUploadDataFileName
	return r
}

func (r ApiMediaBulkUploadAddRequest) BulkUploadDataObjectDataObjectType(bulkUploadDataObjectDataObjectType string) ApiMediaBulkUploadAddRequest {
	r.bulkUploadDataObjectDataObjectType = &bulkUploadDataObjectDataObjectType
	return r
}

// Recipients of the email for bulk upload success/failure
func (r ApiMediaBulkUploadAddRequest) BulkUploadDataEmailRecipients(bulkUploadDataEmailRecipients string) ApiMediaBulkUploadAddRequest {
	r.bulkUploadDataEmailRecipients = &bulkUploadDataEmailRecipients
	return r
}

// Number of objects that finished on error status
func (r ApiMediaBulkUploadAddRequest) BulkUploadDataNumOfErrorObjects(bulkUploadDataNumOfErrorObjects int32) ApiMediaBulkUploadAddRequest {
	r.bulkUploadDataNumOfErrorObjects = &bulkUploadDataNumOfErrorObjects
	return r
}

// privileges for the job
func (r ApiMediaBulkUploadAddRequest) BulkUploadDataPrivileges(bulkUploadDataPrivileges string) ApiMediaBulkUploadAddRequest {
	r.bulkUploadDataPrivileges = &bulkUploadDataPrivileges
	return r
}

func (r ApiMediaBulkUploadAddRequest) BulkUploadEntryDataObjectType(bulkUploadEntryDataObjectType string) ApiMediaBulkUploadAddRequest {
	r.bulkUploadEntryDataObjectType = &bulkUploadEntryDataObjectType
	return r
}

// Selected profile id for all bulk entries
func (r ApiMediaBulkUploadAddRequest) BulkUploadEntryDataConversionProfileId(bulkUploadEntryDataConversionProfileId int32) ApiMediaBulkUploadAddRequest {
	r.bulkUploadEntryDataConversionProfileId = &bulkUploadEntryDataConversionProfileId
	return r
}

func (r ApiMediaBulkUploadAddRequest) Execute() (*KalturaBulkUpload, *http.Response, error) {
	return r.ApiService.MediaBulkUploadAddExecute(r)
}

/*
MediaBulkUploadAdd Method for MediaBulkUploadAdd

Add new bulk upload batch job

Conversion profile id can be specified in the API or in the CSV file, the one in the CSV file will be stronger.

If no conversion profile was specified, partner's default will be used

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaBulkUploadAddRequest
*/
func (a *MediaApiService) MediaBulkUploadAdd(ctx context.Context) ApiMediaBulkUploadAddRequest {
	return ApiMediaBulkUploadAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBulkUpload
func (a *MediaApiService) MediaBulkUploadAddExecute(r ApiMediaBulkUploadAddRequest) (*KalturaBulkUpload, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBulkUpload
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaBulkUploadAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/bulkUploadAdd"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileData == nil {
		return localVarReturnValue, nil, reportError("fileData is required and must be specified")
	}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.bulkUploadDataObjectType != nil {
		localVarQueryParams.Add("bulkUploadData[objectType]", parameterToString(*r.bulkUploadDataObjectType, ""))
	}
	if r.bulkUploadDataFileName != nil {
		localVarQueryParams.Add("bulkUploadData[fileName]", parameterToString(*r.bulkUploadDataFileName, ""))
	}
	if r.bulkUploadDataObjectDataObjectType != nil {
		localVarQueryParams.Add("bulkUploadData[objectData][objectType]", parameterToString(*r.bulkUploadDataObjectDataObjectType, ""))
	}
	if r.bulkUploadDataEmailRecipients != nil {
		localVarQueryParams.Add("bulkUploadData[emailRecipients]", parameterToString(*r.bulkUploadDataEmailRecipients, ""))
	}
	if r.bulkUploadDataNumOfErrorObjects != nil {
		localVarQueryParams.Add("bulkUploadData[numOfErrorObjects]", parameterToString(*r.bulkUploadDataNumOfErrorObjects, ""))
	}
	if r.bulkUploadDataPrivileges != nil {
		localVarQueryParams.Add("bulkUploadData[privileges]", parameterToString(*r.bulkUploadDataPrivileges, ""))
	}
	if r.bulkUploadEntryDataObjectType != nil {
		localVarQueryParams.Add("bulkUploadEntryData[objectType]", parameterToString(*r.bulkUploadEntryDataObjectType, ""))
	}
	if r.bulkUploadEntryDataConversionProfileId != nil {
		localVarQueryParams.Add("bulkUploadEntryData[conversionProfileId]", parameterToString(*r.bulkUploadEntryDataConversionProfileId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileDataLocalVarFormFileName string
	var fileDataLocalVarFileName     string
	var fileDataLocalVarFileBytes    []byte

	fileDataLocalVarFormFileName = "fileData"

	fileDataLocalVarFile := *r.fileData
	if fileDataLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(fileDataLocalVarFile)
		fileDataLocalVarFileBytes = fbs
		fileDataLocalVarFileName = fileDataLocalVarFile.Name()
		fileDataLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: fileDataLocalVarFileBytes, fileName: fileDataLocalVarFileName, formFileName: fileDataLocalVarFormFileName})
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaCancelReplaceRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryApproveRequest
}

func (r ApiMediaCancelReplaceRequest) Ks(ks string) ApiMediaCancelReplaceRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaCancelReplaceRequest) Format(format int32) ApiMediaCancelReplaceRequest {
	r.format = &format
	return r
}

func (r ApiMediaCancelReplaceRequest) ClientTag(clientTag string) ApiMediaCancelReplaceRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaCancelReplaceRequest) PartnerId(partnerId int32) ApiMediaCancelReplaceRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaCancelReplaceRequest) Body(body BaseEntryApproveRequest) ApiMediaCancelReplaceRequest {
	r.body = &body
	return r
}

func (r ApiMediaCancelReplaceRequest) Execute() (*KalturaMediaEntry, *http.Response, error) {
	return r.ApiService.MediaCancelReplaceExecute(r)
}

/*
MediaCancelReplace Method for MediaCancelReplace

Cancels media replacement

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaCancelReplaceRequest
*/
func (a *MediaApiService) MediaCancelReplace(ctx context.Context) ApiMediaCancelReplaceRequest {
	return ApiMediaCancelReplaceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMediaEntry
func (a *MediaApiService) MediaCancelReplaceExecute(r ApiMediaCancelReplaceRequest) (*KalturaMediaEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMediaEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaCancelReplace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/cancelReplace"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaConvertRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *DocumentsConvertRequest
}

func (r ApiMediaConvertRequest) Ks(ks string) ApiMediaConvertRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaConvertRequest) Format(format int32) ApiMediaConvertRequest {
	r.format = &format
	return r
}

func (r ApiMediaConvertRequest) ClientTag(clientTag string) ApiMediaConvertRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaConvertRequest) PartnerId(partnerId int32) ApiMediaConvertRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaConvertRequest) Body(body DocumentsConvertRequest) ApiMediaConvertRequest {
	r.body = &body
	return r
}

func (r ApiMediaConvertRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.MediaConvertExecute(r)
}

/*
MediaConvert Method for MediaConvert

Convert entry

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaConvertRequest
*/
func (a *MediaApiService) MediaConvert(ctx context.Context) ApiMediaConvertRequest {
	return ApiMediaConvertRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return int32
func (a *MediaApiService) MediaConvertExecute(r ApiMediaConvertRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaConvert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/convert"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaCountRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *MediaCountRequest
}

func (r ApiMediaCountRequest) Ks(ks string) ApiMediaCountRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaCountRequest) Format(format int32) ApiMediaCountRequest {
	r.format = &format
	return r
}

func (r ApiMediaCountRequest) ClientTag(clientTag string) ApiMediaCountRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaCountRequest) PartnerId(partnerId int32) ApiMediaCountRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaCountRequest) Body(body MediaCountRequest) ApiMediaCountRequest {
	r.body = &body
	return r
}

func (r ApiMediaCountRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.MediaCountExecute(r)
}

/*
MediaCount Method for MediaCount

Count media entries by filter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaCountRequest
*/
func (a *MediaApiService) MediaCount(ctx context.Context) ApiMediaCountRequest {
	return ApiMediaCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return int32
func (a *MediaApiService) MediaCountExecute(r ApiMediaCountRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaDeleteRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryApproveRequest
}

func (r ApiMediaDeleteRequest) Ks(ks string) ApiMediaDeleteRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaDeleteRequest) Format(format int32) ApiMediaDeleteRequest {
	r.format = &format
	return r
}

func (r ApiMediaDeleteRequest) ClientTag(clientTag string) ApiMediaDeleteRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaDeleteRequest) PartnerId(partnerId int32) ApiMediaDeleteRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaDeleteRequest) Body(body BaseEntryApproveRequest) ApiMediaDeleteRequest {
	r.body = &body
	return r
}

func (r ApiMediaDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.MediaDeleteExecute(r)
}

/*
MediaDelete Method for MediaDelete

Delete a media entry.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaDeleteRequest
*/
func (a *MediaApiService) MediaDelete(ctx context.Context) ApiMediaDeleteRequest {
	return ApiMediaDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MediaApiService) MediaDeleteExecute(r ApiMediaDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMediaExportToCsvRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *MediaExportToCsvRequest
}

func (r ApiMediaExportToCsvRequest) Ks(ks string) ApiMediaExportToCsvRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaExportToCsvRequest) Format(format int32) ApiMediaExportToCsvRequest {
	r.format = &format
	return r
}

func (r ApiMediaExportToCsvRequest) ClientTag(clientTag string) ApiMediaExportToCsvRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaExportToCsvRequest) PartnerId(partnerId int32) ApiMediaExportToCsvRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaExportToCsvRequest) Body(body MediaExportToCsvRequest) ApiMediaExportToCsvRequest {
	r.body = &body
	return r
}

func (r ApiMediaExportToCsvRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.MediaExportToCsvExecute(r)
}

/*
MediaExportToCsv Method for MediaExportToCsv

Creates a batch job that sends an email with a link to download a CSV containing a list of entries

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaExportToCsvRequest
*/
func (a *MediaApiService) MediaExportToCsv(ctx context.Context) ApiMediaExportToCsvRequest {
	return ApiMediaExportToCsvRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *MediaApiService) MediaExportToCsvExecute(r ApiMediaExportToCsvRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaExportToCsv")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/exportToCsv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaFlagRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryFlagRequest
}

func (r ApiMediaFlagRequest) Ks(ks string) ApiMediaFlagRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaFlagRequest) Format(format int32) ApiMediaFlagRequest {
	r.format = &format
	return r
}

func (r ApiMediaFlagRequest) ClientTag(clientTag string) ApiMediaFlagRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaFlagRequest) PartnerId(partnerId int32) ApiMediaFlagRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaFlagRequest) Body(body BaseEntryFlagRequest) ApiMediaFlagRequest {
	r.body = &body
	return r
}

func (r ApiMediaFlagRequest) Execute() (*http.Response, error) {
	return r.ApiService.MediaFlagExecute(r)
}

/*
MediaFlag Method for MediaFlag

Flag inappropriate media entry for moderation

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaFlagRequest
*/
func (a *MediaApiService) MediaFlag(ctx context.Context) ApiMediaFlagRequest {
	return ApiMediaFlagRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MediaApiService) MediaFlagExecute(r ApiMediaFlagRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaFlag")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/flag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMediaGetRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *MediaGetRequest
}

func (r ApiMediaGetRequest) Ks(ks string) ApiMediaGetRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaGetRequest) Format(format int32) ApiMediaGetRequest {
	r.format = &format
	return r
}

func (r ApiMediaGetRequest) ClientTag(clientTag string) ApiMediaGetRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaGetRequest) PartnerId(partnerId int32) ApiMediaGetRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaGetRequest) Body(body MediaGetRequest) ApiMediaGetRequest {
	r.body = &body
	return r
}

func (r ApiMediaGetRequest) Execute() (*KalturaMediaEntry, *http.Response, error) {
	return r.ApiService.MediaGetExecute(r)
}

/*
MediaGet Method for MediaGet

Get media entry by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaGetRequest
*/
func (a *MediaApiService) MediaGet(ctx context.Context) ApiMediaGetRequest {
	return ApiMediaGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMediaEntry
func (a *MediaApiService) MediaGetExecute(r ApiMediaGetRequest) (*KalturaMediaEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMediaEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaGetMrssRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *MediaGetMrssRequest
}

func (r ApiMediaGetMrssRequest) Ks(ks string) ApiMediaGetMrssRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaGetMrssRequest) Format(format int32) ApiMediaGetMrssRequest {
	r.format = &format
	return r
}

func (r ApiMediaGetMrssRequest) ClientTag(clientTag string) ApiMediaGetMrssRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaGetMrssRequest) PartnerId(partnerId int32) ApiMediaGetMrssRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaGetMrssRequest) Body(body MediaGetMrssRequest) ApiMediaGetMrssRequest {
	r.body = &body
	return r
}

func (r ApiMediaGetMrssRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.MediaGetMrssExecute(r)
}

/*
MediaGetMrss Method for MediaGetMrss

Get MRSS by entry id
     XML will return as an escaped string

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaGetMrssRequest
*/
func (a *MediaApiService) MediaGetMrss(ctx context.Context) ApiMediaGetMrssRequest {
	return ApiMediaGetMrssRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *MediaApiService) MediaGetMrssExecute(r ApiMediaGetMrssRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaGetMrss")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/getMrss"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaGetVolumeMapRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryApproveRequest
}

func (r ApiMediaGetVolumeMapRequest) Ks(ks string) ApiMediaGetVolumeMapRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaGetVolumeMapRequest) Format(format int32) ApiMediaGetVolumeMapRequest {
	r.format = &format
	return r
}

func (r ApiMediaGetVolumeMapRequest) ClientTag(clientTag string) ApiMediaGetVolumeMapRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaGetVolumeMapRequest) PartnerId(partnerId int32) ApiMediaGetVolumeMapRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaGetVolumeMapRequest) Body(body BaseEntryApproveRequest) ApiMediaGetVolumeMapRequest {
	r.body = &body
	return r
}

func (r ApiMediaGetVolumeMapRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.MediaGetVolumeMapExecute(r)
}

/*
MediaGetVolumeMap Method for MediaGetVolumeMap

Get volume map by entry id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaGetVolumeMapRequest
*/
func (a *MediaApiService) MediaGetVolumeMap(ctx context.Context) ApiMediaGetVolumeMapRequest {
	return ApiMediaGetVolumeMapRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *MediaApiService) MediaGetVolumeMapExecute(r ApiMediaGetVolumeMapRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaGetVolumeMap")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/getVolumeMap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaListRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *MediaListRequest
}

func (r ApiMediaListRequest) Ks(ks string) ApiMediaListRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaListRequest) Format(format int32) ApiMediaListRequest {
	r.format = &format
	return r
}

func (r ApiMediaListRequest) ClientTag(clientTag string) ApiMediaListRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaListRequest) PartnerId(partnerId int32) ApiMediaListRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaListRequest) Body(body MediaListRequest) ApiMediaListRequest {
	r.body = &body
	return r
}

func (r ApiMediaListRequest) Execute() (*KalturaMediaListResponse, *http.Response, error) {
	return r.ApiService.MediaListExecute(r)
}

/*
MediaList Method for MediaList

List media entries by filter with paging support.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaListRequest
*/
func (a *MediaApiService) MediaList(ctx context.Context) ApiMediaListRequest {
	return ApiMediaListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMediaListResponse
func (a *MediaApiService) MediaListExecute(r ApiMediaListRequest) (*KalturaMediaListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMediaListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaListFlagsRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryListFlagsRequest
}

func (r ApiMediaListFlagsRequest) Ks(ks string) ApiMediaListFlagsRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaListFlagsRequest) Format(format int32) ApiMediaListFlagsRequest {
	r.format = &format
	return r
}

func (r ApiMediaListFlagsRequest) ClientTag(clientTag string) ApiMediaListFlagsRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaListFlagsRequest) PartnerId(partnerId int32) ApiMediaListFlagsRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaListFlagsRequest) Body(body BaseEntryListFlagsRequest) ApiMediaListFlagsRequest {
	r.body = &body
	return r
}

func (r ApiMediaListFlagsRequest) Execute() (*KalturaModerationFlagListResponse, *http.Response, error) {
	return r.ApiService.MediaListFlagsExecute(r)
}

/*
MediaListFlags Method for MediaListFlags

List all pending flags for the media entry

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaListFlagsRequest
*/
func (a *MediaApiService) MediaListFlags(ctx context.Context) ApiMediaListFlagsRequest {
	return ApiMediaListFlagsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaModerationFlagListResponse
func (a *MediaApiService) MediaListFlagsExecute(r ApiMediaListFlagsRequest) (*KalturaModerationFlagListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaModerationFlagListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaListFlags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/listFlags"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaRejectRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryApproveRequest
}

func (r ApiMediaRejectRequest) Ks(ks string) ApiMediaRejectRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaRejectRequest) Format(format int32) ApiMediaRejectRequest {
	r.format = &format
	return r
}

func (r ApiMediaRejectRequest) ClientTag(clientTag string) ApiMediaRejectRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaRejectRequest) PartnerId(partnerId int32) ApiMediaRejectRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaRejectRequest) Body(body BaseEntryApproveRequest) ApiMediaRejectRequest {
	r.body = &body
	return r
}

func (r ApiMediaRejectRequest) Execute() (*http.Response, error) {
	return r.ApiService.MediaRejectExecute(r)
}

/*
MediaReject Method for MediaReject

Reject the media entry and mark the pending flags (if any) as moderated (this will make the entry non playable)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaRejectRequest
*/
func (a *MediaApiService) MediaReject(ctx context.Context) ApiMediaRejectRequest {
	return ApiMediaRejectRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MediaApiService) MediaRejectExecute(r ApiMediaRejectRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaReject")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/reject"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMediaRequestConversionRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *MediaRequestConversionRequest
}

func (r ApiMediaRequestConversionRequest) Ks(ks string) ApiMediaRequestConversionRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaRequestConversionRequest) Format(format int32) ApiMediaRequestConversionRequest {
	r.format = &format
	return r
}

func (r ApiMediaRequestConversionRequest) ClientTag(clientTag string) ApiMediaRequestConversionRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaRequestConversionRequest) PartnerId(partnerId int32) ApiMediaRequestConversionRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaRequestConversionRequest) Body(body MediaRequestConversionRequest) ApiMediaRequestConversionRequest {
	r.body = &body
	return r
}

func (r ApiMediaRequestConversionRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.MediaRequestConversionExecute(r)
}

/*
MediaRequestConversion Method for MediaRequestConversion

Request a new conversion job, this can be used to convert the media entry to a different format

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaRequestConversionRequest
*/
func (a *MediaApiService) MediaRequestConversion(ctx context.Context) ApiMediaRequestConversionRequest {
	return ApiMediaRequestConversionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return int32
func (a *MediaApiService) MediaRequestConversionExecute(r ApiMediaRequestConversionRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaRequestConversion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/requestConversion"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaUpdateRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *MediaUpdateRequest
}

func (r ApiMediaUpdateRequest) Ks(ks string) ApiMediaUpdateRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaUpdateRequest) Format(format int32) ApiMediaUpdateRequest {
	r.format = &format
	return r
}

func (r ApiMediaUpdateRequest) ClientTag(clientTag string) ApiMediaUpdateRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaUpdateRequest) PartnerId(partnerId int32) ApiMediaUpdateRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaUpdateRequest) Body(body MediaUpdateRequest) ApiMediaUpdateRequest {
	r.body = &body
	return r
}

func (r ApiMediaUpdateRequest) Execute() (*KalturaMediaEntry, *http.Response, error) {
	return r.ApiService.MediaUpdateExecute(r)
}

/*
MediaUpdate Method for MediaUpdate

Update media entry. Only the properties that were set will be updated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaUpdateRequest
*/
func (a *MediaApiService) MediaUpdate(ctx context.Context) ApiMediaUpdateRequest {
	return ApiMediaUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMediaEntry
func (a *MediaApiService) MediaUpdateExecute(r ApiMediaUpdateRequest) (*KalturaMediaEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMediaEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaUpdateContentRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryUpdateContentRequest
}

func (r ApiMediaUpdateContentRequest) Ks(ks string) ApiMediaUpdateContentRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaUpdateContentRequest) Format(format int32) ApiMediaUpdateContentRequest {
	r.format = &format
	return r
}

func (r ApiMediaUpdateContentRequest) ClientTag(clientTag string) ApiMediaUpdateContentRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaUpdateContentRequest) PartnerId(partnerId int32) ApiMediaUpdateContentRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaUpdateContentRequest) Body(body BaseEntryUpdateContentRequest) ApiMediaUpdateContentRequest {
	r.body = &body
	return r
}

func (r ApiMediaUpdateContentRequest) Execute() (*KalturaMediaEntry, *http.Response, error) {
	return r.ApiService.MediaUpdateContentExecute(r)
}

/*
MediaUpdateContent Method for MediaUpdateContent

Replace content associated with the media entry.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaUpdateContentRequest
*/
func (a *MediaApiService) MediaUpdateContent(ctx context.Context) ApiMediaUpdateContentRequest {
	return ApiMediaUpdateContentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMediaEntry
func (a *MediaApiService) MediaUpdateContentExecute(r ApiMediaUpdateContentRequest) (*KalturaMediaEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMediaEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaUpdateContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/updateContent"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaUpdateThumbnailRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *MediaUpdateThumbnailRequest
}

func (r ApiMediaUpdateThumbnailRequest) Ks(ks string) ApiMediaUpdateThumbnailRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaUpdateThumbnailRequest) Format(format int32) ApiMediaUpdateThumbnailRequest {
	r.format = &format
	return r
}

func (r ApiMediaUpdateThumbnailRequest) ClientTag(clientTag string) ApiMediaUpdateThumbnailRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaUpdateThumbnailRequest) PartnerId(partnerId int32) ApiMediaUpdateThumbnailRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaUpdateThumbnailRequest) Body(body MediaUpdateThumbnailRequest) ApiMediaUpdateThumbnailRequest {
	r.body = &body
	return r
}

func (r ApiMediaUpdateThumbnailRequest) Execute() (*KalturaMediaEntry, *http.Response, error) {
	return r.ApiService.MediaUpdateThumbnailExecute(r)
}

/*
MediaUpdateThumbnail Method for MediaUpdateThumbnail

Update media entry thumbnail by a specified time offset (In seconds)

If flavor params id not specified, source flavor will be used by default

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaUpdateThumbnailRequest

Deprecated
*/
func (a *MediaApiService) MediaUpdateThumbnail(ctx context.Context) ApiMediaUpdateThumbnailRequest {
	return ApiMediaUpdateThumbnailRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMediaEntry
// Deprecated
func (a *MediaApiService) MediaUpdateThumbnailExecute(r ApiMediaUpdateThumbnailRequest) (*KalturaMediaEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMediaEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaUpdateThumbnail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/updateThumbnail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaUpdateThumbnailFromSourceEntryRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *MediaUpdateThumbnailFromSourceEntryRequest
}

func (r ApiMediaUpdateThumbnailFromSourceEntryRequest) Ks(ks string) ApiMediaUpdateThumbnailFromSourceEntryRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaUpdateThumbnailFromSourceEntryRequest) Format(format int32) ApiMediaUpdateThumbnailFromSourceEntryRequest {
	r.format = &format
	return r
}

func (r ApiMediaUpdateThumbnailFromSourceEntryRequest) ClientTag(clientTag string) ApiMediaUpdateThumbnailFromSourceEntryRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaUpdateThumbnailFromSourceEntryRequest) PartnerId(partnerId int32) ApiMediaUpdateThumbnailFromSourceEntryRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaUpdateThumbnailFromSourceEntryRequest) Body(body MediaUpdateThumbnailFromSourceEntryRequest) ApiMediaUpdateThumbnailFromSourceEntryRequest {
	r.body = &body
	return r
}

func (r ApiMediaUpdateThumbnailFromSourceEntryRequest) Execute() (*KalturaMediaEntry, *http.Response, error) {
	return r.ApiService.MediaUpdateThumbnailFromSourceEntryExecute(r)
}

/*
MediaUpdateThumbnailFromSourceEntry Method for MediaUpdateThumbnailFromSourceEntry

Update media entry thumbnail from a different entry by a specified time offset (In seconds)

If flavor params id not specified, source flavor will be used by default

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaUpdateThumbnailFromSourceEntryRequest

Deprecated
*/
func (a *MediaApiService) MediaUpdateThumbnailFromSourceEntry(ctx context.Context) ApiMediaUpdateThumbnailFromSourceEntryRequest {
	return ApiMediaUpdateThumbnailFromSourceEntryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMediaEntry
// Deprecated
func (a *MediaApiService) MediaUpdateThumbnailFromSourceEntryExecute(r ApiMediaUpdateThumbnailFromSourceEntryRequest) (*KalturaMediaEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMediaEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaUpdateThumbnailFromSourceEntry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/updateThumbnailFromSourceEntry"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaUpdateThumbnailFromUrlRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryUpdateThumbnailFromUrlRequest
}

func (r ApiMediaUpdateThumbnailFromUrlRequest) Ks(ks string) ApiMediaUpdateThumbnailFromUrlRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaUpdateThumbnailFromUrlRequest) Format(format int32) ApiMediaUpdateThumbnailFromUrlRequest {
	r.format = &format
	return r
}

func (r ApiMediaUpdateThumbnailFromUrlRequest) ClientTag(clientTag string) ApiMediaUpdateThumbnailFromUrlRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiMediaUpdateThumbnailFromUrlRequest) PartnerId(partnerId int32) ApiMediaUpdateThumbnailFromUrlRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiMediaUpdateThumbnailFromUrlRequest) Body(body BaseEntryUpdateThumbnailFromUrlRequest) ApiMediaUpdateThumbnailFromUrlRequest {
	r.body = &body
	return r
}

func (r ApiMediaUpdateThumbnailFromUrlRequest) Execute() (*KalturaBaseEntry, *http.Response, error) {
	return r.ApiService.MediaUpdateThumbnailFromUrlExecute(r)
}

/*
MediaUpdateThumbnailFromUrl Method for MediaUpdateThumbnailFromUrl

Update entry thumbnail using URL

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaUpdateThumbnailFromUrlRequest

Deprecated
*/
func (a *MediaApiService) MediaUpdateThumbnailFromUrl(ctx context.Context) ApiMediaUpdateThumbnailFromUrlRequest {
	return ApiMediaUpdateThumbnailFromUrlRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaBaseEntry
// Deprecated
func (a *MediaApiService) MediaUpdateThumbnailFromUrlExecute(r ApiMediaUpdateThumbnailFromUrlRequest) (*KalturaBaseEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaBaseEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaUpdateThumbnailFromUrl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/updateThumbnailFromUrl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaUpdateThumbnailJpegRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	entryId *string
	fileData **os.File
	ks *string
	format *int32
}

// Media entry id
func (r ApiMediaUpdateThumbnailJpegRequest) EntryId(entryId string) ApiMediaUpdateThumbnailJpegRequest {
	r.entryId = &entryId
	return r
}

// Jpeg file data
func (r ApiMediaUpdateThumbnailJpegRequest) FileData(fileData *os.File) ApiMediaUpdateThumbnailJpegRequest {
	r.fileData = &fileData
	return r
}

func (r ApiMediaUpdateThumbnailJpegRequest) Ks(ks string) ApiMediaUpdateThumbnailJpegRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaUpdateThumbnailJpegRequest) Format(format int32) ApiMediaUpdateThumbnailJpegRequest {
	r.format = &format
	return r
}

func (r ApiMediaUpdateThumbnailJpegRequest) Execute() (*KalturaMediaEntry, *http.Response, error) {
	return r.ApiService.MediaUpdateThumbnailJpegExecute(r)
}

/*
MediaUpdateThumbnailJpeg Method for MediaUpdateThumbnailJpeg

Update media entry thumbnail using a raw jpeg file

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaUpdateThumbnailJpegRequest

Deprecated
*/
func (a *MediaApiService) MediaUpdateThumbnailJpeg(ctx context.Context) ApiMediaUpdateThumbnailJpegRequest {
	return ApiMediaUpdateThumbnailJpegRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaMediaEntry
// Deprecated
func (a *MediaApiService) MediaUpdateThumbnailJpegExecute(r ApiMediaUpdateThumbnailJpegRequest) (*KalturaMediaEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaMediaEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaUpdateThumbnailJpeg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/updateThumbnailJpeg"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.entryId == nil {
		return localVarReturnValue, nil, reportError("entryId is required and must be specified")
	}
	if r.fileData == nil {
		return localVarReturnValue, nil, reportError("fileData is required and must be specified")
	}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	localVarQueryParams.Add("entryId", parameterToString(*r.entryId, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileDataLocalVarFormFileName string
	var fileDataLocalVarFileName     string
	var fileDataLocalVarFileBytes    []byte

	fileDataLocalVarFormFileName = "fileData"

	fileDataLocalVarFile := *r.fileData
	if fileDataLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(fileDataLocalVarFile)
		fileDataLocalVarFileBytes = fbs
		fileDataLocalVarFileName = fileDataLocalVarFile.Name()
		fileDataLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: fileDataLocalVarFileBytes, fileName: fileDataLocalVarFileName, formFileName: fileDataLocalVarFormFileName})
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMediaUploadRequest struct {
	ctx context.Context
	ApiService *MediaApiService
	fileData **os.File
	ks *string
	format *int32
}

// The file data
func (r ApiMediaUploadRequest) FileData(fileData *os.File) ApiMediaUploadRequest {
	r.fileData = &fileData
	return r
}

func (r ApiMediaUploadRequest) Ks(ks string) ApiMediaUploadRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiMediaUploadRequest) Format(format int32) ApiMediaUploadRequest {
	r.format = &format
	return r
}

func (r ApiMediaUploadRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.MediaUploadExecute(r)
}

/*
MediaUpload Method for MediaUpload

Upload a media file to Kaltura, then the file can be used to create a media entry.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMediaUploadRequest

Deprecated
*/
func (a *MediaApiService) MediaUpload(ctx context.Context) ApiMediaUploadRequest {
	return ApiMediaUploadRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
// Deprecated
func (a *MediaApiService) MediaUploadExecute(r ApiMediaUploadRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MediaApiService.MediaUpload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/media/action/upload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileData == nil {
		return localVarReturnValue, nil, reportError("fileData is required and must be specified")
	}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileDataLocalVarFormFileName string
	var fileDataLocalVarFileName     string
	var fileDataLocalVarFileBytes    []byte

	fileDataLocalVarFormFileName = "fileData"

	fileDataLocalVarFile := *r.fileData
	if fileDataLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(fileDataLocalVarFile)
		fileDataLocalVarFileBytes = fbs
		fileDataLocalVarFileName = fileDataLocalVarFile.Name()
		fileDataLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: fileDataLocalVarFileBytes, fileName: fileDataLocalVarFileName, formFileName: fileDataLocalVarFormFileName})
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
