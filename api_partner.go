/*
Kaltura VPaaS

The Kaltura VPaaS API

API version: 18.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// PartnerApiService PartnerApi service
type PartnerApiService service

type ApiPartnerCountRequest struct {
	ctx context.Context
	ApiService *PartnerApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *PartnerCountRequest
}

func (r ApiPartnerCountRequest) Ks(ks string) ApiPartnerCountRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiPartnerCountRequest) Format(format int32) ApiPartnerCountRequest {
	r.format = &format
	return r
}

func (r ApiPartnerCountRequest) ClientTag(clientTag string) ApiPartnerCountRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiPartnerCountRequest) PartnerId(partnerId int32) ApiPartnerCountRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiPartnerCountRequest) Body(body PartnerCountRequest) ApiPartnerCountRequest {
	r.body = &body
	return r
}

func (r ApiPartnerCountRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.PartnerCountExecute(r)
}

/*
PartnerCount Method for PartnerCount

Count partner's existing sub-publishers (count includes the partner itself).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPartnerCountRequest
*/
func (a *PartnerApiService) PartnerCount(ctx context.Context) ApiPartnerCountRequest {
	return ApiPartnerCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return int32
func (a *PartnerApiService) PartnerCountExecute(r ApiPartnerCountRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartnerApiService.PartnerCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/partner/action/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPartnerGetRequest struct {
	ctx context.Context
	ApiService *PartnerApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *PartnerGetRequest
}

func (r ApiPartnerGetRequest) Ks(ks string) ApiPartnerGetRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiPartnerGetRequest) Format(format int32) ApiPartnerGetRequest {
	r.format = &format
	return r
}

func (r ApiPartnerGetRequest) ClientTag(clientTag string) ApiPartnerGetRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiPartnerGetRequest) PartnerId(partnerId int32) ApiPartnerGetRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiPartnerGetRequest) Body(body PartnerGetRequest) ApiPartnerGetRequest {
	r.body = &body
	return r
}

func (r ApiPartnerGetRequest) Execute() (*KalturaPartner, *http.Response, error) {
	return r.ApiService.PartnerGetExecute(r)
}

/*
PartnerGet Method for PartnerGet

Retrieve partner object by Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPartnerGetRequest
*/
func (a *PartnerApiService) PartnerGet(ctx context.Context) ApiPartnerGetRequest {
	return ApiPartnerGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaPartner
func (a *PartnerApiService) PartnerGetExecute(r ApiPartnerGetRequest) (*KalturaPartner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaPartner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartnerApiService.PartnerGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/partner/action/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPartnerGetInfoRequest struct {
	ctx context.Context
	ApiService *PartnerApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	batchCleanExclusiveJobsRequest *BatchCleanExclusiveJobsRequest
}

func (r ApiPartnerGetInfoRequest) Ks(ks string) ApiPartnerGetInfoRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiPartnerGetInfoRequest) Format(format int32) ApiPartnerGetInfoRequest {
	r.format = &format
	return r
}

func (r ApiPartnerGetInfoRequest) ClientTag(clientTag string) ApiPartnerGetInfoRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiPartnerGetInfoRequest) PartnerId(partnerId int32) ApiPartnerGetInfoRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiPartnerGetInfoRequest) BatchCleanExclusiveJobsRequest(batchCleanExclusiveJobsRequest BatchCleanExclusiveJobsRequest) ApiPartnerGetInfoRequest {
	r.batchCleanExclusiveJobsRequest = &batchCleanExclusiveJobsRequest
	return r
}

func (r ApiPartnerGetInfoRequest) Execute() (*KalturaPartner, *http.Response, error) {
	return r.ApiService.PartnerGetInfoExecute(r)
}

/*
PartnerGetInfo Method for PartnerGetInfo

Retrieve all info attributed to the partner

This action expects no parameters. It returns information for the current KS partnerId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPartnerGetInfoRequest

Deprecated
*/
func (a *PartnerApiService) PartnerGetInfo(ctx context.Context) ApiPartnerGetInfoRequest {
	return ApiPartnerGetInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaPartner
// Deprecated
func (a *PartnerApiService) PartnerGetInfoExecute(r ApiPartnerGetInfoRequest) (*KalturaPartner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaPartner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartnerApiService.PartnerGetInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/partner/action/getInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchCleanExclusiveJobsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPartnerGetPublicInfoRequest struct {
	ctx context.Context
	ApiService *PartnerApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *PartnerGetRequest
}

func (r ApiPartnerGetPublicInfoRequest) Ks(ks string) ApiPartnerGetPublicInfoRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiPartnerGetPublicInfoRequest) Format(format int32) ApiPartnerGetPublicInfoRequest {
	r.format = &format
	return r
}

func (r ApiPartnerGetPublicInfoRequest) ClientTag(clientTag string) ApiPartnerGetPublicInfoRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiPartnerGetPublicInfoRequest) PartnerId(partnerId int32) ApiPartnerGetPublicInfoRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiPartnerGetPublicInfoRequest) Body(body PartnerGetRequest) ApiPartnerGetPublicInfoRequest {
	r.body = &body
	return r
}

func (r ApiPartnerGetPublicInfoRequest) Execute() (*KalturaPartnerPublicInfo, *http.Response, error) {
	return r.ApiService.PartnerGetPublicInfoExecute(r)
}

/*
PartnerGetPublicInfo Method for PartnerGetPublicInfo

Returns partner public info by Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPartnerGetPublicInfoRequest
*/
func (a *PartnerApiService) PartnerGetPublicInfo(ctx context.Context) ApiPartnerGetPublicInfoRequest {
	return ApiPartnerGetPublicInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaPartnerPublicInfo
func (a *PartnerApiService) PartnerGetPublicInfoExecute(r ApiPartnerGetPublicInfoRequest) (*KalturaPartnerPublicInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaPartnerPublicInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartnerApiService.PartnerGetPublicInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/partner/action/getPublicInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPartnerGetSecretsRequest struct {
	ctx context.Context
	ApiService *PartnerApiService
	format *int32
	clientTag *string
	partnerId *int32
	body *PartnerGetSecretsRequest
}

// The format of the response
func (r ApiPartnerGetSecretsRequest) Format(format int32) ApiPartnerGetSecretsRequest {
	r.format = &format
	return r
}

func (r ApiPartnerGetSecretsRequest) ClientTag(clientTag string) ApiPartnerGetSecretsRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiPartnerGetSecretsRequest) PartnerId(partnerId int32) ApiPartnerGetSecretsRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiPartnerGetSecretsRequest) Body(body PartnerGetSecretsRequest) ApiPartnerGetSecretsRequest {
	r.body = &body
	return r
}

func (r ApiPartnerGetSecretsRequest) Execute() (*KalturaPartner, *http.Response, error) {
	return r.ApiService.PartnerGetSecretsExecute(r)
}

/*
PartnerGetSecrets Method for PartnerGetSecrets

Retrieve partner secret and admin secret

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPartnerGetSecretsRequest
*/
func (a *PartnerApiService) PartnerGetSecrets(ctx context.Context) ApiPartnerGetSecretsRequest {
	return ApiPartnerGetSecretsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaPartner
func (a *PartnerApiService) PartnerGetSecretsExecute(r ApiPartnerGetSecretsRequest) (*KalturaPartner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaPartner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartnerApiService.PartnerGetSecrets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/partner/action/getSecrets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPartnerGetStatisticsRequest struct {
	ctx context.Context
	ApiService *PartnerApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	batchCleanExclusiveJobsRequest *BatchCleanExclusiveJobsRequest
}

func (r ApiPartnerGetStatisticsRequest) Ks(ks string) ApiPartnerGetStatisticsRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiPartnerGetStatisticsRequest) Format(format int32) ApiPartnerGetStatisticsRequest {
	r.format = &format
	return r
}

func (r ApiPartnerGetStatisticsRequest) ClientTag(clientTag string) ApiPartnerGetStatisticsRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiPartnerGetStatisticsRequest) PartnerId(partnerId int32) ApiPartnerGetStatisticsRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiPartnerGetStatisticsRequest) BatchCleanExclusiveJobsRequest(batchCleanExclusiveJobsRequest BatchCleanExclusiveJobsRequest) ApiPartnerGetStatisticsRequest {
	r.batchCleanExclusiveJobsRequest = &batchCleanExclusiveJobsRequest
	return r
}

func (r ApiPartnerGetStatisticsRequest) Execute() (*KalturaPartnerStatistics, *http.Response, error) {
	return r.ApiService.PartnerGetStatisticsExecute(r)
}

/*
PartnerGetStatistics Method for PartnerGetStatistics

Get usage statistics for a partner

Calculation is done according to partner's package

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPartnerGetStatisticsRequest
*/
func (a *PartnerApiService) PartnerGetStatistics(ctx context.Context) ApiPartnerGetStatisticsRequest {
	return ApiPartnerGetStatisticsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaPartnerStatistics
func (a *PartnerApiService) PartnerGetStatisticsExecute(r ApiPartnerGetStatisticsRequest) (*KalturaPartnerStatistics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaPartnerStatistics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartnerApiService.PartnerGetStatistics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/partner/action/getStatistics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchCleanExclusiveJobsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPartnerGetUsageRequest struct {
	ctx context.Context
	ApiService *PartnerApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *PartnerGetUsageRequest
}

func (r ApiPartnerGetUsageRequest) Ks(ks string) ApiPartnerGetUsageRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiPartnerGetUsageRequest) Format(format int32) ApiPartnerGetUsageRequest {
	r.format = &format
	return r
}

func (r ApiPartnerGetUsageRequest) ClientTag(clientTag string) ApiPartnerGetUsageRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiPartnerGetUsageRequest) PartnerId(partnerId int32) ApiPartnerGetUsageRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiPartnerGetUsageRequest) Body(body PartnerGetUsageRequest) ApiPartnerGetUsageRequest {
	r.body = &body
	return r
}

func (r ApiPartnerGetUsageRequest) Execute() (*KalturaPartnerUsage, *http.Response, error) {
	return r.ApiService.PartnerGetUsageExecute(r)
}

/*
PartnerGetUsage Method for PartnerGetUsage

Get usage statistics for a partner

Calculation is done according to partner's package

Additional data returned is a graph points of streaming usage in a time frame

The resolution can be "days" or "months"

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPartnerGetUsageRequest

Deprecated
*/
func (a *PartnerApiService) PartnerGetUsage(ctx context.Context) ApiPartnerGetUsageRequest {
	return ApiPartnerGetUsageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaPartnerUsage
// Deprecated
func (a *PartnerApiService) PartnerGetUsageExecute(r ApiPartnerGetUsageRequest) (*KalturaPartnerUsage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaPartnerUsage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartnerApiService.PartnerGetUsage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/partner/action/getUsage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPartnerListRequest struct {
	ctx context.Context
	ApiService *PartnerApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *DistributionProfileListByPartnerRequest
}

func (r ApiPartnerListRequest) Ks(ks string) ApiPartnerListRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiPartnerListRequest) Format(format int32) ApiPartnerListRequest {
	r.format = &format
	return r
}

func (r ApiPartnerListRequest) ClientTag(clientTag string) ApiPartnerListRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiPartnerListRequest) PartnerId(partnerId int32) ApiPartnerListRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiPartnerListRequest) Body(body DistributionProfileListByPartnerRequest) ApiPartnerListRequest {
	r.body = &body
	return r
}

func (r ApiPartnerListRequest) Execute() (*KalturaPartnerListResponse, *http.Response, error) {
	return r.ApiService.PartnerListExecute(r)
}

/*
PartnerList Method for PartnerList

List partners by filter with paging support

Current implementation will only list the sub partners of the partner initiating the API call (using the current KS).

This action is only partially implemented to support listing sub partners of a VAR partner.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPartnerListRequest
*/
func (a *PartnerApiService) PartnerList(ctx context.Context) ApiPartnerListRequest {
	return ApiPartnerListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaPartnerListResponse
func (a *PartnerApiService) PartnerListExecute(r ApiPartnerListRequest) (*KalturaPartnerListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaPartnerListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartnerApiService.PartnerList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/partner/action/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPartnerListFeatureStatusRequest struct {
	ctx context.Context
	ApiService *PartnerApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	batchCleanExclusiveJobsRequest *BatchCleanExclusiveJobsRequest
}

func (r ApiPartnerListFeatureStatusRequest) Ks(ks string) ApiPartnerListFeatureStatusRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiPartnerListFeatureStatusRequest) Format(format int32) ApiPartnerListFeatureStatusRequest {
	r.format = &format
	return r
}

func (r ApiPartnerListFeatureStatusRequest) ClientTag(clientTag string) ApiPartnerListFeatureStatusRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiPartnerListFeatureStatusRequest) PartnerId(partnerId int32) ApiPartnerListFeatureStatusRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiPartnerListFeatureStatusRequest) BatchCleanExclusiveJobsRequest(batchCleanExclusiveJobsRequest BatchCleanExclusiveJobsRequest) ApiPartnerListFeatureStatusRequest {
	r.batchCleanExclusiveJobsRequest = &batchCleanExclusiveJobsRequest
	return r
}

func (r ApiPartnerListFeatureStatusRequest) Execute() (*KalturaFeatureStatusListResponse, *http.Response, error) {
	return r.ApiService.PartnerListFeatureStatusExecute(r)
}

/*
PartnerListFeatureStatus Method for PartnerListFeatureStatus

List partner's current processes' statuses

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPartnerListFeatureStatusRequest
*/
func (a *PartnerApiService) PartnerListFeatureStatus(ctx context.Context) ApiPartnerListFeatureStatusRequest {
	return ApiPartnerListFeatureStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaFeatureStatusListResponse
func (a *PartnerApiService) PartnerListFeatureStatusExecute(r ApiPartnerListFeatureStatusRequest) (*KalturaFeatureStatusListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaFeatureStatusListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartnerApiService.PartnerListFeatureStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/partner/action/listFeatureStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchCleanExclusiveJobsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPartnerListPartnersForUserRequest struct {
	ctx context.Context
	ApiService *PartnerApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *PartnerListPartnersForUserRequest
}

func (r ApiPartnerListPartnersForUserRequest) Ks(ks string) ApiPartnerListPartnersForUserRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiPartnerListPartnersForUserRequest) Format(format int32) ApiPartnerListPartnersForUserRequest {
	r.format = &format
	return r
}

func (r ApiPartnerListPartnersForUserRequest) ClientTag(clientTag string) ApiPartnerListPartnersForUserRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiPartnerListPartnersForUserRequest) PartnerId(partnerId int32) ApiPartnerListPartnersForUserRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiPartnerListPartnersForUserRequest) Body(body PartnerListPartnersForUserRequest) ApiPartnerListPartnersForUserRequest {
	r.body = &body
	return r
}

func (r ApiPartnerListPartnersForUserRequest) Execute() (*KalturaPartnerListResponse, *http.Response, error) {
	return r.ApiService.PartnerListPartnersForUserExecute(r)
}

/*
PartnerListPartnersForUser Method for PartnerListPartnersForUser

Retrieve a list of partner objects which the current user is allowed to access.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPartnerListPartnersForUserRequest
*/
func (a *PartnerApiService) PartnerListPartnersForUser(ctx context.Context) ApiPartnerListPartnersForUserRequest {
	return ApiPartnerListPartnersForUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaPartnerListResponse
func (a *PartnerApiService) PartnerListPartnersForUserExecute(r ApiPartnerListPartnersForUserRequest) (*KalturaPartnerListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaPartnerListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartnerApiService.PartnerListPartnersForUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/partner/action/listPartnersForUser"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPartnerRegisterRequest struct {
	ctx context.Context
	ApiService *PartnerApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *PartnerRegisterRequest
}

func (r ApiPartnerRegisterRequest) Ks(ks string) ApiPartnerRegisterRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiPartnerRegisterRequest) Format(format int32) ApiPartnerRegisterRequest {
	r.format = &format
	return r
}

func (r ApiPartnerRegisterRequest) ClientTag(clientTag string) ApiPartnerRegisterRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiPartnerRegisterRequest) PartnerId(partnerId int32) ApiPartnerRegisterRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiPartnerRegisterRequest) Body(body PartnerRegisterRequest) ApiPartnerRegisterRequest {
	r.body = &body
	return r
}

func (r ApiPartnerRegisterRequest) Execute() (*KalturaPartner, *http.Response, error) {
	return r.ApiService.PartnerRegisterExecute(r)
}

/*
PartnerRegister Method for PartnerRegister

Create a new Partner object

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPartnerRegisterRequest
*/
func (a *PartnerApiService) PartnerRegister(ctx context.Context) ApiPartnerRegisterRequest {
	return ApiPartnerRegisterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaPartner
func (a *PartnerApiService) PartnerRegisterExecute(r ApiPartnerRegisterRequest) (*KalturaPartner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaPartner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartnerApiService.PartnerRegister")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/partner/action/register"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPartnerRegistrationValidationRequest struct {
	ctx context.Context
	ApiService *PartnerApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *PartnerRegisterRequest
}

func (r ApiPartnerRegistrationValidationRequest) Ks(ks string) ApiPartnerRegistrationValidationRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiPartnerRegistrationValidationRequest) Format(format int32) ApiPartnerRegistrationValidationRequest {
	r.format = &format
	return r
}

func (r ApiPartnerRegistrationValidationRequest) ClientTag(clientTag string) ApiPartnerRegistrationValidationRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiPartnerRegistrationValidationRequest) PartnerId(partnerId int32) ApiPartnerRegistrationValidationRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiPartnerRegistrationValidationRequest) Body(body PartnerRegisterRequest) ApiPartnerRegistrationValidationRequest {
	r.body = &body
	return r
}

func (r ApiPartnerRegistrationValidationRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.PartnerRegistrationValidationExecute(r)
}

/*
PartnerRegistrationValidation Method for PartnerRegistrationValidation

Create a new Partner object

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPartnerRegistrationValidationRequest
*/
func (a *PartnerApiService) PartnerRegistrationValidation(ctx context.Context) ApiPartnerRegistrationValidationRequest {
	return ApiPartnerRegistrationValidationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return bool
func (a *PartnerApiService) PartnerRegistrationValidationExecute(r ApiPartnerRegistrationValidationRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartnerApiService.PartnerRegistrationValidation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/partner/action/registrationValidation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPartnerUpdateRequest struct {
	ctx context.Context
	ApiService *PartnerApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *PartnerUpdateRequest
}

func (r ApiPartnerUpdateRequest) Ks(ks string) ApiPartnerUpdateRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiPartnerUpdateRequest) Format(format int32) ApiPartnerUpdateRequest {
	r.format = &format
	return r
}

func (r ApiPartnerUpdateRequest) ClientTag(clientTag string) ApiPartnerUpdateRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiPartnerUpdateRequest) PartnerId(partnerId int32) ApiPartnerUpdateRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiPartnerUpdateRequest) Body(body PartnerUpdateRequest) ApiPartnerUpdateRequest {
	r.body = &body
	return r
}

func (r ApiPartnerUpdateRequest) Execute() (*KalturaPartner, *http.Response, error) {
	return r.ApiService.PartnerUpdateExecute(r)
}

/*
PartnerUpdate Method for PartnerUpdate

Update details and settings of an existing partner

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPartnerUpdateRequest
*/
func (a *PartnerApiService) PartnerUpdate(ctx context.Context) ApiPartnerUpdateRequest {
	return ApiPartnerUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaPartner
func (a *PartnerApiService) PartnerUpdateExecute(r ApiPartnerUpdateRequest) (*KalturaPartner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaPartner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PartnerApiService.PartnerUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/partner/action/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
