/*
Kaltura VPaaS

The Kaltura VPaaS API

API version: 18.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)


// EventNotificationTemplateApiService EventNotificationTemplateApi service
type EventNotificationTemplateApiService service

type ApiEventNotificationTemplateAddRequest struct {
	ctx context.Context
	ApiService *EventNotificationTemplateApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *EventNotificationTemplateAddRequest
}

func (r ApiEventNotificationTemplateAddRequest) Ks(ks string) ApiEventNotificationTemplateAddRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEventNotificationTemplateAddRequest) Format(format int32) ApiEventNotificationTemplateAddRequest {
	r.format = &format
	return r
}

func (r ApiEventNotificationTemplateAddRequest) ClientTag(clientTag string) ApiEventNotificationTemplateAddRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEventNotificationTemplateAddRequest) PartnerId(partnerId int32) ApiEventNotificationTemplateAddRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEventNotificationTemplateAddRequest) Body(body EventNotificationTemplateAddRequest) ApiEventNotificationTemplateAddRequest {
	r.body = &body
	return r
}

func (r ApiEventNotificationTemplateAddRequest) Execute() (*KalturaEventNotificationTemplate, *http.Response, error) {
	return r.ApiService.EventNotificationTemplateAddExecute(r)
}

/*
EventNotificationTemplateAdd Method for EventNotificationTemplateAdd

This action allows for the creation of new backend event types in the system. This action requires access to the Kaltura server Admin Console. If you're looking to register to existing event types, please use the clone action instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEventNotificationTemplateAddRequest
*/
func (a *EventNotificationTemplateApiService) EventNotificationTemplateAdd(ctx context.Context) ApiEventNotificationTemplateAddRequest {
	return ApiEventNotificationTemplateAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEventNotificationTemplate
func (a *EventNotificationTemplateApiService) EventNotificationTemplateAddExecute(r ApiEventNotificationTemplateAddRequest) (*KalturaEventNotificationTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEventNotificationTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventNotificationTemplateApiService.EventNotificationTemplateAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/eventnotification_eventnotificationtemplate/action/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventNotificationTemplateCloneRequest struct {
	ctx context.Context
	ApiService *EventNotificationTemplateApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *EventNotificationTemplateCloneRequest
}

func (r ApiEventNotificationTemplateCloneRequest) Ks(ks string) ApiEventNotificationTemplateCloneRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEventNotificationTemplateCloneRequest) Format(format int32) ApiEventNotificationTemplateCloneRequest {
	r.format = &format
	return r
}

func (r ApiEventNotificationTemplateCloneRequest) ClientTag(clientTag string) ApiEventNotificationTemplateCloneRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEventNotificationTemplateCloneRequest) PartnerId(partnerId int32) ApiEventNotificationTemplateCloneRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEventNotificationTemplateCloneRequest) Body(body EventNotificationTemplateCloneRequest) ApiEventNotificationTemplateCloneRequest {
	r.body = &body
	return r
}

func (r ApiEventNotificationTemplateCloneRequest) Execute() (*KalturaEventNotificationTemplate, *http.Response, error) {
	return r.ApiService.EventNotificationTemplateCloneExecute(r)
}

/*
EventNotificationTemplateClone Method for EventNotificationTemplateClone

This action allows registering to various backend event. Use this action to create notifications that will react to events such as new video was uploaded or metadata field was updated. To see the list of available event types, call the listTemplates action.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEventNotificationTemplateCloneRequest
*/
func (a *EventNotificationTemplateApiService) EventNotificationTemplateClone(ctx context.Context) ApiEventNotificationTemplateCloneRequest {
	return ApiEventNotificationTemplateCloneRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEventNotificationTemplate
func (a *EventNotificationTemplateApiService) EventNotificationTemplateCloneExecute(r ApiEventNotificationTemplateCloneRequest) (*KalturaEventNotificationTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEventNotificationTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventNotificationTemplateApiService.EventNotificationTemplateClone")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/eventnotification_eventnotificationtemplate/action/clone"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventNotificationTemplateDeleteRequest struct {
	ctx context.Context
	ApiService *EventNotificationTemplateApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AccessControlDeleteRequest
}

func (r ApiEventNotificationTemplateDeleteRequest) Ks(ks string) ApiEventNotificationTemplateDeleteRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEventNotificationTemplateDeleteRequest) Format(format int32) ApiEventNotificationTemplateDeleteRequest {
	r.format = &format
	return r
}

func (r ApiEventNotificationTemplateDeleteRequest) ClientTag(clientTag string) ApiEventNotificationTemplateDeleteRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEventNotificationTemplateDeleteRequest) PartnerId(partnerId int32) ApiEventNotificationTemplateDeleteRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEventNotificationTemplateDeleteRequest) Body(body AccessControlDeleteRequest) ApiEventNotificationTemplateDeleteRequest {
	r.body = &body
	return r
}

func (r ApiEventNotificationTemplateDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.EventNotificationTemplateDeleteExecute(r)
}

/*
EventNotificationTemplateDelete Method for EventNotificationTemplateDelete

Delete an event notification template object

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEventNotificationTemplateDeleteRequest
*/
func (a *EventNotificationTemplateApiService) EventNotificationTemplateDelete(ctx context.Context) ApiEventNotificationTemplateDeleteRequest {
	return ApiEventNotificationTemplateDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EventNotificationTemplateApiService) EventNotificationTemplateDeleteExecute(r ApiEventNotificationTemplateDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventNotificationTemplateApiService.EventNotificationTemplateDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/eventnotification_eventnotificationtemplate/action/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEventNotificationTemplateDispatchRequest struct {
	ctx context.Context
	ApiService *EventNotificationTemplateApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *EventNotificationTemplateDispatchRequest
}

func (r ApiEventNotificationTemplateDispatchRequest) Ks(ks string) ApiEventNotificationTemplateDispatchRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEventNotificationTemplateDispatchRequest) Format(format int32) ApiEventNotificationTemplateDispatchRequest {
	r.format = &format
	return r
}

func (r ApiEventNotificationTemplateDispatchRequest) ClientTag(clientTag string) ApiEventNotificationTemplateDispatchRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEventNotificationTemplateDispatchRequest) PartnerId(partnerId int32) ApiEventNotificationTemplateDispatchRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEventNotificationTemplateDispatchRequest) Body(body EventNotificationTemplateDispatchRequest) ApiEventNotificationTemplateDispatchRequest {
	r.body = &body
	return r
}

func (r ApiEventNotificationTemplateDispatchRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.EventNotificationTemplateDispatchExecute(r)
}

/*
EventNotificationTemplateDispatch Method for EventNotificationTemplateDispatch

Dispatch event notification object by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEventNotificationTemplateDispatchRequest
*/
func (a *EventNotificationTemplateApiService) EventNotificationTemplateDispatch(ctx context.Context) ApiEventNotificationTemplateDispatchRequest {
	return ApiEventNotificationTemplateDispatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return int32
func (a *EventNotificationTemplateApiService) EventNotificationTemplateDispatchExecute(r ApiEventNotificationTemplateDispatchRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventNotificationTemplateApiService.EventNotificationTemplateDispatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/eventnotification_eventnotificationtemplate/action/dispatch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventNotificationTemplateGetRequest struct {
	ctx context.Context
	ApiService *EventNotificationTemplateApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AccessControlDeleteRequest
}

func (r ApiEventNotificationTemplateGetRequest) Ks(ks string) ApiEventNotificationTemplateGetRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEventNotificationTemplateGetRequest) Format(format int32) ApiEventNotificationTemplateGetRequest {
	r.format = &format
	return r
}

func (r ApiEventNotificationTemplateGetRequest) ClientTag(clientTag string) ApiEventNotificationTemplateGetRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEventNotificationTemplateGetRequest) PartnerId(partnerId int32) ApiEventNotificationTemplateGetRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEventNotificationTemplateGetRequest) Body(body AccessControlDeleteRequest) ApiEventNotificationTemplateGetRequest {
	r.body = &body
	return r
}

func (r ApiEventNotificationTemplateGetRequest) Execute() (*KalturaEventNotificationTemplate, *http.Response, error) {
	return r.ApiService.EventNotificationTemplateGetExecute(r)
}

/*
EventNotificationTemplateGet Method for EventNotificationTemplateGet

Retrieve an event notification template object by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEventNotificationTemplateGetRequest
*/
func (a *EventNotificationTemplateApiService) EventNotificationTemplateGet(ctx context.Context) ApiEventNotificationTemplateGetRequest {
	return ApiEventNotificationTemplateGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEventNotificationTemplate
func (a *EventNotificationTemplateApiService) EventNotificationTemplateGetExecute(r ApiEventNotificationTemplateGetRequest) (*KalturaEventNotificationTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEventNotificationTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventNotificationTemplateApiService.EventNotificationTemplateGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/eventnotification_eventnotificationtemplate/action/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventNotificationTemplateListRequest struct {
	ctx context.Context
	ApiService *EventNotificationTemplateApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *EventNotificationTemplateListRequest
}

func (r ApiEventNotificationTemplateListRequest) Ks(ks string) ApiEventNotificationTemplateListRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEventNotificationTemplateListRequest) Format(format int32) ApiEventNotificationTemplateListRequest {
	r.format = &format
	return r
}

func (r ApiEventNotificationTemplateListRequest) ClientTag(clientTag string) ApiEventNotificationTemplateListRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEventNotificationTemplateListRequest) PartnerId(partnerId int32) ApiEventNotificationTemplateListRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEventNotificationTemplateListRequest) Body(body EventNotificationTemplateListRequest) ApiEventNotificationTemplateListRequest {
	r.body = &body
	return r
}

func (r ApiEventNotificationTemplateListRequest) Execute() (*KalturaEventNotificationTemplateListResponse, *http.Response, error) {
	return r.ApiService.EventNotificationTemplateListExecute(r)
}

/*
EventNotificationTemplateList Method for EventNotificationTemplateList

list event notification template objects

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEventNotificationTemplateListRequest
*/
func (a *EventNotificationTemplateApiService) EventNotificationTemplateList(ctx context.Context) ApiEventNotificationTemplateListRequest {
	return ApiEventNotificationTemplateListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEventNotificationTemplateListResponse
func (a *EventNotificationTemplateApiService) EventNotificationTemplateListExecute(r ApiEventNotificationTemplateListRequest) (*KalturaEventNotificationTemplateListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEventNotificationTemplateListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventNotificationTemplateApiService.EventNotificationTemplateList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/eventnotification_eventnotificationtemplate/action/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventNotificationTemplateListByPartnerRequest struct {
	ctx context.Context
	ApiService *EventNotificationTemplateApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *DistributionProfileListByPartnerRequest
}

func (r ApiEventNotificationTemplateListByPartnerRequest) Ks(ks string) ApiEventNotificationTemplateListByPartnerRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEventNotificationTemplateListByPartnerRequest) Format(format int32) ApiEventNotificationTemplateListByPartnerRequest {
	r.format = &format
	return r
}

func (r ApiEventNotificationTemplateListByPartnerRequest) ClientTag(clientTag string) ApiEventNotificationTemplateListByPartnerRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEventNotificationTemplateListByPartnerRequest) PartnerId(partnerId int32) ApiEventNotificationTemplateListByPartnerRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEventNotificationTemplateListByPartnerRequest) Body(body DistributionProfileListByPartnerRequest) ApiEventNotificationTemplateListByPartnerRequest {
	r.body = &body
	return r
}

func (r ApiEventNotificationTemplateListByPartnerRequest) Execute() (*KalturaEventNotificationTemplateListResponse, *http.Response, error) {
	return r.ApiService.EventNotificationTemplateListByPartnerExecute(r)
}

/*
EventNotificationTemplateListByPartner Method for EventNotificationTemplateListByPartner

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEventNotificationTemplateListByPartnerRequest
*/
func (a *EventNotificationTemplateApiService) EventNotificationTemplateListByPartner(ctx context.Context) ApiEventNotificationTemplateListByPartnerRequest {
	return ApiEventNotificationTemplateListByPartnerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEventNotificationTemplateListResponse
func (a *EventNotificationTemplateApiService) EventNotificationTemplateListByPartnerExecute(r ApiEventNotificationTemplateListByPartnerRequest) (*KalturaEventNotificationTemplateListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEventNotificationTemplateListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventNotificationTemplateApiService.EventNotificationTemplateListByPartner")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/eventnotification_eventnotificationtemplate/action/listByPartner"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventNotificationTemplateListTemplatesRequest struct {
	ctx context.Context
	ApiService *EventNotificationTemplateApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *EventNotificationTemplateListRequest
}

func (r ApiEventNotificationTemplateListTemplatesRequest) Ks(ks string) ApiEventNotificationTemplateListTemplatesRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEventNotificationTemplateListTemplatesRequest) Format(format int32) ApiEventNotificationTemplateListTemplatesRequest {
	r.format = &format
	return r
}

func (r ApiEventNotificationTemplateListTemplatesRequest) ClientTag(clientTag string) ApiEventNotificationTemplateListTemplatesRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEventNotificationTemplateListTemplatesRequest) PartnerId(partnerId int32) ApiEventNotificationTemplateListTemplatesRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEventNotificationTemplateListTemplatesRequest) Body(body EventNotificationTemplateListRequest) ApiEventNotificationTemplateListTemplatesRequest {
	r.body = &body
	return r
}

func (r ApiEventNotificationTemplateListTemplatesRequest) Execute() (*KalturaEventNotificationTemplateListResponse, *http.Response, error) {
	return r.ApiService.EventNotificationTemplateListTemplatesExecute(r)
}

/*
EventNotificationTemplateListTemplates Method for EventNotificationTemplateListTemplates

Action lists the template partner event notification templates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEventNotificationTemplateListTemplatesRequest
*/
func (a *EventNotificationTemplateApiService) EventNotificationTemplateListTemplates(ctx context.Context) ApiEventNotificationTemplateListTemplatesRequest {
	return ApiEventNotificationTemplateListTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEventNotificationTemplateListResponse
func (a *EventNotificationTemplateApiService) EventNotificationTemplateListTemplatesExecute(r ApiEventNotificationTemplateListTemplatesRequest) (*KalturaEventNotificationTemplateListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEventNotificationTemplateListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventNotificationTemplateApiService.EventNotificationTemplateListTemplates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/eventnotification_eventnotificationtemplate/action/listTemplates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventNotificationTemplateRegisterRequest struct {
	ctx context.Context
	ApiService *EventNotificationTemplateApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *EventNotificationTemplateRegisterRequest
}

func (r ApiEventNotificationTemplateRegisterRequest) Ks(ks string) ApiEventNotificationTemplateRegisterRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEventNotificationTemplateRegisterRequest) Format(format int32) ApiEventNotificationTemplateRegisterRequest {
	r.format = &format
	return r
}

func (r ApiEventNotificationTemplateRegisterRequest) ClientTag(clientTag string) ApiEventNotificationTemplateRegisterRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEventNotificationTemplateRegisterRequest) PartnerId(partnerId int32) ApiEventNotificationTemplateRegisterRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEventNotificationTemplateRegisterRequest) Body(body EventNotificationTemplateRegisterRequest) ApiEventNotificationTemplateRegisterRequest {
	r.body = &body
	return r
}

func (r ApiEventNotificationTemplateRegisterRequest) Execute() (*KalturaPushNotificationData, *http.Response, error) {
	return r.ApiService.EventNotificationTemplateRegisterExecute(r)
}

/*
EventNotificationTemplateRegister Method for EventNotificationTemplateRegister

Register to a queue from which event messages will be provided according to given template. Queue will be created if not already exists

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEventNotificationTemplateRegisterRequest
*/
func (a *EventNotificationTemplateApiService) EventNotificationTemplateRegister(ctx context.Context) ApiEventNotificationTemplateRegisterRequest {
	return ApiEventNotificationTemplateRegisterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaPushNotificationData
func (a *EventNotificationTemplateApiService) EventNotificationTemplateRegisterExecute(r ApiEventNotificationTemplateRegisterRequest) (*KalturaPushNotificationData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaPushNotificationData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventNotificationTemplateApiService.EventNotificationTemplateRegister")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/eventnotification_eventnotificationtemplate/action/register"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventNotificationTemplateSendCommandRequest struct {
	ctx context.Context
	ApiService *EventNotificationTemplateApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *EventNotificationTemplateSendCommandRequest
}

func (r ApiEventNotificationTemplateSendCommandRequest) Ks(ks string) ApiEventNotificationTemplateSendCommandRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEventNotificationTemplateSendCommandRequest) Format(format int32) ApiEventNotificationTemplateSendCommandRequest {
	r.format = &format
	return r
}

func (r ApiEventNotificationTemplateSendCommandRequest) ClientTag(clientTag string) ApiEventNotificationTemplateSendCommandRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEventNotificationTemplateSendCommandRequest) PartnerId(partnerId int32) ApiEventNotificationTemplateSendCommandRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEventNotificationTemplateSendCommandRequest) Body(body EventNotificationTemplateSendCommandRequest) ApiEventNotificationTemplateSendCommandRequest {
	r.body = &body
	return r
}

func (r ApiEventNotificationTemplateSendCommandRequest) Execute() (*http.Response, error) {
	return r.ApiService.EventNotificationTemplateSendCommandExecute(r)
}

/*
EventNotificationTemplateSendCommand Method for EventNotificationTemplateSendCommand

Clear queue messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEventNotificationTemplateSendCommandRequest
*/
func (a *EventNotificationTemplateApiService) EventNotificationTemplateSendCommand(ctx context.Context) ApiEventNotificationTemplateSendCommandRequest {
	return ApiEventNotificationTemplateSendCommandRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *EventNotificationTemplateApiService) EventNotificationTemplateSendCommandExecute(r ApiEventNotificationTemplateSendCommandRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventNotificationTemplateApiService.EventNotificationTemplateSendCommand")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/eventnotification_eventnotificationtemplate/action/sendCommand"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEventNotificationTemplateUpdateRequest struct {
	ctx context.Context
	ApiService *EventNotificationTemplateApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *EventNotificationTemplateUpdateRequest
}

func (r ApiEventNotificationTemplateUpdateRequest) Ks(ks string) ApiEventNotificationTemplateUpdateRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEventNotificationTemplateUpdateRequest) Format(format int32) ApiEventNotificationTemplateUpdateRequest {
	r.format = &format
	return r
}

func (r ApiEventNotificationTemplateUpdateRequest) ClientTag(clientTag string) ApiEventNotificationTemplateUpdateRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEventNotificationTemplateUpdateRequest) PartnerId(partnerId int32) ApiEventNotificationTemplateUpdateRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEventNotificationTemplateUpdateRequest) Body(body EventNotificationTemplateUpdateRequest) ApiEventNotificationTemplateUpdateRequest {
	r.body = &body
	return r
}

func (r ApiEventNotificationTemplateUpdateRequest) Execute() (*KalturaEventNotificationTemplate, *http.Response, error) {
	return r.ApiService.EventNotificationTemplateUpdateExecute(r)
}

/*
EventNotificationTemplateUpdate Method for EventNotificationTemplateUpdate

Update an existing event notification template object

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEventNotificationTemplateUpdateRequest
*/
func (a *EventNotificationTemplateApiService) EventNotificationTemplateUpdate(ctx context.Context) ApiEventNotificationTemplateUpdateRequest {
	return ApiEventNotificationTemplateUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEventNotificationTemplate
func (a *EventNotificationTemplateApiService) EventNotificationTemplateUpdateExecute(r ApiEventNotificationTemplateUpdateRequest) (*KalturaEventNotificationTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEventNotificationTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventNotificationTemplateApiService.EventNotificationTemplateUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/eventnotification_eventnotificationtemplate/action/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEventNotificationTemplateUpdateStatusRequest struct {
	ctx context.Context
	ApiService *EventNotificationTemplateApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *EventNotificationTemplateUpdateStatusRequest
}

func (r ApiEventNotificationTemplateUpdateStatusRequest) Ks(ks string) ApiEventNotificationTemplateUpdateStatusRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiEventNotificationTemplateUpdateStatusRequest) Format(format int32) ApiEventNotificationTemplateUpdateStatusRequest {
	r.format = &format
	return r
}

func (r ApiEventNotificationTemplateUpdateStatusRequest) ClientTag(clientTag string) ApiEventNotificationTemplateUpdateStatusRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiEventNotificationTemplateUpdateStatusRequest) PartnerId(partnerId int32) ApiEventNotificationTemplateUpdateStatusRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiEventNotificationTemplateUpdateStatusRequest) Body(body EventNotificationTemplateUpdateStatusRequest) ApiEventNotificationTemplateUpdateStatusRequest {
	r.body = &body
	return r
}

func (r ApiEventNotificationTemplateUpdateStatusRequest) Execute() (*KalturaEventNotificationTemplate, *http.Response, error) {
	return r.ApiService.EventNotificationTemplateUpdateStatusExecute(r)
}

/*
EventNotificationTemplateUpdateStatus Method for EventNotificationTemplateUpdateStatus

Update event notification template status by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEventNotificationTemplateUpdateStatusRequest
*/
func (a *EventNotificationTemplateApiService) EventNotificationTemplateUpdateStatus(ctx context.Context) ApiEventNotificationTemplateUpdateStatusRequest {
	return ApiEventNotificationTemplateUpdateStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaEventNotificationTemplate
func (a *EventNotificationTemplateApiService) EventNotificationTemplateUpdateStatusExecute(r ApiEventNotificationTemplateUpdateStatusRequest) (*KalturaEventNotificationTemplate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaEventNotificationTemplate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EventNotificationTemplateApiService.EventNotificationTemplateUpdateStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/eventnotification_eventnotificationtemplate/action/updateStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
