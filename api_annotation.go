/*
Kaltura VPaaS

The Kaltura VPaaS API

API version: 18.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
)


// AnnotationApiService AnnotationApi service
type AnnotationApiService service

type ApiAnnotationAddRequest struct {
	ctx context.Context
	ApiService *AnnotationApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AnnotationAddRequest
}

func (r ApiAnnotationAddRequest) Ks(ks string) ApiAnnotationAddRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiAnnotationAddRequest) Format(format int32) ApiAnnotationAddRequest {
	r.format = &format
	return r
}

func (r ApiAnnotationAddRequest) ClientTag(clientTag string) ApiAnnotationAddRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiAnnotationAddRequest) PartnerId(partnerId int32) ApiAnnotationAddRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiAnnotationAddRequest) Body(body AnnotationAddRequest) ApiAnnotationAddRequest {
	r.body = &body
	return r
}

func (r ApiAnnotationAddRequest) Execute() (*KalturaAnnotation, *http.Response, error) {
	return r.ApiService.AnnotationAddExecute(r)
}

/*
AnnotationAdd Method for AnnotationAdd

Allows you to add an annotation object associated with an entry

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnnotationAddRequest
*/
func (a *AnnotationApiService) AnnotationAdd(ctx context.Context) ApiAnnotationAddRequest {
	return ApiAnnotationAddRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaAnnotation
func (a *AnnotationApiService) AnnotationAddExecute(r ApiAnnotationAddRequest) (*KalturaAnnotation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaAnnotation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnotationApiService.AnnotationAdd")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/annotation_annotation/action/add"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAnnotationAddFromBulkRequest struct {
	ctx context.Context
	ApiService *AnnotationApiService
	fileData **os.File
	ks *string
	format *int32
}

func (r ApiAnnotationAddFromBulkRequest) FileData(fileData *os.File) ApiAnnotationAddFromBulkRequest {
	r.fileData = &fileData
	return r
}

func (r ApiAnnotationAddFromBulkRequest) Ks(ks string) ApiAnnotationAddFromBulkRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiAnnotationAddFromBulkRequest) Format(format int32) ApiAnnotationAddFromBulkRequest {
	r.format = &format
	return r
}

func (r ApiAnnotationAddFromBulkRequest) Execute() (*KalturaCuePointListResponse, *http.Response, error) {
	return r.ApiService.AnnotationAddFromBulkExecute(r)
}

/*
AnnotationAddFromBulk Method for AnnotationAddFromBulk

Allows you to add multiple cue points objects by uploading XML that contains multiple cue point definitions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnnotationAddFromBulkRequest
*/
func (a *AnnotationApiService) AnnotationAddFromBulk(ctx context.Context) ApiAnnotationAddFromBulkRequest {
	return ApiAnnotationAddFromBulkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaCuePointListResponse
func (a *AnnotationApiService) AnnotationAddFromBulkExecute(r ApiAnnotationAddFromBulkRequest) (*KalturaCuePointListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaCuePointListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnotationApiService.AnnotationAddFromBulk")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/annotation_annotation/action/addFromBulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileData == nil {
		return localVarReturnValue, nil, reportError("fileData is required and must be specified")
	}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileDataLocalVarFormFileName string
	var fileDataLocalVarFileName     string
	var fileDataLocalVarFileBytes    []byte

	fileDataLocalVarFormFileName = "fileData"

	fileDataLocalVarFile := *r.fileData
	if fileDataLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(fileDataLocalVarFile)
		fileDataLocalVarFileBytes = fbs
		fileDataLocalVarFileName = fileDataLocalVarFile.Name()
		fileDataLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: fileDataLocalVarFileBytes, fileName: fileDataLocalVarFileName, formFileName: fileDataLocalVarFormFileName})
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAnnotationCloneRequest struct {
	ctx context.Context
	ApiService *AnnotationApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AnnotationCloneRequest
}

func (r ApiAnnotationCloneRequest) Ks(ks string) ApiAnnotationCloneRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiAnnotationCloneRequest) Format(format int32) ApiAnnotationCloneRequest {
	r.format = &format
	return r
}

func (r ApiAnnotationCloneRequest) ClientTag(clientTag string) ApiAnnotationCloneRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiAnnotationCloneRequest) PartnerId(partnerId int32) ApiAnnotationCloneRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiAnnotationCloneRequest) Body(body AnnotationCloneRequest) ApiAnnotationCloneRequest {
	r.body = &body
	return r
}

func (r ApiAnnotationCloneRequest) Execute() (*KalturaAnnotation, *http.Response, error) {
	return r.ApiService.AnnotationCloneExecute(r)
}

/*
AnnotationClone Method for AnnotationClone

Clone cuePoint with id to given entry

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnnotationCloneRequest
*/
func (a *AnnotationApiService) AnnotationClone(ctx context.Context) ApiAnnotationCloneRequest {
	return ApiAnnotationCloneRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaAnnotation
func (a *AnnotationApiService) AnnotationCloneExecute(r ApiAnnotationCloneRequest) (*KalturaAnnotation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaAnnotation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnotationApiService.AnnotationClone")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/annotation_annotation/action/clone"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAnnotationCountRequest struct {
	ctx context.Context
	ApiService *AnnotationApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AnnotationCountRequest
}

func (r ApiAnnotationCountRequest) Ks(ks string) ApiAnnotationCountRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiAnnotationCountRequest) Format(format int32) ApiAnnotationCountRequest {
	r.format = &format
	return r
}

func (r ApiAnnotationCountRequest) ClientTag(clientTag string) ApiAnnotationCountRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiAnnotationCountRequest) PartnerId(partnerId int32) ApiAnnotationCountRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiAnnotationCountRequest) Body(body AnnotationCountRequest) ApiAnnotationCountRequest {
	r.body = &body
	return r
}

func (r ApiAnnotationCountRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.AnnotationCountExecute(r)
}

/*
AnnotationCount Method for AnnotationCount

count cue point objects by filter

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnnotationCountRequest
*/
func (a *AnnotationApiService) AnnotationCount(ctx context.Context) ApiAnnotationCountRequest {
	return ApiAnnotationCountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return int32
func (a *AnnotationApiService) AnnotationCountExecute(r ApiAnnotationCountRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnotationApiService.AnnotationCount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/annotation_annotation/action/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAnnotationDeleteRequest struct {
	ctx context.Context
	ApiService *AnnotationApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AnnotationDeleteRequest
}

func (r ApiAnnotationDeleteRequest) Ks(ks string) ApiAnnotationDeleteRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiAnnotationDeleteRequest) Format(format int32) ApiAnnotationDeleteRequest {
	r.format = &format
	return r
}

func (r ApiAnnotationDeleteRequest) ClientTag(clientTag string) ApiAnnotationDeleteRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiAnnotationDeleteRequest) PartnerId(partnerId int32) ApiAnnotationDeleteRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiAnnotationDeleteRequest) Body(body AnnotationDeleteRequest) ApiAnnotationDeleteRequest {
	r.body = &body
	return r
}

func (r ApiAnnotationDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.AnnotationDeleteExecute(r)
}

/*
AnnotationDelete Method for AnnotationDelete

delete cue point by id, and delete all children cue points

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnnotationDeleteRequest
*/
func (a *AnnotationApiService) AnnotationDelete(ctx context.Context) ApiAnnotationDeleteRequest {
	return ApiAnnotationDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AnnotationApiService) AnnotationDeleteExecute(r ApiAnnotationDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnotationApiService.AnnotationDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/annotation_annotation/action/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAnnotationGetRequest struct {
	ctx context.Context
	ApiService *AnnotationApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AnnotationDeleteRequest
}

func (r ApiAnnotationGetRequest) Ks(ks string) ApiAnnotationGetRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiAnnotationGetRequest) Format(format int32) ApiAnnotationGetRequest {
	r.format = &format
	return r
}

func (r ApiAnnotationGetRequest) ClientTag(clientTag string) ApiAnnotationGetRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiAnnotationGetRequest) PartnerId(partnerId int32) ApiAnnotationGetRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiAnnotationGetRequest) Body(body AnnotationDeleteRequest) ApiAnnotationGetRequest {
	r.body = &body
	return r
}

func (r ApiAnnotationGetRequest) Execute() (*KalturaCuePoint, *http.Response, error) {
	return r.ApiService.AnnotationGetExecute(r)
}

/*
AnnotationGet Method for AnnotationGet

Retrieve an CuePoint object by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnnotationGetRequest
*/
func (a *AnnotationApiService) AnnotationGet(ctx context.Context) ApiAnnotationGetRequest {
	return ApiAnnotationGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaCuePoint
func (a *AnnotationApiService) AnnotationGetExecute(r ApiAnnotationGetRequest) (*KalturaCuePoint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaCuePoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnotationApiService.AnnotationGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/annotation_annotation/action/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAnnotationListRequest struct {
	ctx context.Context
	ApiService *AnnotationApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AnnotationListRequest
}

func (r ApiAnnotationListRequest) Ks(ks string) ApiAnnotationListRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiAnnotationListRequest) Format(format int32) ApiAnnotationListRequest {
	r.format = &format
	return r
}

func (r ApiAnnotationListRequest) ClientTag(clientTag string) ApiAnnotationListRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiAnnotationListRequest) PartnerId(partnerId int32) ApiAnnotationListRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiAnnotationListRequest) Body(body AnnotationListRequest) ApiAnnotationListRequest {
	r.body = &body
	return r
}

func (r ApiAnnotationListRequest) Execute() (*KalturaAnnotationListResponse, *http.Response, error) {
	return r.ApiService.AnnotationListExecute(r)
}

/*
AnnotationList Method for AnnotationList

List annotation objects by filter and pager

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnnotationListRequest
*/
func (a *AnnotationApiService) AnnotationList(ctx context.Context) ApiAnnotationListRequest {
	return ApiAnnotationListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaAnnotationListResponse
func (a *AnnotationApiService) AnnotationListExecute(r ApiAnnotationListRequest) (*KalturaAnnotationListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaAnnotationListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnotationApiService.AnnotationList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/annotation_annotation/action/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAnnotationServeBulkRequest struct {
	ctx context.Context
	ApiService *AnnotationApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AnnotationListRequest
}

func (r ApiAnnotationServeBulkRequest) Ks(ks string) ApiAnnotationServeBulkRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiAnnotationServeBulkRequest) Format(format int32) ApiAnnotationServeBulkRequest {
	r.format = &format
	return r
}

func (r ApiAnnotationServeBulkRequest) ClientTag(clientTag string) ApiAnnotationServeBulkRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiAnnotationServeBulkRequest) PartnerId(partnerId int32) ApiAnnotationServeBulkRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiAnnotationServeBulkRequest) Body(body AnnotationListRequest) ApiAnnotationServeBulkRequest {
	r.body = &body
	return r
}

func (r ApiAnnotationServeBulkRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.AnnotationServeBulkExecute(r)
}

/*
AnnotationServeBulk Method for AnnotationServeBulk

Download multiple cue points objects as XML definitions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnnotationServeBulkRequest
*/
func (a *AnnotationApiService) AnnotationServeBulk(ctx context.Context) ApiAnnotationServeBulkRequest {
	return ApiAnnotationServeBulkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *AnnotationApiService) AnnotationServeBulkExecute(r ApiAnnotationServeBulkRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnotationApiService.AnnotationServeBulk")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/annotation_annotation/action/serveBulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAnnotationUpdateRequest struct {
	ctx context.Context
	ApiService *AnnotationApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AnnotationUpdateRequest
}

func (r ApiAnnotationUpdateRequest) Ks(ks string) ApiAnnotationUpdateRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiAnnotationUpdateRequest) Format(format int32) ApiAnnotationUpdateRequest {
	r.format = &format
	return r
}

func (r ApiAnnotationUpdateRequest) ClientTag(clientTag string) ApiAnnotationUpdateRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiAnnotationUpdateRequest) PartnerId(partnerId int32) ApiAnnotationUpdateRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiAnnotationUpdateRequest) Body(body AnnotationUpdateRequest) ApiAnnotationUpdateRequest {
	r.body = &body
	return r
}

func (r ApiAnnotationUpdateRequest) Execute() (*KalturaAnnotation, *http.Response, error) {
	return r.ApiService.AnnotationUpdateExecute(r)
}

/*
AnnotationUpdate Method for AnnotationUpdate

Update annotation by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnnotationUpdateRequest
*/
func (a *AnnotationApiService) AnnotationUpdate(ctx context.Context) ApiAnnotationUpdateRequest {
	return ApiAnnotationUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaAnnotation
func (a *AnnotationApiService) AnnotationUpdateExecute(r ApiAnnotationUpdateRequest) (*KalturaAnnotation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaAnnotation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnotationApiService.AnnotationUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/annotation_annotation/action/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAnnotationUpdateCuePointsTimesRequest struct {
	ctx context.Context
	ApiService *AnnotationApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AnnotationUpdateCuePointsTimesRequest
}

func (r ApiAnnotationUpdateCuePointsTimesRequest) Ks(ks string) ApiAnnotationUpdateCuePointsTimesRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiAnnotationUpdateCuePointsTimesRequest) Format(format int32) ApiAnnotationUpdateCuePointsTimesRequest {
	r.format = &format
	return r
}

func (r ApiAnnotationUpdateCuePointsTimesRequest) ClientTag(clientTag string) ApiAnnotationUpdateCuePointsTimesRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiAnnotationUpdateCuePointsTimesRequest) PartnerId(partnerId int32) ApiAnnotationUpdateCuePointsTimesRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiAnnotationUpdateCuePointsTimesRequest) Body(body AnnotationUpdateCuePointsTimesRequest) ApiAnnotationUpdateCuePointsTimesRequest {
	r.body = &body
	return r
}

func (r ApiAnnotationUpdateCuePointsTimesRequest) Execute() (*KalturaCuePoint, *http.Response, error) {
	return r.ApiService.AnnotationUpdateCuePointsTimesExecute(r)
}

/*
AnnotationUpdateCuePointsTimes Method for AnnotationUpdateCuePointsTimes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnnotationUpdateCuePointsTimesRequest
*/
func (a *AnnotationApiService) AnnotationUpdateCuePointsTimes(ctx context.Context) ApiAnnotationUpdateCuePointsTimesRequest {
	return ApiAnnotationUpdateCuePointsTimesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaCuePoint
func (a *AnnotationApiService) AnnotationUpdateCuePointsTimesExecute(r ApiAnnotationUpdateCuePointsTimesRequest) (*KalturaCuePoint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaCuePoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnotationApiService.AnnotationUpdateCuePointsTimes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/annotation_annotation/action/updateCuePointsTimes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAnnotationUpdateStatusRequest struct {
	ctx context.Context
	ApiService *AnnotationApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *AnnotationUpdateStatusRequest
}

func (r ApiAnnotationUpdateStatusRequest) Ks(ks string) ApiAnnotationUpdateStatusRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiAnnotationUpdateStatusRequest) Format(format int32) ApiAnnotationUpdateStatusRequest {
	r.format = &format
	return r
}

func (r ApiAnnotationUpdateStatusRequest) ClientTag(clientTag string) ApiAnnotationUpdateStatusRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiAnnotationUpdateStatusRequest) PartnerId(partnerId int32) ApiAnnotationUpdateStatusRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiAnnotationUpdateStatusRequest) Body(body AnnotationUpdateStatusRequest) ApiAnnotationUpdateStatusRequest {
	r.body = &body
	return r
}

func (r ApiAnnotationUpdateStatusRequest) Execute() (*http.Response, error) {
	return r.ApiService.AnnotationUpdateStatusExecute(r)
}

/*
AnnotationUpdateStatus Method for AnnotationUpdateStatus

Update cuePoint status by id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAnnotationUpdateStatusRequest
*/
func (a *AnnotationApiService) AnnotationUpdateStatus(ctx context.Context) ApiAnnotationUpdateStatusRequest {
	return ApiAnnotationUpdateStatusRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AnnotationApiService) AnnotationUpdateStatusExecute(r ApiAnnotationUpdateStatusRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnotationApiService.AnnotationUpdateStatus")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/annotation_annotation/action/updateStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
