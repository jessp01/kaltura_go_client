/*
Kaltura VPaaS

The Kaltura VPaaS API

API version: 18.12.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
)


// DocumentsApiService DocumentsApi service
type DocumentsApiService service

type ApiDocumentsAddFromEntryRequest struct {
	ctx context.Context
	ApiService *DocumentsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *DocumentsAddFromEntryRequest
}

func (r ApiDocumentsAddFromEntryRequest) Ks(ks string) ApiDocumentsAddFromEntryRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiDocumentsAddFromEntryRequest) Format(format int32) ApiDocumentsAddFromEntryRequest {
	r.format = &format
	return r
}

func (r ApiDocumentsAddFromEntryRequest) ClientTag(clientTag string) ApiDocumentsAddFromEntryRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiDocumentsAddFromEntryRequest) PartnerId(partnerId int32) ApiDocumentsAddFromEntryRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiDocumentsAddFromEntryRequest) Body(body DocumentsAddFromEntryRequest) ApiDocumentsAddFromEntryRequest {
	r.body = &body
	return r
}

func (r ApiDocumentsAddFromEntryRequest) Execute() (*KalturaDocumentEntry, *http.Response, error) {
	return r.ApiService.DocumentsAddFromEntryExecute(r)
}

/*
DocumentsAddFromEntry Method for DocumentsAddFromEntry

Copy entry into new entry

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDocumentsAddFromEntryRequest
*/
func (a *DocumentsApiService) DocumentsAddFromEntry(ctx context.Context) ApiDocumentsAddFromEntryRequest {
	return ApiDocumentsAddFromEntryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaDocumentEntry
func (a *DocumentsApiService) DocumentsAddFromEntryExecute(r ApiDocumentsAddFromEntryRequest) (*KalturaDocumentEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaDocumentEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentsApiService.DocumentsAddFromEntry")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/document_documents/action/addFromEntry"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocumentsAddFromFlavorAssetRequest struct {
	ctx context.Context
	ApiService *DocumentsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *DocumentsAddFromFlavorAssetRequest
}

func (r ApiDocumentsAddFromFlavorAssetRequest) Ks(ks string) ApiDocumentsAddFromFlavorAssetRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiDocumentsAddFromFlavorAssetRequest) Format(format int32) ApiDocumentsAddFromFlavorAssetRequest {
	r.format = &format
	return r
}

func (r ApiDocumentsAddFromFlavorAssetRequest) ClientTag(clientTag string) ApiDocumentsAddFromFlavorAssetRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiDocumentsAddFromFlavorAssetRequest) PartnerId(partnerId int32) ApiDocumentsAddFromFlavorAssetRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiDocumentsAddFromFlavorAssetRequest) Body(body DocumentsAddFromFlavorAssetRequest) ApiDocumentsAddFromFlavorAssetRequest {
	r.body = &body
	return r
}

func (r ApiDocumentsAddFromFlavorAssetRequest) Execute() (*KalturaDocumentEntry, *http.Response, error) {
	return r.ApiService.DocumentsAddFromFlavorAssetExecute(r)
}

/*
DocumentsAddFromFlavorAsset Method for DocumentsAddFromFlavorAsset

Copy flavor asset into new entry

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDocumentsAddFromFlavorAssetRequest
*/
func (a *DocumentsApiService) DocumentsAddFromFlavorAsset(ctx context.Context) ApiDocumentsAddFromFlavorAssetRequest {
	return ApiDocumentsAddFromFlavorAssetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaDocumentEntry
func (a *DocumentsApiService) DocumentsAddFromFlavorAssetExecute(r ApiDocumentsAddFromFlavorAssetRequest) (*KalturaDocumentEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaDocumentEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentsApiService.DocumentsAddFromFlavorAsset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/document_documents/action/addFromFlavorAsset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocumentsAddFromUploadedFileRequest struct {
	ctx context.Context
	ApiService *DocumentsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *DocumentsAddFromUploadedFileRequest
}

func (r ApiDocumentsAddFromUploadedFileRequest) Ks(ks string) ApiDocumentsAddFromUploadedFileRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiDocumentsAddFromUploadedFileRequest) Format(format int32) ApiDocumentsAddFromUploadedFileRequest {
	r.format = &format
	return r
}

func (r ApiDocumentsAddFromUploadedFileRequest) ClientTag(clientTag string) ApiDocumentsAddFromUploadedFileRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiDocumentsAddFromUploadedFileRequest) PartnerId(partnerId int32) ApiDocumentsAddFromUploadedFileRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiDocumentsAddFromUploadedFileRequest) Body(body DocumentsAddFromUploadedFileRequest) ApiDocumentsAddFromUploadedFileRequest {
	r.body = &body
	return r
}

func (r ApiDocumentsAddFromUploadedFileRequest) Execute() (*KalturaDocumentEntry, *http.Response, error) {
	return r.ApiService.DocumentsAddFromUploadedFileExecute(r)
}

/*
DocumentsAddFromUploadedFile Method for DocumentsAddFromUploadedFile

Add new document entry after the specific document file was uploaded and the upload token id exists

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDocumentsAddFromUploadedFileRequest
*/
func (a *DocumentsApiService) DocumentsAddFromUploadedFile(ctx context.Context) ApiDocumentsAddFromUploadedFileRequest {
	return ApiDocumentsAddFromUploadedFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaDocumentEntry
func (a *DocumentsApiService) DocumentsAddFromUploadedFileExecute(r ApiDocumentsAddFromUploadedFileRequest) (*KalturaDocumentEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaDocumentEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentsApiService.DocumentsAddFromUploadedFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/document_documents/action/addFromUploadedFile"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocumentsApproveReplaceRequest struct {
	ctx context.Context
	ApiService *DocumentsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryApproveRequest
}

func (r ApiDocumentsApproveReplaceRequest) Ks(ks string) ApiDocumentsApproveReplaceRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiDocumentsApproveReplaceRequest) Format(format int32) ApiDocumentsApproveReplaceRequest {
	r.format = &format
	return r
}

func (r ApiDocumentsApproveReplaceRequest) ClientTag(clientTag string) ApiDocumentsApproveReplaceRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiDocumentsApproveReplaceRequest) PartnerId(partnerId int32) ApiDocumentsApproveReplaceRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiDocumentsApproveReplaceRequest) Body(body BaseEntryApproveRequest) ApiDocumentsApproveReplaceRequest {
	r.body = &body
	return r
}

func (r ApiDocumentsApproveReplaceRequest) Execute() (*KalturaDocumentEntry, *http.Response, error) {
	return r.ApiService.DocumentsApproveReplaceExecute(r)
}

/*
DocumentsApproveReplace Method for DocumentsApproveReplace

Approves document replacement

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDocumentsApproveReplaceRequest
*/
func (a *DocumentsApiService) DocumentsApproveReplace(ctx context.Context) ApiDocumentsApproveReplaceRequest {
	return ApiDocumentsApproveReplaceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaDocumentEntry
func (a *DocumentsApiService) DocumentsApproveReplaceExecute(r ApiDocumentsApproveReplaceRequest) (*KalturaDocumentEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaDocumentEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentsApiService.DocumentsApproveReplace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/document_documents/action/approveReplace"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocumentsCancelReplaceRequest struct {
	ctx context.Context
	ApiService *DocumentsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryApproveRequest
}

func (r ApiDocumentsCancelReplaceRequest) Ks(ks string) ApiDocumentsCancelReplaceRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiDocumentsCancelReplaceRequest) Format(format int32) ApiDocumentsCancelReplaceRequest {
	r.format = &format
	return r
}

func (r ApiDocumentsCancelReplaceRequest) ClientTag(clientTag string) ApiDocumentsCancelReplaceRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiDocumentsCancelReplaceRequest) PartnerId(partnerId int32) ApiDocumentsCancelReplaceRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiDocumentsCancelReplaceRequest) Body(body BaseEntryApproveRequest) ApiDocumentsCancelReplaceRequest {
	r.body = &body
	return r
}

func (r ApiDocumentsCancelReplaceRequest) Execute() (*KalturaDocumentEntry, *http.Response, error) {
	return r.ApiService.DocumentsCancelReplaceExecute(r)
}

/*
DocumentsCancelReplace Method for DocumentsCancelReplace

Cancels document replacement

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDocumentsCancelReplaceRequest
*/
func (a *DocumentsApiService) DocumentsCancelReplace(ctx context.Context) ApiDocumentsCancelReplaceRequest {
	return ApiDocumentsCancelReplaceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaDocumentEntry
func (a *DocumentsApiService) DocumentsCancelReplaceExecute(r ApiDocumentsCancelReplaceRequest) (*KalturaDocumentEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaDocumentEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentsApiService.DocumentsCancelReplace")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/document_documents/action/cancelReplace"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocumentsConvertRequest struct {
	ctx context.Context
	ApiService *DocumentsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *DocumentsConvertRequest
}

func (r ApiDocumentsConvertRequest) Ks(ks string) ApiDocumentsConvertRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiDocumentsConvertRequest) Format(format int32) ApiDocumentsConvertRequest {
	r.format = &format
	return r
}

func (r ApiDocumentsConvertRequest) ClientTag(clientTag string) ApiDocumentsConvertRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiDocumentsConvertRequest) PartnerId(partnerId int32) ApiDocumentsConvertRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiDocumentsConvertRequest) Body(body DocumentsConvertRequest) ApiDocumentsConvertRequest {
	r.body = &body
	return r
}

func (r ApiDocumentsConvertRequest) Execute() (int32, *http.Response, error) {
	return r.ApiService.DocumentsConvertExecute(r)
}

/*
DocumentsConvert Method for DocumentsConvert

Convert entry

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDocumentsConvertRequest
*/
func (a *DocumentsApiService) DocumentsConvert(ctx context.Context) ApiDocumentsConvertRequest {
	return ApiDocumentsConvertRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return int32
func (a *DocumentsApiService) DocumentsConvertExecute(r ApiDocumentsConvertRequest) (int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentsApiService.DocumentsConvert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/document_documents/action/convert"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocumentsConvertPptToSwfRequest struct {
	ctx context.Context
	ApiService *DocumentsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryApproveRequest
}

func (r ApiDocumentsConvertPptToSwfRequest) Ks(ks string) ApiDocumentsConvertPptToSwfRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiDocumentsConvertPptToSwfRequest) Format(format int32) ApiDocumentsConvertPptToSwfRequest {
	r.format = &format
	return r
}

func (r ApiDocumentsConvertPptToSwfRequest) ClientTag(clientTag string) ApiDocumentsConvertPptToSwfRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiDocumentsConvertPptToSwfRequest) PartnerId(partnerId int32) ApiDocumentsConvertPptToSwfRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiDocumentsConvertPptToSwfRequest) Body(body BaseEntryApproveRequest) ApiDocumentsConvertPptToSwfRequest {
	r.body = &body
	return r
}

func (r ApiDocumentsConvertPptToSwfRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.DocumentsConvertPptToSwfExecute(r)
}

/*
DocumentsConvertPptToSwf Method for DocumentsConvertPptToSwf

This will queue a batch job for converting the document file to swf

Returns the URL where the new swf will be available

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDocumentsConvertPptToSwfRequest
*/
func (a *DocumentsApiService) DocumentsConvertPptToSwf(ctx context.Context) ApiDocumentsConvertPptToSwfRequest {
	return ApiDocumentsConvertPptToSwfRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DocumentsApiService) DocumentsConvertPptToSwfExecute(r ApiDocumentsConvertPptToSwfRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentsApiService.DocumentsConvertPptToSwf")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/document_documents/action/convertPptToSwf"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocumentsDeleteRequest struct {
	ctx context.Context
	ApiService *DocumentsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryApproveRequest
}

func (r ApiDocumentsDeleteRequest) Ks(ks string) ApiDocumentsDeleteRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiDocumentsDeleteRequest) Format(format int32) ApiDocumentsDeleteRequest {
	r.format = &format
	return r
}

func (r ApiDocumentsDeleteRequest) ClientTag(clientTag string) ApiDocumentsDeleteRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiDocumentsDeleteRequest) PartnerId(partnerId int32) ApiDocumentsDeleteRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiDocumentsDeleteRequest) Body(body BaseEntryApproveRequest) ApiDocumentsDeleteRequest {
	r.body = &body
	return r
}

func (r ApiDocumentsDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.DocumentsDeleteExecute(r)
}

/*
DocumentsDelete Method for DocumentsDelete

Delete a document entry.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDocumentsDeleteRequest
*/
func (a *DocumentsApiService) DocumentsDelete(ctx context.Context) ApiDocumentsDeleteRequest {
	return ApiDocumentsDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DocumentsApiService) DocumentsDeleteExecute(r ApiDocumentsDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentsApiService.DocumentsDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/document_documents/action/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDocumentsGetRequest struct {
	ctx context.Context
	ApiService *DocumentsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *BaseEntryGetRequest
}

func (r ApiDocumentsGetRequest) Ks(ks string) ApiDocumentsGetRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiDocumentsGetRequest) Format(format int32) ApiDocumentsGetRequest {
	r.format = &format
	return r
}

func (r ApiDocumentsGetRequest) ClientTag(clientTag string) ApiDocumentsGetRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiDocumentsGetRequest) PartnerId(partnerId int32) ApiDocumentsGetRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiDocumentsGetRequest) Body(body BaseEntryGetRequest) ApiDocumentsGetRequest {
	r.body = &body
	return r
}

func (r ApiDocumentsGetRequest) Execute() (*KalturaDocumentEntry, *http.Response, error) {
	return r.ApiService.DocumentsGetExecute(r)
}

/*
DocumentsGet Method for DocumentsGet

Get document entry by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDocumentsGetRequest
*/
func (a *DocumentsApiService) DocumentsGet(ctx context.Context) ApiDocumentsGetRequest {
	return ApiDocumentsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaDocumentEntry
func (a *DocumentsApiService) DocumentsGetExecute(r ApiDocumentsGetRequest) (*KalturaDocumentEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaDocumentEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentsApiService.DocumentsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/document_documents/action/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocumentsListRequest struct {
	ctx context.Context
	ApiService *DocumentsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *DocumentsListRequest
}

func (r ApiDocumentsListRequest) Ks(ks string) ApiDocumentsListRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiDocumentsListRequest) Format(format int32) ApiDocumentsListRequest {
	r.format = &format
	return r
}

func (r ApiDocumentsListRequest) ClientTag(clientTag string) ApiDocumentsListRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiDocumentsListRequest) PartnerId(partnerId int32) ApiDocumentsListRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiDocumentsListRequest) Body(body DocumentsListRequest) ApiDocumentsListRequest {
	r.body = &body
	return r
}

func (r ApiDocumentsListRequest) Execute() (*KalturaDocumentListResponse, *http.Response, error) {
	return r.ApiService.DocumentsListExecute(r)
}

/*
DocumentsList Method for DocumentsList

List document entries by filter with paging support.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDocumentsListRequest
*/
func (a *DocumentsApiService) DocumentsList(ctx context.Context) ApiDocumentsListRequest {
	return ApiDocumentsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaDocumentListResponse
func (a *DocumentsApiService) DocumentsListExecute(r ApiDocumentsListRequest) (*KalturaDocumentListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaDocumentListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentsApiService.DocumentsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/document_documents/action/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocumentsServeRequest struct {
	ctx context.Context
	ApiService *DocumentsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *DocumentsServeRequest
}

func (r ApiDocumentsServeRequest) Ks(ks string) ApiDocumentsServeRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiDocumentsServeRequest) Format(format int32) ApiDocumentsServeRequest {
	r.format = &format
	return r
}

func (r ApiDocumentsServeRequest) ClientTag(clientTag string) ApiDocumentsServeRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiDocumentsServeRequest) PartnerId(partnerId int32) ApiDocumentsServeRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiDocumentsServeRequest) Body(body DocumentsServeRequest) ApiDocumentsServeRequest {
	r.body = &body
	return r
}

func (r ApiDocumentsServeRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.DocumentsServeExecute(r)
}

/*
DocumentsServe Method for DocumentsServe

Serves the file content

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDocumentsServeRequest
*/
func (a *DocumentsApiService) DocumentsServe(ctx context.Context) ApiDocumentsServeRequest {
	return ApiDocumentsServeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DocumentsApiService) DocumentsServeExecute(r ApiDocumentsServeRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentsApiService.DocumentsServe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/document_documents/action/serve"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocumentsServeByFlavorParamsIdRequest struct {
	ctx context.Context
	ApiService *DocumentsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *DocumentsServeByFlavorParamsIdRequest
}

func (r ApiDocumentsServeByFlavorParamsIdRequest) Ks(ks string) ApiDocumentsServeByFlavorParamsIdRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiDocumentsServeByFlavorParamsIdRequest) Format(format int32) ApiDocumentsServeByFlavorParamsIdRequest {
	r.format = &format
	return r
}

func (r ApiDocumentsServeByFlavorParamsIdRequest) ClientTag(clientTag string) ApiDocumentsServeByFlavorParamsIdRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiDocumentsServeByFlavorParamsIdRequest) PartnerId(partnerId int32) ApiDocumentsServeByFlavorParamsIdRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiDocumentsServeByFlavorParamsIdRequest) Body(body DocumentsServeByFlavorParamsIdRequest) ApiDocumentsServeByFlavorParamsIdRequest {
	r.body = &body
	return r
}

func (r ApiDocumentsServeByFlavorParamsIdRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.DocumentsServeByFlavorParamsIdExecute(r)
}

/*
DocumentsServeByFlavorParamsId Method for DocumentsServeByFlavorParamsId

Serves the file content

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDocumentsServeByFlavorParamsIdRequest
*/
func (a *DocumentsApiService) DocumentsServeByFlavorParamsId(ctx context.Context) ApiDocumentsServeByFlavorParamsIdRequest {
	return ApiDocumentsServeByFlavorParamsIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DocumentsApiService) DocumentsServeByFlavorParamsIdExecute(r ApiDocumentsServeByFlavorParamsIdRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentsApiService.DocumentsServeByFlavorParamsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/document_documents/action/serveByFlavorParamsId"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocumentsUpdateRequest struct {
	ctx context.Context
	ApiService *DocumentsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *DocumentsUpdateRequest
}

func (r ApiDocumentsUpdateRequest) Ks(ks string) ApiDocumentsUpdateRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiDocumentsUpdateRequest) Format(format int32) ApiDocumentsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiDocumentsUpdateRequest) ClientTag(clientTag string) ApiDocumentsUpdateRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiDocumentsUpdateRequest) PartnerId(partnerId int32) ApiDocumentsUpdateRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiDocumentsUpdateRequest) Body(body DocumentsUpdateRequest) ApiDocumentsUpdateRequest {
	r.body = &body
	return r
}

func (r ApiDocumentsUpdateRequest) Execute() (*KalturaDocumentEntry, *http.Response, error) {
	return r.ApiService.DocumentsUpdateExecute(r)
}

/*
DocumentsUpdate Method for DocumentsUpdate

Update document entry. Only the properties that were set will be updated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDocumentsUpdateRequest
*/
func (a *DocumentsApiService) DocumentsUpdate(ctx context.Context) ApiDocumentsUpdateRequest {
	return ApiDocumentsUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaDocumentEntry
func (a *DocumentsApiService) DocumentsUpdateExecute(r ApiDocumentsUpdateRequest) (*KalturaDocumentEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaDocumentEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentsApiService.DocumentsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/document_documents/action/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocumentsUpdateContentRequest struct {
	ctx context.Context
	ApiService *DocumentsApiService
	ks *string
	format *int32
	clientTag *string
	partnerId *int32
	body *DocumentsUpdateContentRequest
}

func (r ApiDocumentsUpdateContentRequest) Ks(ks string) ApiDocumentsUpdateContentRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiDocumentsUpdateContentRequest) Format(format int32) ApiDocumentsUpdateContentRequest {
	r.format = &format
	return r
}

func (r ApiDocumentsUpdateContentRequest) ClientTag(clientTag string) ApiDocumentsUpdateContentRequest {
	r.clientTag = &clientTag
	return r
}

func (r ApiDocumentsUpdateContentRequest) PartnerId(partnerId int32) ApiDocumentsUpdateContentRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiDocumentsUpdateContentRequest) Body(body DocumentsUpdateContentRequest) ApiDocumentsUpdateContentRequest {
	r.body = &body
	return r
}

func (r ApiDocumentsUpdateContentRequest) Execute() (*KalturaDocumentEntry, *http.Response, error) {
	return r.ApiService.DocumentsUpdateContentExecute(r)
}

/*
DocumentsUpdateContent Method for DocumentsUpdateContent

Replace content associated with the given document entry.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDocumentsUpdateContentRequest
*/
func (a *DocumentsApiService) DocumentsUpdateContent(ctx context.Context) ApiDocumentsUpdateContentRequest {
	return ApiDocumentsUpdateContentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KalturaDocumentEntry
func (a *DocumentsApiService) DocumentsUpdateContentExecute(r ApiDocumentsUpdateContentRequest) (*KalturaDocumentEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KalturaDocumentEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentsApiService.DocumentsUpdateContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/document_documents/action/updateContent"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	if r.clientTag != nil {
		localVarQueryParams.Add("clientTag", parameterToString(*r.clientTag, ""))
	}
	if r.partnerId != nil {
		localVarQueryParams.Add("partnerId", parameterToString(*r.partnerId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocumentsUploadRequest struct {
	ctx context.Context
	ApiService *DocumentsApiService
	fileData **os.File
	ks *string
	format *int32
}

// The file data
func (r ApiDocumentsUploadRequest) FileData(fileData *os.File) ApiDocumentsUploadRequest {
	r.fileData = &fileData
	return r
}

func (r ApiDocumentsUploadRequest) Ks(ks string) ApiDocumentsUploadRequest {
	r.ks = &ks
	return r
}

// The format of the response
func (r ApiDocumentsUploadRequest) Format(format int32) ApiDocumentsUploadRequest {
	r.format = &format
	return r
}

func (r ApiDocumentsUploadRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.DocumentsUploadExecute(r)
}

/*
DocumentsUpload Method for DocumentsUpload

Upload a document file to Kaltura, then the file can be used to create a document entry.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDocumentsUploadRequest

Deprecated
*/
func (a *DocumentsApiService) DocumentsUpload(ctx context.Context) ApiDocumentsUploadRequest {
	return ApiDocumentsUploadRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
// Deprecated
func (a *DocumentsApiService) DocumentsUploadExecute(r ApiDocumentsUploadRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DocumentsApiService.DocumentsUpload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/document_documents/action/upload"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileData == nil {
		return localVarReturnValue, nil, reportError("fileData is required and must be specified")
	}

	if r.ks != nil {
		localVarQueryParams.Add("ks", parameterToString(*r.ks, ""))
	}
	if r.format != nil {
		localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileDataLocalVarFormFileName string
	var fileDataLocalVarFileName     string
	var fileDataLocalVarFileBytes    []byte

	fileDataLocalVarFormFileName = "fileData"

	fileDataLocalVarFile := *r.fileData
	if fileDataLocalVarFile != nil {
		fbs, _ := ioutil.ReadAll(fileDataLocalVarFile)
		fileDataLocalVarFileBytes = fbs
		fileDataLocalVarFileName = fileDataLocalVarFile.Name()
		fileDataLocalVarFile.Close()
	}
	formFiles = append(formFiles, formFile{fileBytes: fileDataLocalVarFileBytes, fileName: fileDataLocalVarFileName, formFileName: fileDataLocalVarFormFileName})
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ks"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("ks", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
